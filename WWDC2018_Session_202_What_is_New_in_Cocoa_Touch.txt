좋아, 좋은 아침.
 오늘 아침 코코아 터치의 새로운 기능을 모두 배우셔서 고마워요.
 지금 평상시, Eliza는 당신이 단지 나로부터 소식을 듣고있을 예정이지만 올해 조금 나중에 나에게 가입 할 것이다.
 그래서, 그녀는 나중에 년 후에 돌아올거야.
 그것에 대해 걱정하지 마십시오.
 오늘 아침에 우리는 세 가지 주요 범주에 대해 이야기 할 것입니다.
 우리는 성능 및 보안과 같은 몇 가지 프레임 워크 업데이트부터 시작하겠습니다.
 그런 다음 알림 및 메시지를 비롯하여 SDK에있는 다양한 기존 API에 대한 몇 가지 API 개선 사항에 대해 설명 할 것입니다.
 그리고 나서 우리는 Siri Shortcuts로 끝낼 것입니다.
 첫 번째 주제 인 성능 업데이트를 시작합시다.
 이제 스크롤, 메모리 및 자동 레이아웃과 같은 세 가지 주요 영역에서 성능에 대해 살펴 보겠습니다.
 이제 우리가 들어가기 전에 스크롤에 관한 약간의 배경 지식을 염두에 두는 것이 중요합니다.
 iOS에서 스크롤하는 것은 대부분의 장소에서 꽤 일반적인 패턴을 따릅니다.
 우리는보기에 표시 할 내용을로드하고 그 내용을 주변으로 이동합니다.
 그리고 우리가 그것을 움직이는 동안, 우리는 새로운 것을로드 할 필요가 없기 때문에 대부분의 프레임은 생성하기가 정말로 싸다.
 그러나 지금은 언제나 새로운 시각이 보입니다. 첫 번째 프레임이 생성 될 때 한 프레임은 생성되는 데 비용이 많이 들지만, 다른 프레임은 생성되지 않습니다.
 이제는 한 프레임이로드되고 나면 콘텐츠를 돌아 다니기 만하면됩니다. 따라서 CPU에서 수행하는 작업의 양은 다른 대부분의 스크롤에서 꽤 작아집니다.
 그래서 다른 모든 것보다 더 많은 것을 초래하는 정말 고가의 틀에서 어떤 일이 일어나고 있습니까? 관점 UI 표보기를 살펴 보도록하겠습니다. 그러나 여기에서 살펴본 모든 내용은 UI Collection View 또는 실제로 비슷한 방식으로 동작 할 수있는 사용자 지정보기에 대해 실제로 동일합니다.
 따라서 값 비싼 프레임의 작업은 TableView의 구현에서 시작될 것입니다. For Row At 인덱스 경로 대리자 메서드.
 이제 우리가 할 일은 우리가 표시하고 싶은 셀을 얻는 것입니다.
 재사용 대기열에서 이상적으로 대기열에서 대기열에서 제외하고 대기열에서 대기열에서 탈출하려고 시도합니다. 아직 대기열에 대기열이 없으면 실제로 준비하기 위해 일부 할당을해야 할 수도 있습니다.
 셀이 생기면 모델 데이터를 채 웁니다.
 이제는 애플리케이션에 따라 비용이 얼마나 비싸지 만 파일 읽기, 데이터베이스에서 데이터로드 또는 그 밖의 자연스러운 작업과 같이 많은 양의 값 비싼 작업을 포함 할 수 있습니다.
 그래서 당신은 분명히 여기에 자신의 애플 리케이션에서 비용을보고 싶어하지만, 그것이 어디에 그것의 좋은 부분이 존재하는 경향이 있습니다.
 자, 여러분은 그것이 값 비싼 작업의 끝이라고 생각할 수 있습니다.하지만 일단이 방법으로 돌아 오더라도 실제로 셀을 화면에 표시 할 준비가 되려면 더 많은 작업이 필요합니다.
 따라서, 다음으로, 우리는 그 셀에있는 모든 내용을 배치해야합니다.
 우리는 모든 견해의 크기를 정하고 올바른 위치에 배치해야합니다.
 이제는 실제로 텍스트를 측정하는 것과 같은 다른 비싼 작업을 포함 할 수 있기 때문에 우리가 소비하는 총 시간 중 상당 부분이 될 수 있습니다.
 일단 모든 것이 적절하게 크기 조정되고 배치되면 도면 호출을 사용하여 그려야 할 내용을 생성하고 해당 셀 내의 모든 하위 뷰에 대해 Draw Rect를 호출해야합니다.
 다시 말하지만, 텍스트를 그리는 것과 같은 일을하기 때문에 시간이 많이 걸릴 수도 있습니다.
 전반적으로이 코드 전체에 걸쳐 발생해야하는 많은 작업이 있으며 실제로는 매우 짧은 시간 내에 발생해야합니다.
 60 헤르츠 기기의 경우 프레임을 버리지 않고 원활한 스크롤을 유지하기 위해 모든 작업을 완료하는 데 16 밀리 초가 걸립니다.
 우리의 12 헤르쯔 iPads에, iPad 직업에, 당신은 그 일 전부를 완료하기 위하여 단지 8 밀리 세컨드가있다.
 따라서 가능한 한 빨리 완료해야합니다.
 이제는 iOS 10에서 셀 프리 페치 API를 소개했으며 프리 페치 API를 사용하여 아이디어를 얻은 다음이 작업 중 일부를 수행하여 셀에 모델 데이터를 채우고이 중요한 섹션에서 가져옵니다. 짧은 창에서의 요구, 일찍 처리, 백그라운드 스레드에서의 작업 등 다른 작업과 비동기 적으로 발생할 수 있습니다. 특히 우리가 이야기 한 값싼 프레임을 비동기 적으로 처리 할 수 ​​있습니다.
 이제 이것을 채택하는 것은 정말 쉽습니다.
 UI 테이블 뷰 데이터 소스 프리 페치 프로토콜 일 뿐이며 실제로는 두 가지 방법 중 하나만 필요합니다.
 그리고 여기에있는 아이디어는 파일에서 물건을로드하거나 데이터베이스를 읽는 비싼 작업을 필요에 따라 수행 할 필요가 없도록 이동하는 것입니다.

셀 표시가 필요할 때 데이터가 이미 준비되어 있습니다.
 대부분의 경우 iOS 12에서 자체 앱 중 일부를 볼 때 실제로이 문제가 Google을 돕는 대신 문제를 일으키고있는 것으로 나타났습니다.
 그럼 어떻게 생겼는지 살펴 보겠습니다.
 다음은 iPhone 6 Plus에서 스크롤하는 동안 사용한 추적의 예입니다.
 상단에있는 세로 막대는 표시 할 프레임을 나타냅니다.
 번갈아가는 밝은 색과 어두운 파란색 색은 우리가 변경 한 프레임을 나타냅니다.
 그리고 그 두배의 밝은 파란색 막대는 두 개의 전체 프레임 기간 동안 동일한 프레임을 그렸습니다.
 따라서 이러한 상황이 발생하는 동안 기기를보고있는 고객의 경우, 이는 떨어 뜨린 프레임 또는 스크롤링 장애와 유사합니다. 이는 분명히 우리가 피하려고하는 것입니다.
 이 경우 무슨 일이 일어 났습니까? 여기서 빨간색 막대는 방금 이야기 한 중요한 부분에서 소비하는 시간, 모든 자기 인식 할 수없는 색인 경로, 레이아웃 및 그림을 나타냅니다.
 그리고 여기에 실제로 프레임을 그려야하는 16 밀리 초보다 오래 걸립니다.
 이제 장치가 고정 된 위치에서 새 프레임을 화면에 스왑 할 수 있기 때문에 일단 마감 시간을 놓치게되면 두 프레임의 전체 프레임을 동일한 프레임으로 표시하는 결과를 낳았습니다.
 그런데 왜 여기에서 일어 났습니까? 이 경우 우리는 실제로 셀 프리 페칭 (prefetching) 메소드를 구현 한 앱을 찾고 있으므로 데이터가 준비되어야합니다.
 이상적으로 이것은 더 빨리 수행 될 수있었습니다.
 우리가 추적을 좀 더 살펴보면, 무슨 일이 일어나고 있는지 알 수 있습니다.
 셀 프리 페치 API가 현재 셀을 요청하는 것과 동시에 호출되었습니다.
 이제 현재 셀의 데이터를 호출하지 않았습니다.
 그것은 우리가 미래의 세포에서 필요할지도 모르는 데이터를 요청 받았지만, 동시에 실행되고있었습니다.
 그래서 우리는 현재 프레임을로드하고 아직 실제로 필요하지 않은 미래 프레임의 데이터를로드하려고 시도하면서 CPU에 대한 논쟁이있었습니다.
 그래서 그 논쟁으로 인해 실제로 두 가지 작업 모두 조금 더 오랜 시간이 걸렸습니다.
 이제 iOS 12에서 이러한 백그라운드 프리 페치 작업을 예약하는 것이 훨씬 더 지능적이어서 동시 발생과 일부 CPU 경합을 일으키지 않고 연속적으로 실행되므로 현재 셀을로드하는 데 걸리는 시간이 단축되고 많은 경우 프레임이 떨어지는 것을 방지합니다.
 일단 우리가 고정시켜 주면 우리는 앱을 계속 프로파일 링하고 실제로 프레임이 떨어지는 놀라운 원인이있는 또 다른 사례를 발견했습니다.
 이제 우리가 발견 한 것은 기기가 부하가 걸리지 않았을 때 백그라운드 작업이 없었기 때문에 포어 그라운드 앱에서 스크롤하는 것뿐이었습니다.
 반 직관적으로, 약간의 밝은 배경 작업이 진행될 때 우리는 실제로 시간보다 더 많은 프레임을 떨어 뜨릴 수 있습니다.
 그건별로 의미가 없었습니다.
 그리고 왜 그런 일이 발생했는지 이해하기 위해 작업 부하를 예약 할 때 CPU의 동작을 한 단계 아래로 내려 봐야했습니다.
 그럼 다른 흔적을 살펴 봅시다.
 여기에서도 동일한 상황이 발생합니다.
 더블 와이드 블루 바는 우리가 프레임을 떨어 뜨리거나 오히려 떨어 뜨린 프레임입니다.
 이제 여기서 CPU 성능에 대한 그래프를 볼 수 있습니다.
 대부분의 값싼 프레임 중에는 CPU 성능이 매우 낮습니다.
 계속 배경 작업이 없습니다.
 우리가하는 일은 스크롤하는 것입니다. 스크롤하는 데 드는 비용이 많이 드는 작업을 수행하지 않을 때는 가능한 한 CPU를 낮게 유지하여 배터리 수명을 보존해야하기 때문에 원하는 것이 맞을 것입니다.
 그래서 위대했습니다.
 그다지 좋지 않은 것은 그것이 진입하기까지 약간의 시간이 걸렸다는 것입니다.
 어제 기조 연설에서이 얘기를 들었습니까?
 이제 마침내 램프가 올라 왔을 때 이미 표시해야하는 셀을로드하는 작업을 완료하는 데는 너무 늦었습니다. 그래서 프레임을 다시 잃어 버렸습니다.
 이제 우리는 전체 소프트웨어 스택을 위에서부터 아래로 소유하고 있기 때문에 iOS 12에서는 상위 UIKit 프레임 워크에있는 모든 정보를 스크롤이 발생하는 시점과 이러한 중요한 부분이 발생하는 시점 및 모든 정보를 통과시키는 정보를 가져 왔습니다 낮은 수준의 CPU 성능 컨트롤러에 연결하여 현재 진행중인 작업에 대해 훨씬 지능적으로 추론 할 수 있고 이러한 버스트가 발생할시기와 앱의 과거 수요에 대한 최종 기한을 충족시키기 위해 필요한 CPU 성능을 예측할 수 있습니다. 했다.
 따라서 부하가 바로 여기서 시작된 변화가 일어나면 우리는 CPU를 훨씬 더 자주 또는 더 신속하게 그 마감 시간에 맞추기 위해 필요한 정확한 수행량을 얻었습니다. 프레임을 떨어 뜨리지 마십시오.
 이로 인해 iOS 관련 여러 가지 다양한 스크롤 시나리오에서 큰 개선이 이루어졌습니다.

따라서 모든 응용 프로그램에서이 향상된 기능과 그 밖의 여러 기능을 무료로 제공받을 수 있습니다. 그러나 가장 많은 작업을 수행 할 수있는 몇 가지 방법이 있습니다 둘 다에서.
 먼저, tableView 셀 프리 페치 API 또는 콜렉션 뷰 프리젠 테이션을 아직 채택하지 않았다면, 데이터를 준비하는 것이 셀로드가 빠른지 확인하는 가장 좋은 방법 중 하나이기 때문에 확실히 살펴보십시오. 가능한 한.
 물론 셀로드의 전체 중요 섹션을 프로파일 링하고 가능한 한 많이 줄이는 것이 중요합니다.
 iOS 12는이 기간 동안 CPU 성능을 응용 프로그램의 요구 사항과 일치 시키려고 시도하지만 할 수있는 최선의 방법은 고객에게 다음과 같은 사항을 제공하기 위해 수행해야하는 작업량을 줄이기위한 것입니다. 정말 부드러운 스크롤링 경험.
 그래서 iOS 12에서 스크롤됩니다.
 다음으로 우리의 다음 성과 주제 인 메모리에 대해 알아 보겠습니다.
 이제 성능 토론의 중간에 메모리가 왜 등장하고 있는지 궁금해 할 것입니다.하지만 실제로는 많은 의미가 있으며 메모리가 실제로 성능이기 때문에 그 이유가 확실합니다.
 앱이 사용할 메모리가 많을수록 애플리케이션 성능에 더 많은 영향을 미칩니다.
 그 이유를 이해하기 위해 일반적인 상황에서 시스템의 전체 메모리가 어떻게 보이는지에 대한 매우 높은 수준의 개요를 살펴 보겠습니다.
 물론 여기서 볼 수 있듯이 많은 시스템 메모리가 다른 응용 프로그램과 시스템 자체에서 사용되고 있습니다.
 앱에서 잠시 동안 사용하고 있습니다.
 그리고 새로운 할당 요청을 서비스 할 때 무료로 제공되는 서비스도 있습니다.
 이제, 그 기억의 대부분은 아마도 진정한 자유가 아닙니다.
 메모리가 즉시 수요를 충족시킬 수 있는지 확인하기 위해 신속하게 버려지는 캐시 나 다른 것들을 포함 할 가능성이 높지만 일반적으로 실제로는 실제로 뭔가 사용되고 있지만 쉽게 사용할 수 있습니다.
 이제 애플리케이션이 메모리를 요청할 때 어떤 일이 일어나는지 살펴 보겠습니다.
 어쩌면 당신은 작은 요청을하게 될 것입니다. 이것은 현재 무료 풀에서 사용할 수있는 양만큼 만족 될 수 있습니다.
 글쎄, 그렇다면 앱으로 곧 돌아갈 것이고, 작업을 계속할 수 있습니다.
 하지만 이제는 응용 프로그램이 더 큰 요청을하고 오랜 시간 동안 필요하지 않을 수도 있으므로 실제로 걱정할 필요는 없습니다.
 디스크에서 이미지를로드하고 압축을 풀고 일부 픽셀에 대해 빠른 작업을 수행 한 다음 버릴 수 있습니다.
 따라서 너무 걱정하지 않아도되는 빠른 작업처럼 보입니다.
 글쎄요, 우리는 그 큰 요청을 할 것이고, 현재는 시스템이 현재 쉽게 이용할 수있는 더 많은 메모리입니다.
 따라서 즉시 만족할 수 없으며 다른 곳에서 그 기억을 찾아야 할 것입니다.
 실제로, 가장 유력한 장소는 시스템상의 다른 응용 프로그램이나 사물에서옵니다.
 이제는 앱에 대한 기억을 얻으려고하기 때문에 걱정하지 않을 것입니다. 그래서 다른 곳에서 무슨 일이 일어나고 있는지 걱정하지 않아도됩니다.
 그러나 이것은 나중에 고객이 기대할 수있는 다른 것에 영향을 미칠 것입니다.하지만 더 중요한 것은 지금 당장은 시스템이 작업을해야하기 때문에 앱에도 영향을 미칩니다. 가서이 기억을 가져와.
 쉽게 사용할 수 없다는 사실은 커널이이를 찾아서 CPU에서 작업을 수행하여 사용 가능하게해야 함을 의미합니다.
 그리고 그 시간은 당신을 위해 그 기억을 얻는 데 쓰고 있습니다. 당신의 앱이 무엇이든 최선을 다하는 데 더 많은 시간을 할애 할 수있는 시간입니다.
 따라서 이러한 더 큰 요청을 청크하거나 전반적인 최대 수요를 줄이는 방법을 찾는 것은 앱을 사용하는 동안 앱의 성능에 큰 영향을 줄 수 있으며 나중에 다른 앱에서 고객 경험을 향상시킬 수 있습니다.
 따라서 앱의 총 메모리 사용량을 줄이고 프로필과 도구로 시작하는 것이 여러모로 볼 수 있습니다.
 하지만 오늘 아침에는 iOS 12가 가져다주는 새로운 기술 중 하나를 살펴보고 앱의 메모리 사용을 줄이는 데 도움이되는 기능을 살펴 보겠습니다. 자동 백업 스토어입니다.
 그래서 우리가 iPhone X에서 초상화 모드로이 게으른 프레리 도그를 그리기를 원한다고 가정 해 봅시다.
 그게 얼마나 커요? iPhone X의 세로 모드, 가로 375 포인트, 가로 세로 비율을 유지하려면 250 포인트의 키가 필요합니다.
 얼마나 많은 기억이 사용됩니까? 음, 375 x 250 (3x), 픽셀 당 64 비트 (깊은 컬러 장치이기 때문에)는 2가 될 것입니다.
프레리 도그를 그리는 데 2 ​​메가 바이트의 메모리가 필요합니다.
 그것은 꽤 괜찮은 양처럼 보입니다. 그러나이 경우 실제로는 아마도 잘 소비 된 기억 일 것입니다.

우리는 실제로이 완전 충실도의 이미지를 나타 내기 위해 노력하고 있습니다. 그리고 그것은이 버퍼에 이미지를 그리는 데 필요한 메모리 용량입니다.
 아마도 그렇게 예상됩니다.
 그러나 우리가 우리의 프레리 도그의 더 충실도가 낮은 버전을 그려야한다고 가정 해 봅시다. 아마도 흑백 그래픽을 사용하여 스케치 할 것입니다. 아마도 iPad에 Apple 연필로 그린 것일 수도 있습니다.
 그것은 이런 모습 일 겁니다.
 우리 충실도가 낮은 프레리 도그가 얼마나 많은 기억을 사용합니까? 음, 정확히 같은 양의 메모리를 사용합니다.
 이제 여기에 분명히 기억의 사용이 좋지 않습니다.
 모든 회색 음영입니다.
 그 딥 컬러 정보는 모두이 이미지에서 사용되지 않습니다.
 그래서 우리는 훨씬 더 잘할 수 있었고, iOS 12는 자동 백킹 스토어 지원을 도입하여 정확하게 지원할 수있게되었습니다.
 이제 draw Rect를 구현 한 모든 뷰에는 그려진 내용의 깊이에 따라 정의 된 배킹 스토어가 있습니다.
 따라서 Core Graphics를 사용하여 그레이 스케일 컨텐츠 만 스케치하는 경우 실제로 픽셀 당 64 비트 대신 8 비트 픽셀 백킹 저장소가 자동으로 사용됩니다.
 이렇게하면 그려진 뷰에 대한 메모리 요구량이 2에서 275KB로 줄어 듭니다.
2 메가 바이트.
 그것은 당신과 우리 둘다 많은 다른 응용 프로그램에 걸쳐 정말 큰 개선입니다.
 자동 백업 스토어는 기본적으로 iOS 12 SDK로 제작 된 모든 앱에 사용됩니다.
 UIView에서 Rect 그리기의 모든 구현은 UI 그래픽 이미지 렌더러를 사용하여 오프 스크린 비트 맵에 그리는 모든 콘텐츠뿐만 아니라 자동으로이 작업을 수행합니다.
 이제 UI Graphics Image Renderer의 경우 최종적으로 얻은 이미지로 수행 할 작업을 계획 할 필요가 없습니다.
 따라서 이미지 렌더러에서 원하는대로 자동 동작이 아니라는 사실을 알고있는 경우 새로운 Range API를 사용하여 확장 범위를 구체적으로 지정하는 등 원하는 특정 배킹 스토어 스타일을 지정할 수 있습니다 영상.
 이번 주말에는 이미지 및 그래픽 모범 사례 세션에서 UI 이미지를 중심으로이 기술에 대해 자세히 배울 수 있습니다.
 성능면에서는 두 번째입니다.
 다음으로 자동 레이아웃으로 넘어 갑시다.
 이제 iOS 10의 자동 레이아웃에는 몇 가지 큰 개선 사항이 있습니다.
 팀은 가능한 한 앱의 자동 레이아웃을 최적화하기 위해 엄청나게 노력했습니다.
 iOS 12에서는 기본적으로 자동 레이아웃이 더 빨라졌습니다.
 우리는 많은 경우에 대해 이야기 할 것입니다.
 그러나 Auto Layout을 프로파일 링하고 최적화하는 동안 그들은 많은 자체 앱에서 시스템을 조사하고 Auto Layout을 어떻게 사용했는지에 대해 알아 보았습니다. .
 따라서 앱 레이아웃을 최적화하기 위해 따라갈 수있는 간단한 모범 사례를 보여 드리겠습니다.
 오늘 아침에 일부 일반적인 사용자 시나리오에서보기를 추가함에 따라 자동 레이아웃의 점근 현상을 살펴봄으로써 iOS 12에서 자동 레이아웃이 기본적으로 더 빠르다는 것을 보도록하겠습니다.
 이제는 우리가보기의 수를 극적으로 증가시킬 때 어떤 일이 일어나는지 실제로보고 싶어하기 때문에 점근선을보고 있습니다.
 이것은 우리가 정말보기에 엄청나게 많은 수의보기로 갈 때 성능 문제를 빠르게 나타낼 수 있습니다.
 그것은 단지 우리가 그것을 보는데 도움이됩니다.
 최적화는 실제로 적은 수의 뷰에도 적용하고 빠르게 처리합니다.
 그래서 가장 공통적 인 패턴, 가장 간단한 경우부터 시작하겠습니다. 일부 컨테이너 내부의 독립 형제 뷰.
 이제 이러한 뷰는 컨테이너 나 다른 뷰에 대해 제약을두고 배치되지만 서로에 대해 제약을받지는 않습니다.
 그들은 서로 독립적입니다.
 이제 iOS 11에서 계속해서 더 많은 것을 추가하면서 이러한 독립 형제 자매의 비용은 선형 적으로 증가했습니다.
 그래서 실제로 꽤 좋습니다.
 그것은 바로 이와 같은 상황에서 기대할 수있는 것입니다.
 기본적으로 우리가 말한 것은 다른 뷰와 독립적으로 배치 된 계층에 추가 한 새로운 뷰를 추가 할 때마다 고정 된 일정한 비용이 있다는 것입니다.
 이제는 우리가 예상 한 지수로 이미 성장했기 때문에 iOS 12의 경우에도 그대로 남아 있습니다. 그러나 팀은 가능한 한 추가 할 값이 싼 추가보기를 만들기 위해 일정한 비용을 줄이기 위해 열심히 노력했습니다.
 그럼 다음에 좀 더 재미있는 예를 살펴 보겠습니다.
 이 경우 Dependent Siblings를 살펴볼 것입니다.
 그래서 당신은 여러개의 자식 뷰를 가지고 있고 그것들은 현재 서로간에 제약이 있습니다.
 그래서 그들의 레이아웃은 서로 의존적입니다.
 불행히도, iOS 11에서는 여기에있는 점근 적 표현이 아주 좋지 않다는 것을 알게 될 것입니다.
 실제로, 그것은 기하 급수적으로 증가하고있었습니다.
 따라서 추가 한 뷰가 많을수록 더 많은 뷰를 추가 할 수 있습니다.

이제 팀은이 기하 급수적 인 성장의 원천을 확인하고 알고리즘을 수정하여 더 이상 그렇지 않게되었습니다.
 그래서 iOS 12에서는 이제 선형으로 커집니다.
 물론, 팀은 또한 이러한 경우에 대한 지속적인 비용을 줄이기 위해 노력하고 있습니다.
 이제 종속 형제 외에도 찾을 수있는 또 다른 일반적인 유형의 레이아웃이 있는데 중첩 된 뷰는 한 뷰가 다른 뷰의 내부에 있고 외부 뷰에 대한 제한이있을 때입니다.
 이것은 분명히 앱에서 꽤 흔한 패턴이며, 불행히도 여기 iOS 11에서도 기하 급수적으로 증가한 것으로 나타났습니다.
 그리고 다시 좋은 소식입니다.
 이 팀은 iOS 12에서도이 기능을 선형으로 만들었습니다.
 따라서 iOS 12의 자동 레이아웃에는 여러 가지 큰 개선 사항이 있으며 iOS 12에서 직접 실행하기 시작하면 바로 이러한 개선 사항을 앱에서 볼 수 있습니다.
 그 모든 것에 대해 더 배우고, 더 나은 감각을 얻고, 다양한 레이아웃의 성능에 대한 느낌을 얻는 방법에 대한 좋은 감각을 개발하고 여기에 공통적 인 함정이라고 말한 이들 주제 중 일부가 있습니다.
 이번 주말 고성능 오토 레이아웃 대화를 꼭 확인하십시오.
 최종 프레임 워크 업데이트 주제에 대해서는 Swiftification으로 넘어 갑시다.
 당신이 들었을 때, iOS 12는 Swift 4를 소개합니다.
2.
 그리고 스위프트 4.
2 우리는 정말 UIKit이 앱 전반에 걸쳐 Swift에서 사용되었을 때 특히 Swift가 일반적인 패턴을 가진 다른 Swift Standard Library 또는 장소와 상호 작용할 때 정말 좋은 느낌을 주길 원했습니다.
 그래서 우리는 모든 UIKit을 감사하고 모든 것이 실제로 자연스럽게 맞는 것처럼 느껴지도록했습니다.
 더 나아가 우리는 UIKit에 대한 모든 변경 사항을 자동으로 마이그레이션 할 수 있도록 했으므로 이러한 업데이트를 얻으려면 추가 작업이 필요하지 않습니다.
 이제이 업데이트는 실제로 아침에 이야기 할 세 가지 범주로 나뉩니다. SDK를 살펴보면 실제로 개선 및 일관성이 많이 개선됩니다.
 그러나 오늘날 우리는 유형, 상수 및 함수의 중첩에 대해 이야기 할 것입니다.
 먼저 중첩 유형을 살펴 보겠습니다.
 이제 Swift 4에는 글로벌 네임 스페이스에있는 여러 유형이있었습니다 (UI Application State와 같은 것).
 이와 같이 다른 클래스와 함께 사용되는 유형의 경우이 클래스 내에이 클래스를 중첩했습니다.
 그래서 우리는이 모든 종류의 열거 형과 다른 전역 유형을 살펴 보았고 관련 클래스의 하위 유형으로 이동했습니다.
 그래서 이것은 UIApplication이됩니다.
상태.
 이것은이 두 가지 사이의 관계에 대해 훨씬 더 강력한 메시지를 보내고 쉽게 찾을 수있게합니다.
 이제는 이해력을 높이고 혼란을 없애는 데 도움이 될 수 있습니다.
 이 경우 UI 탭 표시 줄 항목 위치 지정을 살펴 보겠습니다.
 이제 UITabBarItemPositioning 또는 UITabBarItem 포지셔닝이라고 생각하십니까? 그것은 실제로 둘 중 하나 일 수 있습니다.
 둘 다 클래스입니다.

그리고 Swift 42에서는 실제로 UITabBar ItemPositioning이라는 것이 완벽하게 분명합니다.
 따라서 중첩 된 유형 외에도 많은 상수를 중첩했습니다.
 따라서 스위프트 4를 살펴보면 NS 알림이 모두 글로벌 NSNotification에 포함되어있었습니다.
Name 네임 스페이스와 관련 사용자 정보 키는 실제로 실제로 떠 다니는 전역 상수였습니다.
 따라서 AppKit과의 일관성을 유지하고 이러한 유형을 쉽게 찾고 연관 시키려면 이제는 함께 사용되는 클래스 아래에 중첩되어 있습니다.
 그래서 변경 상태 표시 줄 방향이 UI 아래에 있습니다. 응용 프로그램이 변경 상태 표시 줄 방향 알림 및 해당 사용자 정보 키가 함께 이동하여 모두 함께 배치되었습니다.
 이제 우리는 UIKit 전체에서 다른 모든 전역 상수를 감사하고 적절한 위치에 모두 중첩했습니다.
 따라서 UI Float Range Zero 및 UI Float Range Infinite와 같은 항목은 UI Float Range의 속성이 될뿐만 아니라 찾기 쉽고 사용하기 쉽습니다.
 UI Float Range를 사용할 수있는 곳에서 그냥 입력 할 수 있습니다.
0 또는.
무한하고 사실은 이제 속성이기 때문에 Xcode는 사용자를 감안할 때 자동 완성 기능으로 제안 할 수 있습니다.
 이제 상수 외에도 우리는 모든 글로벌 기능을 감사했습니다.
 그래서 UI Edge Insert와 UI Image 같은 것들은 다른 유형의 운영을위한 전역 기능을 가지고있었습니다.
 이제 Swift 4에서.
2, 이들은 적절한 유형의 메소드가되었다.
 이제는 Rect에서 삽입하거나 Png Data를 이미지에서 가져 오는 것이 정말 자연스럽고 신속한 느낌의 방법입니다.
 이제는 내가 오늘 아침에 언급하고자하는 또 하나의 큰 클래스의 함수가있었습니다. UIKit, CGPoint, CGRect, CGSize, CGVector에있는 모든 유형의 모든 문자열 변환 함수였습니다. 로트에서 문자열을주고받을 수 있습니다.
 이제 우리는 이것들을보고 어디로 가야 할지를 결정할 때 실제로 두 가지 유스 케이스가 있음을 깨달았습니다.
 하나는 인코딩 및 디코딩을위한 것입니다.
 그러나 다른 것은 디버그 설명을 얻으려고 할 때 주로 인쇄하는 데 사용된다는 것입니다.
 두 가지 용도가 매우 다르지만 실제로 Swift는이 두 가지 경우에 대해 일류급 지원을 제공합니다.
 그래서 우리는 이러한 모든 유형이 Swift의 내장형 지원과 함께 정말 잘 작동하는지 확인했습니다.
 그래서 Swift 4에서.
2에서 이러한 유형은 모두 Codable을 준수하므로 이러한 모든 유형의 JSON을 인코딩 및 디코딩하는 것과 같은 작업을 매우 쉽게 수행 할 수 있습니다.
 물론 Swift에서의 디버그 인쇄는 실제로 Objective-C보다 더 쉽습니다. 추가 변환을 할 필요가 없기 때문입니다.
 유형의 내장 된 내 향 검사를 사용하면 직접 인쇄 할 수 있습니다.
 그래서 Swift 4에서.
2, 디버그 목적으로 인쇄하거나 로그하려면 인쇄 유형에 직접이 유형을 직접 전달하십시오.
 마지막으로 이전 문자열 변환 함수의 비헤이비어를 사용하는 기존 코드가 이미 있고 호환되는 기능이 필요할 수도 있습니다.
 그래서 우리는 실제로이 모든 것들의 이름을 바꾸었고 그것들을 NSCoder의 속성으로 옮겼습니다.
 이것은 실제로 이러한 메소드의 의도가 인코딩 및 디코딩에 사용된다는 사실을 강조하는 데 도움이되므로, 거기에 들어가는 것이 매우 자연스럽게 맞습니다.
 따라서 이는 Swift 4 용 iOS 12 SDK에서 찾을 수있는 몇 가지 일관성 개선 사항에 불과합니다.
2 그러나 당신은 더 많은 것을 또한 발견 할 것이다.
 이제 인코딩 및 디코딩, NS 보안 코딩에 대해 말하면서 iOS 12에는 기본적으로 새로운 보안 인코딩 및 디코딩 API가 추가되었습니다.
 NS Keyed Archiver에서 모든 인코딩 요구에 맞는 NS 보안 코딩을 채택하는 것은 악의적 인 데이터와 손상된 데이터로부터 고객을 보호하는 데있어 핵심입니다.
 또한 오래된 안전하지 않은 API는 더 이상 사용되지 않습니다.
 따라서 목요일 오전 9시에 신뢰할 수있는 데이터 (Data You Can Trust Session)에서 모든 것을 배우고 자세한 내용을 알 수 있습니다.
엠.
 이것이 프레임 워크 업데이트입니다.
 다음으로 기존 API에 대한 몇 가지 개선 사항을 살펴보고 알림부터 시작하겠습니다.
 알림에는 iOS 12의 여러 가지 큰 개선 사항이 있지만 오늘 아침에만 세 개에 집중할 예정입니다.
 맞춤 알림 내의 상호 작용, 알림 그룹화, 앱 내 알림 설정 액세스
 그럼 상호 작용으로 시작합시다.
 이제 사용자 정의 알림은 잠시 동안 이러한 알림에 대한 미리 정의 된 동작 집합을 정의 할 수있게되었습니다.
 iOS 12에서이 일련의 동작은 더 이상 정적이 아닙니다.
 프로그래밍 방식으로 정의 할 수 있으며 런타임에 변경할 수 있습니다.
 이러한 작업 외에도 알림 자체가 대화 형으로 처리 될 수 있습니다.
 예를 들어, 여기에서는 메시지를 통해 해당 알림에서 직접 메시지 인라인에 신속하게 응답 할 수 있음을 알 수 있습니다.

이제 상호 작용 외에도 iOS 12에는 기본적으로 알림 그룹이 포함되어 있으며 기본 동작은 특정 앱에 대한 모든 알림을 단일 그룹으로 그룹화하는 것입니다.
 물론 iMessage와 같이 특정 대화의 모든 메시지를 그룹화하고 해당 앱의 나머지 모든 알림과는 별도로 그룹화 할 수 있도록 앱을 맞춤 설정할 필요가있을 수 있습니다.
 이제는 특정 스레드 식별자로 알림을 태그 지정하고 해당 위협 식별자에 대한 모든 알림을 단일 그룹에 표시하여 앱에서이를 채택 할 수 있습니다.
 이제 iOS 12의 알림 UI 업데이트에는 사용자가 알림 전달 작업을 맞춤 설정할 수있는 몇 가지 새로운 기능이 포함되어 있습니다.
 물론, 앱에는 알림 관리를위한 기존의보다 세분화 된 컨트롤도 포함될 수 있습니다.
 또한 iOS 12에는 고객이보다 세분화 된 컨트롤을 원하는 경우 알림 설정 UI에 직접 연결될 수있는 새로운 API가 도입되었습니다.
 따라서 이번 주말에는 사용자 알림의 새로운 기능과 그룹화 된 알림 사용에 대한 모든 공지 사항에 대해 자세히 알 수 있습니다.
 알림입니다.
 다음은 메시지에 대해 이야기 해 봅시다.
 이제 iOS 12의 메시지에는 카메라의 새롭고 흥미로운 기능이 포함되어 있습니다.
 또한 모든 iMessage 스티커를 카메라에 직접 가져올 수 있습니다.
 Xcode 스티커 템플릿을 사용하는 경우 기본적으로 추가 작업없이 자동으로 작동합니다.
 그러나 MS 메시지 앱 뷰 컨트롤러를 사용하여 더 많은 맞춤형 스티커 경험을 구축하려는 경우 약간의 채택이 필요합니다.
 이제 사용자 정보 plist에 추가 할 수있는 새로운 MS Messages Supported Presentation Contexts API가 있으며 메시지 컨텍스트와 미디어 컨텍스트 둘 다에 표시되도록 지정할 수 있습니다.
 이렇게하면 앱이 앱 스트립과 카메라에 모두 나타납니다.
 이제 런타임시에 당신이 어떤 컨텍스트를 가지고 있는지 알아야 할 필요가 있습니다. 예를 들어 스티커 표시를 약간 사용자 정의하고 싶다면, 새로운 API도 있습니다.
 프레젠테이션 컨텍스트를 확인하여 메시지 또는 카메라에 있는지 빠르게 확인할 수 있습니다.
 이제 이러한 기능 외에도 iOS 12는 메시지 앱과 상호 작용할 수있는 새로운 기능을 제공합니다.
 컴팩트 모드에서 이전에 메시지 앱에서 가로로 아래로 스 와이프하면 앱간에 전환됩니다.
 iOS 12에서는 가로로 움직이는 수평 스 와이프와 상호 작용이 이제 앱에서 직접 사용할 수 있으므로 다른 앱으로 전환하는 대신 앱과 상호 작용할 수 있습니다.
 그리고 그것은 메시지입니다.
 다음은 자동 암호 및 보안 코드 자동 채우기에 대해 설명 합니다.
 이제 iOS 11은 자동 암호 또는 암호 입력을 응용 프로그램에 도입했습니다.
 그리고 iOS 12에서는이를 한 걸음 더 나아가고 있습니다.
 하지만 처음으로 돌아가서 전체 경험에 대해 이야기합시다.
 따라서 iCloud Keychain에 비밀번호가 저장되어있는 사용자의 경우 iOS 11부터 로그인 흐름에서 앱에 자동으로 입력되도록 할 수 있습니다.
 이제 iOS 12에서 이러한 암호는 로그인 윈도우 흐름과 암호 변경 요청 UI에서 응용 프로그램의 iCloud Keychain에 저장할 수 있습니다.
 사용자가 로그인하면 암호를 iCloud Keychain에 저장하라는 메시지가 표시됩니다.
 이제는 iOS 12가 새 계정 흐름과 비밀번호 변경 흐름에서 자동으로 암호를 생성 할 수 있습니다.
 이것을 채택하는 것은 정말로 쉽습니다.
 비밀번호 입력란이 비밀번호 입력란 인 경우 암호 텍스트 콘텐츠 유형으로 태그를 지정했는지 또는 새 계정 또는 비밀번호 변경 입력란 인 경우 새 비밀번호 텍스트 콘텐츠 유형으로 태그 입력란을 지정했는지 확인하면됩니다.
 예를 들어 필수 또는 허용되지 않은 문자가 있거나 반복되는 최대 문자 수와 같은 다른 요구 사항이있는 경우 서비스에 암호에 대한 특정 요구 사항이있는 경우 이러한 요구 사항을 지정하여 자동으로 생성 된 암호가 완전히 모든 요구 사항과 호환됩니다.
 이제 로그인 경험 중 마지막 마찰은 두 가지 요소의 인증 코드를 가져 와서 문자 메시지와 앱으로 가져와야하는 경우입니다.
 IOS 12는 이러한 알림을 자동으로 식별하여 보안 코드에 주목하고 Quick Type 후보 바에 바로 제안하여 앱에 바로 적용하기 쉽도록 만듭니다.
 이제 앱에서이 기능이 작동하는지 확인하기 위해 수행해야하는 유일한 작업은 표준 iOS 텍스트 상호 작용 API를 사용하여 이러한 비밀번호를 허용하는지 확인하는 것입니다.

이러한 새로운 기능을 모두 갖춘 iOS 12는 기억할 필요가 없거나 다시 입력 할 필요가없는 모든 서비스에 고유하고 강력한 암호를 사용하여 훨씬 더 안전한 미래를 실현합니다.
 이번 주말에 자동 강력한 암호 및 보안 코드 자동 완성 세션에서이 모든 것을 배울 수 있습니다.
 이제 최종 API 향상 주제는 실제로 약간의 리뷰이지만 조금 더 많은 컨텍스트가 있습니다.
 그래서 iOS 11에서는 Safe Area insets를 도입했습니다.
 안전한 영역 인세 트는 콘텐츠가 화면 상단과 하단의 막대와 같이 사용자 인터페이스의 다른 부분과 겹치지 않도록하는 훌륭한 방법입니다.
 이것은 바가 꽤 간단하지만 정말 강력합니다.
 안전한 영역 인세 트는 애플리케이션의 모든 뷰의 로컬 좌표 공간에서 안전 영역 좌표를 제공하므로 iPad와 같은 훨씬 복잡한 인터페이스까지도 확장 할 수 있습니다. 분할의 마스터 및 세부면에 다른 높이 막대가 있습니다 전망.
 이 막대 아래에있는보기의 안전 영역 삽입은 분할의 측면에있는 막대에 의해 겹쳐지는 양에 적합합니다.
 따라서 직사각형 화면이있는 기기에서는 정말 좋지만 아이폰 X와 같은 직사각형이 아닌 화면에서는 정말 강력합니다.
 자, 홈 단추가있는 장치보다 위쪽과 아래쪽에 큰 막대가 있다는 것을 알 수 있습니다.
 안전 영역 삽입물은 분명 더 큰 크기를 수용 할 수 있도록 확장되었습니다.
 iPhone X의 독특한 점은 막대가없는 경우에도 안전 영역 인세 트가 있다는 것입니다.이 기능은 가로 모드를 확장하여 실제로 안전하고 직사각형 영역이 있는지 확인하는 데 도움이됩니다. 콘텐츠를 표시하며 절대로 자르지 않습니다.
 그래서 안전 영역 삽입물을 채택하고 iPhone X 용 앱을 업데이트 한 분들께 감사드립니다.
 작년에 정말 좋은 경험이었고, 이미 여러분 대부분이 이미 그렇게 해왔습니다.
 그렇지 않다면 지금은 정말 좋은 시간입니다.
 고객은 항상 최신 상태로 유지되는 앱을 선호 할 것이며 iPhone X에 대한 지원은 그 사실을 실제로 볼 수있는 지표입니다.
 그렇게하지 않았다면 지금 당장 해보십시오.
 그리고 필요한 모든 정보가 있는지 확인하기 위해 이번 주 후반에 모든 크기 및 모양 세션에 대한 UIKit Apps를 확인하면 안전 영역 인세 트 및 기타 관련된 모든 인세 트 API에 대해 모두 알 수 있습니다. UIKit 전체에서 모든 모양과 크기로 확장 가능한 앱을 쉽게 만들 수 있습니다.
 이것이 바로 우리의 프레임 워크 업데이트와 API 향상입니다.
 다음으로 Siri Shortcuts에 대해 이야기 해 봅시다.
 따라서 Siri Shortcuts는 iOS 12의 흥미 진진한 새로운 API입니다.
 Siri Shortcuts를 사용하면 일반적인 작업을 앱에서 쉽게 가져와 Siri를 통해 쉽게 액세스 할 수 있습니다.
 이제는 Siri Shortcuts를 표지에 능동적으로 제안하여 액세스하려는 정확한 시간과 장소에서 액세스하려는 작업에 쉽게 액세스 할 수 있습니다.
 더 좋은 점은 Apple Watch의 Siri 시계 화면에서 바로 제안 할 수 있다는 것입니다.
 이제 시리 (Siri) 액션이 사전에 제안되었을뿐만 아니라 사용자 지정 음성 구문을 사용하여 실행되도록 설정할 수도 있습니다.
 이제 귀하의 앱에 Siri Action Support를 추가하는 것은 정말 쉽습니다.
 두 개의 API를 사용할 수 있습니다.
 NS 사용자 활동이 있습니다. 이미 Handoff 및 Spotlight 통합 지원을 위해 사용할 수 있으며, 더 많은 사용자 지정 상호 작용이있는보다 복잡한 시나리오의 경우 Siri Intents에 대한 지원도 있습니다.
 먼저 NS 사용자 활동을 살펴 보겠습니다.
 이제 언급했듯이 NS User Activity는 Handoff 및 Spotlight가있는 일반적인 API이며 Siri Shortcuts에서 앱의 특정 위치로 고객을 유도해야 할 경우 (예 : 특정 메시지로드 또는 문서를 다른 장치로 넘기려고 할 때와 똑같은 기능을합니다.
 이미이 작업을 수행 중이라면 Siri Shortcuts에 대한 지원을 추가하는 것이 정말 쉽습니다.
 Prediction for Prediction을 true로 설정하면됩니다.
 그리고 그렇지 않은 경우, 귀하의 지름길이이 카테고리 중 하나에 들어 맞는 경우 여전히 훌륭한 방법 일 수 있습니다.
 이제 앱에 더 많은 사용자 정의 요구 사항이 있거나 더 많은 제어가 필요한 경우 Siri Kit Intents API를 채택 할 수 있습니다.
 이제 Siri Kit Intents는 사용자가 쉽게 채택 할 수있는 여러 가지 사전 정의 된 인 텐트를 제공합니다.
 이전의 Siri Kit Intents와 동일합니다.
 이제 앱에 더 많은 맞춤 동작이있는 경우 iOS 12에서 나만의 맞춤 의도를 정의 할 수 있습니다.
 맞춤 인 텐트는 실제로 유연 할 수 있으며 원하는 모든 작업을 수행 할 수 있습니다.
 이 경우에는 내년에 WWDC 슬라이드를 만들 수 있도록 도와드립니다.
 이제 의도를 파악할 수있는 범주가 이미 광범위합니다.

여기에서는 Create 카테고리를 사용했습니다.
 그러나 당신의 의도가 그보다 훨씬 일반 적이라면, General Do, Run, Go 옵션과 같은 좀 더 일반적인 것들이 있습니다.
 이제 일단 의도를 만들면 고객이 이러한 사용자 지정 바로 가기를 만들어서 쉽게 얻을 수 있도록하려는 것입니다.
 앱 내에 바로 API가 있으므로 고객이 맞춤 음성 단축키를 만들도록 허용 할 수 있습니다.
 그래서 여기에 작업을 마자 마자 내 앱에서 새로운 바로 가기를 만들 수있는 새로운 패널을 가져올 버튼이 있습니다.
 따라서 아침에 커피를 주문하는 것과 같은 일을하는 경우 다시 할 수있는 일임을 알게되면 다음 번에 할 수있는 Siri Shortcut을 만들 수있는 좋은 기회입니다.
 이제는 앱 스토어에서 제공되는 새로운 바로 가기 앱을 사용하여 이러한 바로 가기를 함께 결합 할 수도 있습니다.
 따라서 이번 주말에 Siri Shortcuts 소개, Voice Siri Shortcuts 제작 및 Siri Shortcuts에서 Siri Watch Face 세션에 대한 자세한 내용을 배울 수 있습니다.
 오늘 아침에 iOS 12의 새로운 기능에 대해 많은 이야기를 나눴지만 새로운 내용이 반드시 필요한 것은 아닙니다.
 따라서 iOS 용 앱을 처음 만드는 사람이라면 체크 아웃해야 할 멋진 세션이 있습니다. 앱에 대한 아이디어가 있습니다.
 그래서 확실히 확인해보십시오.
 이미 앱을 가지고 있고 더 세련된 인터페이스를 추가하려는 경우에는 몇 가지 훌륭한 세션도 있습니다. IOS 컬렉션에 UI 컬렉션보기 및 즐거움 추가하기.
 오늘 아침에 새로운 소식을 들으니 너무 고맙습니다.
 실험실에서 만나기를 기대하며 좋은 한 주를 보내길 바랍니다.
 감사.
