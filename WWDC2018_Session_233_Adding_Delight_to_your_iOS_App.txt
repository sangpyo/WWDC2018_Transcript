얘들 아! 안녕하세요.
 iOS 앱에 기쁨 추가하기에 오신 것을 환영합니다.
 내 이름은 벤이야.
 그리고 내 이름은 피터 야.
 그리고, 우리는 당신에게 6 가지 프로 팁을 보여 주어 마법을 만듭니다.
 외부 디스플레이 지원부터 시작하여 앱의 경험을 대형 화면으로 가져올 것입니다.
 다음으로 레이아웃 주도형 UI라고하는 새로운 프로그래밍 패턴을 살펴 보겠습니다.
 그런 다음 레이저 빠른 출시로 가능한 한 빨리 고객에게 즐거운 경험을 선사하는 방법을 알려 드리겠습니다.
 우리는 매끄러운 스크롤에 집중할 것이며, 일들을 훌륭하게 유지할 것입니다.
 연속성은 iOS에서 가장 환상적인 경험 중 하나입니다.
 그리고 애플리케이션에서 Handoff를 채택하는 것이 얼마나 쉬운지를 보여 드리겠습니다.
 마지막으로 우리는 프로처럼 디버깅 할 때 몇 가지 매트릭스 수준의 디버깅 기술을 가르쳐 드리겠습니다.
 우리는 많은 것을 다루어야하기 때문에 시작합시다.
 iOS 기기는 놀라 울 정도로 통합 된 디스플레이로 정의됩니다.
 또한 외부 디스플레이에 대한 지원을 추가하여 앱의 경험을 더욱 향상시킬 수 있습니다.
 이를 설명하는 데모 응용 프로그램을 만들었습니다.
 iOS에 내장 된 디스플레이 미러링은 외부 시스템의 디스플레이에 전체 시스템 UI를 복제합니다.
 여기에 데모 앱이 있습니다.
 보시다시피 간단한 사진 뷰어입니다.
 사진 미리보기 이미지를 탭하면 사진이 슬라이드되고 전체 화면으로 표시됩니다.
 그리고이 전체 경험은 외부 디스플레이에 복제됩니다.
 외부 디스플레이의 크기를 최대한 활용하기 위해 iPhone을 가로로 돌려서 채울 수 있습니다.
 그리고, 이것은 훌륭합니다. 우리는이 일을 할 수있었습니다.
 그러나 우리는 이것보다 더 잘할 수 있습니다.
 iOS에 바로 내장 된이 API를 사용하면이 외부 연결 디스플레이에 완전히 사용자 정의 된 두 번째 사용자 인터페이스를 만들 수 있습니다.
 이 작업을 수행 한 몇 가지 앱의 예를 살펴 보겠습니다.
 기조 연설은 좋은 본보기입니다.
 외부 디스플레이에서는 현재 기본 슬라이드에 초점을 맞 춥니 다.
 그러나 통합 iPhone 디스플레이에서 발표자 노트와 다음 슬라이드를 볼 수 있으며 프레젠테이션에 필수적인 도구입니다.
 아니면 게임을 할 수도 있습니다.
 그러나 일반적으로 부드럽고 중첩 된 컨트롤을 사용합니다.
 게임을 제어하고 iOS 기기의 디스플레이에 배치하고 외부 디스플레이에 완벽하고 방해받지 않고 몰입 할 수있는 게임 경험을 제공하는 완전히 맞춤화 된 인터페이스를 만들 수 있습니다.
 외부 디스플레이 용으로 응용 프로그램을 설계 할 때는 고려해야 할 몇 가지 중요한 사항이 있습니다.
 명백한 크기 차이를 제외하고는 iPhone은 개인적인 것입니다.
 따라서이 디스플레이에 표시되는 정보의 종류는 비공개로 간주해야합니다.
 반면, 외부 디스플레이는 일반적으로 거실의 TV 나 회의실의 프로젝션 시스템과 같이 많은 사람들이 볼 수있는 환경에 놓이게됩니다.
 따라서이 디스플레이에 표시된 정보는 공개 된 것으로 가정해야합니다.
 또한 iPhone 및 iPad에 내장 된 디스플레이는 대화 형이지만 외부 디스플레이는 아닙니다.
 따라서 외부 요소에 UI 요소 나 상호 작용 가능한 컨트롤을 표시하지 않아야합니다.
 따라서 이런 종류의 생각을 데모 응용 프로그램에 적용하고 우리가 생각해 낼 수있는 것을 살펴 보겠습니다.
 다음은 외부 디스플레이 용으로 최적화 된 버전입니다.
 보시다시피 이제는 선택한 사진을 외부 디스플레이에 전체 크기로 표시하고 있습니다.
 또한 통합 디스플레이에는 미리보기 이미지 만 표시되고 새 선택 표시기는 현재 전체 화면으로 표시되는 사진을 표시합니다.
 간단하지만이 기능은이 디자인을 사용하는 데있어 매우 유용합니다.
 이것을 데모 앱에 어떻게 구현했는지 보여주기 위해 세 가지 주제를 다룰 것입니다.
 연결성, 동작 및 연결 전환.
 연결성부터 시작합시다.
 외부 디스플레이가 연결되어 있는지 어떻게 알 수 있습니까? UIScreen에는 iPhone에 내장 된 장치를 비롯하여 연결된 모든 디스플레이 목록이 포함 된 클래스 변수 인 screen이 있습니다.
 따라서이 배열에 요소가 두 개 이상있는 경우 외부 디스플레이가 연결되어 있다는 것을 알고 있습니다.
 또한 외부 디스플레이를 자유롭게 연결하거나 연결 해제 할 수 있기 때문에 UIKit에서는 알림이 게시되면 언제 알 수 있습니다.
 따라서 UIScreen을 청취해야합니다.
didConnectNotification 및 UIScreen.
didDisconnectNotifications.
 그리고 UI를 가져 와서 적절하게 분리하십시오.
 Peter, 두 번째 사용자 인터페이스를 설정하는 것이 얼마나 쉬운 지 개발자에게 보여줄 수 있습니까? 벤, 나는 행복 할거야.
 UIScreen 연결 콜백 코드를 살펴 보겠습니다.
 여기에서는 화면 배열의 마지막 화면으로 로컬 변수를 설정합니다.
 우리는 didConnectNotification 콜백 내부에 있기 때문에 이것이 외부 화면이라는 것을 알고 있습니다.
 그런 다음이 외부 디스플레이에 표시 할 새 UI 창을 만듭니다.
 그리고 화면 속성을 화면에 지정합니다.
 다음으로, 우리는이 창을 설정하기를 원할 것입니다.

우리는 이것을 함수로 만들었지 만 우리가 여기에서하는 모든 작업은 온보드 디스플레이를 위해 할 때와 같은 방식으로 루트보기 컨트롤러를 만들고이를 윈도우에 고정시키는 것입니다.
 마지막으로이 창을 외부 화면에 표시하기 위해 숨기지 않은 것으로 표시합니다.
 그래서, 그것은 연결입니다.
 이제 연결 해제를 살펴 봅시다.
 그래서, 여기 우리는 우리의 UIScreen 안에 있습니다.
didDisconnectNotification 핸들러이며, 여기서해야하는 일은 창을 숨기고 로컬 참조를 없애 리소스를 비우는 것입니다.
 그리고 그게 다야.
 우리는 앱에서 화면 연결 및 연결 해제를 구현했습니다.
 와우, 피터, 정말 쉬웠 어.
 다음으로 고려해야 할 것은 외부 디스플레이가 연결되어있을 때의 앱의 기본 동작을 변경하는 것입니다.
 데모 응용 프로그램의 일부 코드 예제를 살펴 보겠습니다.
 콜렉션 뷰에서 사진을 누를 때 호출되는 코드입니다.
 싱글 디스플레이 모드에있을 때, 우리는 photoViewController를 생성하고 그것을 네비게이션 스택에 푸시합니다.
 그러나 외부 모니터가 연결되어있을 때 두 번째 UI에는 이미 photoViewController 전체 화면이 표시되어 있으므로 해당 사진을 표시하도록 지시합니다.
 정말 쉽습니다.
 외부 디스플레이를 디자인 할 때 세 번째 고려해야 할 점은 우아한 전환으로 연결 변경을 처리해야한다는 것입니다.
 이것을 설명하기 위해 데모 응용 프로그램으로 돌아 갑시다.
 여기에서 데모 응용 프로그램이 현재 사진을 전체 크기로 표시하고 있음을 알 수 있습니다.
 그리고 아직 외부 디스플레이를 연결하지 않았습니다.
 우리가 플러그를 꽂으면 어떻게 될지 지켜보십시오.
 여기서 일어난 일은 viewController를 축소판 뷰로 다시 팝하는 동시에 이전에 선택한 사진을 외부 디스플레이에 전체 크기로 표시하는 것입니다.
 또한 문맥을 보존하는 데 도움이되는 우아한 전환이되어 고객이 앱의 흐름에서 어디에 있는지 이해할 수 있도록 도와줍니다.
 그래서 외부 디스플레이 지원입니다.
 설정하는 것은 정말 쉽습니다.
 애플리케이션을 디자인 할 때 다양한 디스플레이 컨텍스트를 고려하고 연결 변경 사항을 적절하게 처리해야합니다.
 이에 대한 자세한 내용은 WWDC 2011에서이 대화를 확인하십시오.
 고맙습니다.
  레이아웃 기반 UI는 앱을 작성하여 기능을 쉽게 추가하고 디버그하기 쉽게 만드는 강력한 방법입니다.
 레이아웃 기반 UI는 iOS 앱에서 가장 큰 문제의 원인을 처리하는 데 도움이되며 UI 복잡성을 관리합니다.
 네가 전에 여기에 왔을거야.
 나도 알아.
 코드와 제스처 콜백을 추가합니다.
 알림 콜백에 더 많은 UI 업데이트 코드를 추가합니다.
 또한 UI 컨트롤에서 값 트리거를 얻으면 더 많은 기능을 제공합니다.
 그리고 갑자기 앱이 이상하고 이해하기 힘든 상태에 빠지게됩니다.
 그리고 이러한 비정상적인 버그를 재현하려면 이러한 이상한 명령을 따라야합니다.
 또한 앱에 더 많은 기능을 추가하면 문제가 더욱 악화됩니다.
 대신 간단한 레서피를 따라 UI 업데이트를 레이아웃에 적용하면 이러한 버그를 없애고 기능을 훨씬 쉽게 추가 할 수 있습니다.
 레이아웃 중심의 UI를 앱에 추가하는 방법을 살펴 보겠습니다.
 먼저해야 할 일은 UI에 영향을 미치는 모든 상태를 식별하고 추적해야합니다.
 그런 다음 상태가 변경 될 때마다 setNeedsLayout을 호출하여 레이아웃 시스템을 더러워야합니다.
 마지막으로 layoutSubviews에서 UI를이 상태로 업데이트하려고합니다.
 그리고 그게 다야.
 그래서, 제가이 조리법에 대해 좋아하는 것은 따라하기 쉽다는 것입니다.
 또한 레이아웃 기반 UI를 전체적으로 응용 프로그램에 적용하면 iOS 응용 프로그램, 레이아웃, 애니메이션 및 제스처의 세 가지 핵심 구성 요소를 고려하면서이 세 가지를 모두 구현하면 실제로 끝내주는 방법.
 레이아웃부터 시작하겠습니다.
 레이아웃은 응용 프로그램의 내용을 화면에 배치하는 프로세스입니다.
 그러나 레이아웃에서 다른 모든 UI 업데이트를 수행 할 것을 권장합니다.
 이것을 강조하기 위해 작성한 간단한 샘플 앱을 살펴 보겠습니다.
 벤,이 앱으로 우리를 데려 갈 수 있니? 물론이지, 피터.
 따라서 중간에 멋진 사람이있는 매우 간단한 샘플 앱이 있습니다.
 그는 우리가 차가운 느낌을 언제 보여줍니다.
 우리가 아니라면 그는 숨어 있습니다.
 그러나 우리는 지금 아주 냉담한 느낌입니다, 피터.
 그럼 데려와 봅시다.
 큰.
 따라서 간단한 예제이지만 진행하는 것이 중요하므로 레이아웃 기반 UI가 어떻게 작동하는지 이해할 수 있습니다.
 이제이 앱의 골격을 살펴보고 Ben이 앞서 보여준 레이아웃 기반 UI 레시피를 살펴 보겠습니다.
 그래서, 우리는 coolview에서 내가 미리 썼던 멋진 남자의 모습을 주인공으로하는 관리 뷰를 얻었습니다.
 벤, 우리 조리법의 첫 걸음은 뭔가? 우리는 UI에 영향을주는 상태를 식별하고 추적해야합니다.
 Ben이 말한 것을 기억하십시오.
 시원한 사람은 우리가 시원할 때 거기에 있습니다.
 그리고 우리가 없을 때 그는 거기에 있지 않습니다.
 그래서, 우리는 feelingCool이라는 변수를 가질 것입니다.
 승인.

벤, 제법의 두 번째 단계는 무엇입니까? 자, 이제이 상태가 바뀔 때마다 setNeedsLayout을 호출하여 레이아웃 시스템을 더럽힐 필요가 있습니다.
 그러나 우리는이 상태가 바뀔 때마다 이것이 일어날 수 있도록해야합니다.
 그리고이 상태는 응용 프로그램의 여러 위치에서 바뀔 수 있습니다.
 그래서 Peter는 변화가있을 때 어떻게 레이아웃 시스템을 항상 지키고 있는지 확인할 수 있습니까? 네가 물어 봤으면 좋겠다. 왜냐하면 나는 이것에 대해 좋은 생각을 가지고 있다고 생각하기 때문이다.
 신속 속성 관찰자라는 기능을 사용할 수 있습니다.
 이것들은 속성이 설정되기 전이나 후에 코드를 실행하게합니다.
 따라서 didSet 속성 옵저버를 사용하여 setNeedsLayout을 호출 할 수 있습니다.
 이것은 앱에서 Swift 속성 관찰자를 사용하는 데있어 탁월합니다.
 승인.
 그래서, 우리는 거의 끝났습니다.
 벤, 조리법의 마지막 단계는 무엇입니까? 이제 Peter는이 상태를 사용하여 layoutSubviews에서 UI를 업데이트해야합니다.
 좋아, 쉬워.
 우리는 layoutSubviews를 오버라이드 할 것이고, 우리는 feelingCool의 가치에 기반한 멋진 사람보기의 isHidden 속성을 업데이트 할 것입니다.
 그리고 그게 다야.
 레이아웃 기반 UI를 앱에 추가하기 위해 필요한 모든 것입니다.
 자,이 간단한 예제에 대해 이것이 실제로 잘 작동하는 반면, 이전의 복잡한 예제에서는 더 잘 작동합니다.
 벤과 저는 지난 밤에 애플의 캠퍼스를 휩쓸고있는이 새로운 macOS The Gathering 트레이딩 카드 게임을 정말 늦게까지했습니다.
 우리는 다음 주말에 토너먼트에서 우승 할 수 있도록이 재미있는 작은 데크 빌더 앱을 만들었습니다.
 이 카드를 집어 들고 끌 수 있으며,이 작은 갑판 영역으로 던질 수 있습니다.
 그리고 그것은 정말 빠르고 재미 있고 유동적입니다.
 우리는 동시에 두 장의 카드를 가져올 수 있습니다.
 이 앱으로 레이아웃 기반 UI가 어떻게 작동하는지 실제로 보여줄 수 있다고 생각합니다. 중요한 것은 다음 주에 Ben의 직무를 이길 수 있다는 것입니다.
 이제 iOS 앱의 다른 두 가지 핵심 요소와 애니메이션으로 시작하여 레이아웃 기반 UI를 어떻게 적용 할 수 있는지 살펴 보겠습니다.
 애니메이션은 훌륭한 iOS 경험의 특징입니다.
 사용자 인터페이스의 실물과 같은 움직임은 진정으로 앱이 살아 있다는 느낌을줍니다.
 UIKit에는 이러한 멋진 애니메이션을 제작하는 데 도움이되는 유용한 API가 있습니다.
 UIViewPropertyAnimator API는 정말 강력한 도구이며 작년에 새로운 기능이 추가되어 터보 차져졌습니다.
 사용 방법에 대해 자세히 알아 보려면 WWDC 2017의 UIKit에서 Advanced Animations를 확인하십시오.
 이 외에도, 시도하고 진정한 UIView 클로저 API는 이러한 애니메이션을 만드는 좋은 방법입니다.
 그래서 큰.
 UI 기반 레이아웃 기반 UI 기반 UIViewAnimations를 사용할 수 있습니다.
 염두에 두어야 할 것은 beginFromCurrentState 애니메이션 옵션을 항상 사용하고자하는 것입니다.
 이것은 UIKit에 애니메이션의 중간 애니메이션 인 경우에도 애니메이션의 현재 화면 위치를 취하도록 지시합니다.
 따라서 인터랙티브 인터랙티브 애니메이션을 만들 수 있습니다.
 macOS The Gathering 트레이딩 카드 게임 앱의 예를 살펴 보겠습니다.
 여기에는 어떤 카드가 갑판에 있는지 추적하는 변수가 있습니다.
 그리고 이전에 이야기했던 스위프트 속성 관찰자를 사용하여 setNeedsLayout을 호출하여 변경 될 때마다 레이아웃 시스템을 지저분하게 만들고 있습니다.
 다음으로, 카드를 데크에 넣으려면이 배열에 카드를 추가해야합니다. 레이아웃이 더러워지면이 beginFromCurrentState 옵션을 사용하여 animation 블록 내부에 layoutIfNeeded를 호출합니다.
 이렇게하면 layoutSubviews에서 코드를 호출하여 모든 뷰를 이동시키고 적절한 애니메이션 상태 전환을 재생합니다.
 그리고이 점에 대해 정말 탁월한 점은 여기에서 강조하고 싶은 점은 이러한 애니메이션에 특별한 사례를 추가하지 않은 점에 주목하십시오.
 우리는 애니메이션 블록 내부의 레이아웃을 수행함으로써이 애니메이션 레이아웃을 무료로 얻을 수 있습니다.
 이것은 정말로, 정말로 굉장합니다.
 따라서 레이아웃 기반 UI 앱에 애니메이션을 추가 할 수 있습니다.
 마지막으로 iOS 앱의 세 번째 핵심 요소 인 제스처에 대해 살펴 보겠습니다.
 물론 UIGestureRecognizer에 대해 이야기하지 않고도 제스처에 대해 말할 수는 없습니다. UIKit의 앱에 제스처 상호 작용을 추가하는 데 도움이되는 멋진 API입니다.
 UIKit은 UIgestureRecognizer의 훌륭한 하위 클래스를 제공합니다.
 팬에서 핀치, 스 와이프, 회전까지 모든 것.
 이를 사용하여 원하는 상호 작용을 만들 수 있어야합니다.
 또한 맞춤 설정할 수 있습니다.
 정말 미친 무언가를 원한다면 UIGestureRecognizer를 언제나 서브 클래스화할 수 있습니다.
 내장 된 UIKitGestureRecognizers를 볼 때 이산 동작과 연속 동작의 차이를 이해하는 것이 중요합니다.
 이산 동작은 이벤트가 발생했음을 알려줍니다.
 그들은 가능한 상태에서 시작하고, 그 후에 그들은 가야한다, 그들은 $ 200를 모이지 않는다.
 그들은 즉시 인식 상태로 이동합니다.
 이러한 기능은 화재시 유용하며 앱에서 상호 작용을 잊어 버리지 만 상호 작용 중 모든 단계에서 알려주지는 않습니다.
 다른 종류의 제스처는 연속적인 제스처입니다.

이것들은 당신에게 훨씬 더 높은 수준의 충실도를 제공합니다.
 이산 제스처처럼, 그들은 가능한 상태에서 시작하지만, 인식되기 시작할 때 그들은 Began 상태로 이동합니다.
 추적 할 때 변경된 상태가됩니다.
 그리고이 시점에서 제스처가 움직이면서 연속적인 이벤트 흐름을 받고 있습니다.
 마지막으로 제스처가 완료되면 Ended 상태로 이동합니다.
 우리가 가장 좋아하는 유형의 연속 제스처는 UIPanGestureRecognizer입니다.
 그리고 그것을 최대한 활용하는 데 도움이되는 두 가지 유용한 기능이 있습니다.
 translationInView는 뷰와 관련된 제스처 추적 위치를 알려줍니다.
 그리고 velocityInView는 몸짓이 얼마나 빨리 움직이는 지 알려줍니다.
 그리고 이것은 제스처와 후속 애니메이션 간의 속도를 전달하는 데 정말 강력합니다.
 이 방법을 사용하여 실제로 멋진 제스처 상호 작용을 작성하는 방법에 대해 자세히 알아 보려면 WWDC 2014에서 인터럽트 및 반응 상호 작용 작성을 참조하십시오.
 그래서 UIPanGestureRecognizer도 좋아합니다.
 그리고 이전에 본 카드 드래그 동작을 구축하는 데 도움이되었습니다.
 우리가 레이아웃 주도 UI를 사용하여 어떻게했는지 살펴 보겠습니다.
 다시 말하지만 우리는 제스처가 적용한 각 카드의 오프셋을 추적하는 지역 변수를 가지고 있습니다.
 그리고이 변수가 바뀔 때마다 다시 한번, Swift의 속성 관찰자 중 하나를 사용하여 setNeedsLayout을 트리거합니다.
 그런 다음 panGestureRecognizer 콜백 함수의 내부에서 현재 번역을 잡고 제스처를보고이 제스처를 카드 중 하나에 연결합니다.
 그런 다음이 사전에서이 카드의 오프셋을 증가시킵니다.
 마지막으로 layoutSubviews에서이 사전의 오프셋을 기반으로 카드보기의 위치를 ​​업데이트해야합니다.
 전통적인 레이아웃 중심의 UI 케이스 외에도 우리가 특별한 것을하지 않는 방법에 대해 다시 한번 주목하십시오.
 우리는 제스처에 의해 구동되는 이런 상태의 조각을 가지고 있습니다. 우리는 layoutSubviews에서 응답하고 있습니다.
 사실, 앱 전체에서이 패턴을 따르면, 이러한 유형의 상호 작용을 훨씬 쉽게 채택 할 수 있다는 것을 알게 될 것입니다.
 레이아웃 기반 UI입니다.
 조리법을 기억하십시오.
 UI에 영향을 미치는 모든 상태를 찾아 추적하십시오.
 이 상태가 변경 될 때마다 신속 속성 관찰자를 사용하여 setNeedsLayout을 트리거합니다.
 마지막으로 layoutSubviews를 구현할 때 추적 한 상태에 따라 뷰 상태를 업데이트해야합니다.
 고맙습니다.
  iOS 환경은 모두 반응 적입니다.
 그리고 고객은 가능한 빨리 고객에게 즐거운 경험을 제공하고자합니다.
 그들 사이에 아이콘을 두드려서 기뻐하고있는 한 단계가 있습니다.
 그리고 한 발자국은 발사 시간입니다.
 이를 최적화하는 데 도움이되도록 출시의 해부를 구성하는 5 개의 고급 구성 요소를 살펴 보겠습니다.
 1 번부터 시작하여 포크를 처리합니다.
 피터, 발사의이 단계에서 우리는 무엇을 할 수 있습니까? 프로세스 포킹의 경우, 실제로 복잡합니다.
 fork 및 exec에 대한 Man 페이지를 읽고 POSIX 기본 사항을 익혀야합니다.
 아니, 농담이야.
 iOS가 프로세스 포크를 처리합니다.
 우리는 당신을 위해 1 번을 다룰 것입니다.
 2 번을 보자.
 [Audience Laughter] 동적 인 연결.
 이 단계에서는 애플리케이션을 실행하기 위해 메모리를 할당합니다.
 라이브러리와 프레임 워크를 연결합니다.
 우리는 Swift, Objective-C, Foundation을 초기화하고 있습니다.
 그리고 우리는 정적 객체 초기화도하고 있습니다.
 일반적으로 앱의 일반적인 출시 시간의 40 ~ 50 %를 차지할 수 있습니다.
 그리고 기억해야 할 핵심 사항 중 하나는 지금 시점에서 실행 한 코드가 하나도 없습니다.
 따라서이를 최적화하는 방법을 이해하는 것이 중요합니다.
 Peter, 개발자에게 큰 충고가 있습니까? 네가 물어 봤으면 좋겠다, 벤.
 앱 시작 시간의 연결 단계를 최적화 할 때는 매우주의해야합니다.
 그렇게 많은 양의 발사 시간을 차지하기 때문입니다.
 제 첫 번째 조언은 가능하면 코드 중복을 피하는 것입니다.
 함수, 객체 또는 구조체가 중복되는 경우 앱에서 해당 함수, 객체 또는 구조체를 제거하십시오.
 반복하지 마십시오.
 다음으로 타사 라이브러리 사용을 제한하려고합니다.
 iOS 자사 라이브러리는 캐시되고 다른 응용 프로그램이 사용중인 경우 이미 활성 메모리에있을 수 있습니다.
 그러나 타사 라이브러리는 캐시되지 않습니다.
 다른 앱이 귀하와 같은 버전의 라이브러리를 사용하고있는 경우에도 앱에서 사용하는 경우 프레임 워크를 가져와야합니다.
 따라서 실제로 이러한 타사 라이브러리의 사용을 최대한 제한해야합니다.
 마지막으로 정적 이니셜 라이저를 피하고 플러스 초기화, 플러스로드와 같은 메소드에서 동작을 원할 것입니다.
 앱이 의미있는 작업을 수행하려면 먼저 실행해야하기 때문입니다.
 시작 시간의 중요한 부분에 대해 자세히 알아 보려면 WWDC 2017에서 App Start-Time : 과거, 현재 및 미래를 확인하십시오.


시작의 다음 단계는 UI 구성입니다.
 이 시점에서 UI를 준비하면서 viewController를 작성합니다.
 시스템은 상태 복원을 수행하고 원하는대로로드합니다.
 또한 앱이 응답하기 위해 필요한 데이터를로드하고 있습니다.
 피터, 발사의이 단계에서 우리가 할 수있는 일은 무엇입니까? 앱의 가능한 한 빨리 UI 구축 단계를 최적화하고 싶을 것입니다.
 이는 UI 응용 프로그램 활성화 방법에서 최대한 빨리 반환한다는 의미입니다.
 WillFinishLaunching, didFinishLaunching, didBecomeActive.
 UIKit은 앱을 활성으로 표시하기 전에 이러한 함수에서 돌아 오기를 기다리기 때문에
 다음으로, 응용 프로그램이 실행되는 동안 파일 시스템 쓰기가 차단되고 sys 호출이 필요하기 때문에 이러한 작업을 수행하지 않으려합니다.
 이와 함께 손을 잡아라. 앱을 시작하는 동안 매우 큰 읽기를 피하기를 원할 것이다.
 대신 지금 당장 필요한 데이터 만 스트리밍하는 것이 좋습니다.
 마지막으로 데이터베이스 위생을 확인하시기 바랍니다.
 항상 깨끗한 상태로 유지하는 것이 좋습니다.
 CoreData와 같은 라이브러리를 사용하는 경우 가능한 한 빨리 스키마를 최적화하는 것이 좋습니다.
 SQLite 또는 이와 유사한 기술을 사용하여 자체 솔루션을 구상하는 경우 주기적으로 데이터베이스를 비우는 것이 좋습니다.
 예를 들어, 앱이 업데이트 될 때마다
 고마워, 피터.
 출시의 다음 단계는 첫 프레임을 만들 때입니다.
 이 시점에서 핵심 애니메이션은 해당 프레임을 준비하는 데 필요한 모든 렌더링을 수행하고 있습니다.
 텍스트 그리기를하고 있어요.
 또한 UI에 표시해야하는 이미지를로드하고 압축을 푸는 중입니다.
 피터, 발사의이 단계에서 더 이상 세이지 조언이 있니? 오, 나.
 첫 번째 프레임을 준비 할 때는 시작하는 동안 절대적으로 필요한 사용자 인터페이스 만 준비하면되므로 매우 중요합니다.
 사용자가 앱의 특정 섹션으로 이동하지 않은 경우 앱을로드하지 마십시오.
 그리고, 당신이 절대적으로 필요로 할 때, 그것을 느슨하게 잡아 당깁니다.
 또한 앱으로 처음 이동할 때 표시되지 않아야하는보기 및 레이어를 숨기지 않아야합니다.
 보기 및 레이어가 숨겨진 경우에도 비용은 여전히 ​​있습니다.
 따라서 첫 번째 프레임에 꼭 필요한보기 및 레이어 만 가져 오십시오.
 발사의 마지막 단계는 확장 발사 행동입니다.
 이는 신속하게 대응할 수 있도록 출시 경로에서 연기 한 작업입니다.
 따라서 앱이이 시점에서 반응적일 수는 있지만 아직까지는 유용하지 않을 수 있습니다.
 이 단계는 정말로 다음에해야 할 일에 우선 순위를 매기는 것입니다.
 지금은 화면 상에 있어야하는 콘텐츠를 가져 오십시오.
 또한 원격 서버에서 콘텐츠를로드하는 경우 네트워크 환경이 어려울 수도 있다는 점을 고려해야합니다.
 필요한 경우 자리 표시 자 UI를 준비하십시오.
 그래서, 그것들은 발사의 해부학을 구성하는 5 개의 고수준 구성 요소입니다.
 오늘은 한가지 더 있습니다.
 ABM.
 A : 항상.
 B : 만나.
 M : 측정.
 커피는 빠른 앱용입니다.
 시작 시간이 어디로 가고 있는지를 이해하는 것이 중요합니다.
 시간 프로파일 러를 사용하여 정기적으로 측정하십시오.
 시작 경로에서 경로의 코드를 변경할 때마다 다시 측정해야합니다.
 그리고 통계적 평균을 취하십시오.
 단일 프로파일에 의존하지 말고 발사 시간을 확인하십시오.
 따라서 레이저 빠른 실행이 시작됩니다.
 신속하게 반응하십시오.
 필요한 것을 사용하십시오.
 그리고, 측정, 측정, 측정.
 고맙습니다.
  스크롤링은 iOS 사용자 경험의 핵심 부분이며 앱 내부의 많은 부분을 차지합니다.
 iPhone과 iPad는 귀하의 앱이 좋아할만한 것으로 변신 할 수있는 불가사의 한 유리 시트입니다.
 따라서이 마법의 유리판에서 앱의 콘텐츠가 움직이는 환상을 유지하는 데 도움을주는 것이 중요합니다.
 애플에서 우리는 당신의 앱이 버터처럼 매끄러 워야한다는 말을하고 싶다.
 그러나 때로는 버터와 같지 않게 느껴지도록 약간의 발목과 바늘이 있고 땅콩 버터와 비슷합니다.
 그리고 전에 이것을 보았습니다.
 앱이 고르지 않거나 고르지 않게 느껴집니다.
 Ben, 앱의 느린 동작의 원인은 무엇입니까? 음, 피터, 당신이 묘사하고있는이 느린 행동은 실제로 우리가 프레임을 떨어 뜨리고 있다는 것입니다.
 그래서 우리는 그것이 왜 일어날 지 이해할 필요가 있습니다.
 그리고 이것이 일어날 수있는 두 가지 핵심 영역이 있습니다.
 첫 번째는 너무 많은 계산을 수행 할 수 있다는 것입니다.
 그리고 두 번째는 복잡한 그래픽 합성 작업을 너무 많이 할 수 있다는 것입니다.
 계산을 시작으로 이들 각각을 차례로 살펴 보겠습니다.
 너무 많은 계산을하는 경우 어떻게 알 수 있습니까? 음, Instruments에 내장 된 Time Profiler는이를위한 최고의 도구입니다.
 코드가 사용하는 CPU 시간의 양만 줄 측정 값까지 줄 수 있습니다.
 정말 강력한 도구이며, WWDC 2016의 계측기에서 시간 프로파일 러 사용을 참조하십시오.

따라서 Time Profiler 도구를 사용하여 이러한 핫 스폿을 확인한 후에는이를 최적화 할 수있는 몇 가지 유용한 정보를 얻었습니다.
 첫 번째는 UICollectionView 및 UITableView 프리 페칭을 사용하는 것입니다.
 이 API는 사용자가 특정 셀을 향해 스크롤하는 동안 알려주고 해당 데이터를 사전로드 할 수있는 기회를 제공 할 API 조각입니다.
 2016 년에 아주 잘 생긴 두 명의 발표자가 멋진 이야기를 나누어주었습니다.
 내가 가지고있는 다음 팁은 UI에서 UI를 업데이트하고 사용자 입력을 처리하기 위해 주 대기열을 비울 수 있도록 가능한 한 많은 작업을 기본 대기열에서 백그라운드 대기열로 밀어 넣는 것입니다.
 벤, 어떤 대기열에서 벗어날 수 있니? 네트워크 및 파일 시스템 액세스와 같은 일반적인 것들이 있습니다.
 이것들은 메인 쓰레드에서 결코 실행되어서는 안된다.
 그러나 이미지 그리기 및 텍스트 크기 조정과 같이 예상치 못한 다른 것들이있을 수 있습니다.
 UIGraphicsImageRenderer 및 분산 문자열에는 백그라운드 스레드에서 안전하게 사용할 수있는 함수가 있습니다.이 함수를 사용하면 복잡한 계산 중 일부를 기본 대기열에서 이동할 수 있습니다.
 와우, 벤, 그게 좋은 조언 이네.
 나는 메인 큐에서 그렇게 생각하지 않았을 것이다.
 그래서, Time Profiler를 실행했다고합시다.
 그 사람들이 나에게 말했듯이 프리 패칭을 사용했습니다.
 그리고 메인 큐에서 최대한 많은 작업을 푸시했지만 앱이 여전히 느립니다.
 확실히 이건 내 문제가 아니야, 벤? 글쎄, 피터, 우린 아직 숲에서 빠져 나오지 않았을거야.
 우리가 계산을 최적화했을지라도, 우리는 여전히 그래픽 시스템에 문제가있을 수 있습니다.
 다행히도 여기에 유용한 도구가 있습니다.
 Core Animation (코어 애니메이션) 악기는 프레임 속도가 정확히 무엇인지 확인하는 매우 강력한 방법입니다.
 또한 동시에 GPU 활용도를 조사합니다.
 정말 강력한 도구입니다.
 또한 사용 방법에 대해 자세히 알아 보려면 WWDC 2014의 iOS 앱용 고급 그래픽 및 애니메이션을 확인하십시오.
 일단 앱이 그래픽에 구속되어 있다는 것을 확인하면 조사 할 수있는 훌륭한 열매가 있습니다.
 일반적으로 시각적 효과, 마스킹 및 클리핑의 두 가지 중 하나를 과도하게 사용하여 그래픽이 연결된 앱을 사용합니다.
 흐려짐이나 흔들림과 같은 시각적 효과는 값 비싸기 때문에 앱에서 멋지게 사용해야합니다.
 흐리게 처리 할 때 흐리게 표시 될 경우에는 흐리게 표시하지 않는 것이 좋습니다. 그러면 GPU가 오버 드라이브에서 작동하여 앱 속도가 느려질 수 있습니다.
 또한 가능하면 마스킹 및 클리핑을 피해야합니다.
 대신보기 위에 불투명 한 내용을 배치하여 동일한 시각적 모양을 얻을 수 있다면 UIViewer CA Layer의 마스크 된보기 또는 마스크 된 속성 대신 마스크를 사용하는 것이 좋습니다.
 이것이 바로 원활한 스크롤링 성능을 최적화 할 수있는 방법입니다.
 앱에서 Time Profiler 및 Core Animation 악기를 실행하십시오.
 프리 페칭을 사용하고 가능한 한 많은 작업을 기본 대기열에서 밀어냅니다.
 그리고 시각 효과를 사용하고 마스킹 및 클리핑을 조심스럽게 사용하십시오.
 프로파일 링에 대한 더 자세한 정보는 WWDC 2015의 위대한 대화를 확인하십시오.
 고맙습니다.
  연속성은 Apple 플랫폼에서 가장 환상적인 경험 중 하나입니다.
 Handoff는 고객을 진정으로 기쁘게하는 환상적인 방법입니다.
 한 장치에서 작업을 가져 와서 다른 장치로 원활하게 전환 할 수있는 능력은 절대적으로 좋습니다.
 Handoff는 iOS, macOS 및 watchOS간에 작동합니다.
 피어 - 투 - 피어 연결을 사용하기 때문에 인터넷 연결이 필요하지 않으며 모든 사용자에게 가장 좋습니다. 설정하는 것이 정말 쉽습니다.
 그렇다면 애플리케이션에서 핸드 오프를 사용하는 방법에 대해 어떻게 생각해야합니까? 자, Apple 애플 리케이션에서 어떻게 작동하는지 몇 가지 예를 들어 봅시다.
 잘 생긴 공동 발표자로부터 메시지를 받았다고 가정 해 봅시다. 유머러스 한 애니메지로 iPhone X에 답장하고 싶습니다.
 음, iOS의 App Switcher에서 직접 대화로 돌아갈 수 있습니다.
 또는 Mac의 Pages에서 문서를 편집 할 때 실행해야하고 Dock에있는 아이콘을 두드려서 실행할 수 있습니다.
 또는 시계에서 사진을 자연스럽게 탐색하고 이전 WWDC의 사진을 찾아서 그 앨범에있는 모든 사진을보고 싶다면 바로 사진 라이브러리로 돌아갈 수 있습니다. 내 아이폰, 그 하나의 사진을 검색하지 않고.
 핸드 오프는 정말 강력하고 장치에서 장치로 이동할 때 고객에게 많은 시간을 절약 할 수 있습니다.
 그래서 우리는 당신이 얼마나 쉽게 받아들이는지를 보여줄 것입니다.
 NSUserActivity API를 기반으로 구축되었습니다.
 NSUserActivity는 현재 수행중인 현재 상태 또는 활동을 나타냅니다.
 이 경우 이메일을 작성합니다.
 이 활동이 생성되면 동일한 iCloud 계정으로 로그인 한 인근 기기에는 모두 Handoff가 사용 가능한 것으로 표시됩니다.
 Mac에서는 Dock에 아이콘이 표시됩니다.

이 Mail 아이콘을 클릭하면 활동이 Mac으로 전송되고 Mail은 시작한 지점에서 계속 실행되고 계속 진행됩니다.
 이제 이것을 설정하는 데 필요한 코드를 살펴 보겠습니다.
 원래 장치에서 NSUserActivity를 특정 유형으로 작성합니다.
 그리고이 유형은 사용자가 현재 수행하고있는 활동의 종류를 나타냅니다.
 그런 다음 제목을 설정하고 isEligibleForHandoff를 true로 설정합니다.
 그런 다음 userInfo 사전을 채 웁니다.
 그리고 활동을 계속하기 위해 필요한 모든 정보를 기입해야합니다.
 이 예에서는 동영상을 예로 들며 동영상 ID와 현재 재생 시간을 포함합니다.
 마지막으로이 액티비티를 viewController의 userActivity 속성에 설정하려고 할 것이다.
 이는 해당 viewController가 제공 될 때마다 현재 활동이되도록합니다.
 그리고, 그것은 원래의 장치에서해야 할 모든 것입니다.
 지속적인 장치에서 우선 앱은 사용자가 만든 활동 유형에 대한 지원을 선언해야합니다.
 그런 다음 두 개의 UIApplicationDelegate 콜백을 구현해야합니다.
 첫 번째는 application willContinueUser ActivityWithType입니다.
 그리고 아이콘을 클릭하거나 탭하면 곧바로 핸드 오프가 시작됩니다.
 이 시점에서 우리는 아직 NSUserActivity 객체를 준비하지 않았지만 계속 진행될 활동의 종류를 알고 있기 때문에 UI 준비를 시작할 수 있습니다.
 아주 조금 지나면 완전히 재구성 된 NSUserActivity 객체를 포함하는 applicationContinueRestoration 핸들러를 수신하게됩니다.
 그 시점부터 해당 장치에서 직접 경험을 설정하고 계속할 수 있습니다.
 userInfo 사전에 들어갈 수있는 것보다 많은 정보가 있다면 NSUserActivity의 훌륭한 기능인 연속 스트림을 사용할 수 있습니다.
 supportsContinuationStreams 속성을 true로 설정하면됩니다.
 그런 다음 계속 장치에서는 NSUserActivity에서 getContinuationStreams 메서드를 호출하여 입력 및 출력 스트림을 제공합니다.
 원래 장치에서 NSUserActivity의 대리자는 입력 및 출력 스트림을 제공하는 콜백을 수신합니다.
 또한 이러한 채널을 통해 발신 장치와 계속 장치 사이의 양방향 통신을 수행 할 수 있습니다.
 그러나 사용자가 가능한 한 빨리이 작업을 끝내기를 원합니다. 사용자가 장치를 분리하여 이동할 수 있기 때문입니다.
 스트림에 대한 자세한 내용은 개발자의 Stream Programming Guide를 확인하십시오.
사과.
com.
 이제는 이전의 전자 메일 핸드 오프 예와 같이 이미지 또는 비디오 내용과 같이 userInfo 사전에 입력하기에 적합하지 않은 것들을 이동하는 데 유용합니다.
 그러나 문서 기반 응용 프로그램의 경우에는 핸드 오프 이야기가 훨씬 쉽습니다.
 왜냐하면 당신은 무료로 많은 행동을 취하기 때문입니다.
 UIDocument와 NSDocument는 현재 편집중인 문서를 나타내는 NSUserActivity 객체를 자동으로 생성합니다.
 또한 iCloud에 저장된 모든 문서에 유용합니다.
 애플리케이션에서해야 할 일은 정보를 구성하는 것뿐입니다.
그에 따라 plist.
 app-to-app handoff 외에도 app-to-web 브라우저 핸드 오프도 지원합니다.
 네이티브 앱 환경과 잘 어울리는 웹 경험이 있고 연속 장치에 네이티브 앱이 설치되어 있지 않은 경우 Safari로 전달하고 웹 브라우저에서 바로 작업을 계속할 수 있습니다.
 핸드 오프는 웹 브라우저에서 앱으로의 핸드 오프를 지원합니다.
 웹 서버에 승인 된 앱 ID 목록을 구성해야하며 iOS 앱에 연결된 도메인 자격을 추가해야합니다.
 그런 다음 사용자는 iOS의 웹 경험에서 앱으로 원활하게 계속할 수 있습니다.
 이것에 대한 자세한 내용은 2014 년 핸드 오프 (Handoff) 강연을 확인하십시오.
 핸드 오프입니다.
 밖으로 나가서 응용 프로그램에 구현하십시오.
 사용자를 진심으로 환영하며, 보너스로 NSUserActivity API가 시스템 경험 전반에 걸쳐 사용됩니다.
 Spotlight 검색 및 새로운 Siri 단축키 기능과 같은 기능
 이에 대한 자세한 내용은 이전 WWDC와의 회담을 확인하십시오.
 고맙습니다.
  놀라운 앱과 경험을 씁니다.
 그러나 수시로 조사해야 할 문제가 있습니다.
 그리고이를 위해 몇 가지 매트릭스 레벨 디버깅 기술을 알려 드리겠습니다.
 하지만 먼저, 경고의 말씀.
 이 빨간 약을주고 토끼 구멍이 얼마나 깊은지를 보여주기 전에이 섹션에서 우리가 보여줄 방법이 디버깅에 유용하지만 제출하지 말아야한다는 것을 알려드립니다. App Store.
 그렇게하면 신청서가 거부되며 나쁜 날이 올 것입니다.
 그래서, 그 경고와 함께, 시작하자.
 우리는 형사 사고 방식으로 시작할 것입니다.
 당신이 당신의 프로그램에서 발견 한 문제에 접근하는 방법.
 다음으로, 우리는 뷰로 문제를 디버그하고 컨트롤러를 보는 방법에 대해 이야기 할 것입니다.
 우리는 LLDB에 대해 알려주고,이를 사용하여 앱의 상태 문제를 식별하는 방법에 대해 설명합니다.

그리고 마지막으로, 우리는 당신이 중대한 것보다 덜 느낄 수있는 중대한 기억 문제에 대한 몇 가지 기술을 살펴볼 것입니다.
 그러니 형사 사고 방식부터 시작합시다.
 프로그램에서 문제를보고있을 때 가정을 확인해야합니다.
 당신의 프로그램이 무엇을 기대하고 있습니까? 그런 다음 실제로 그렇게하고 있는지 확인하십시오.
 이는 앱의 문제를 디버깅하기 시작할 때 아주 좋은 단계입니다.
 일단 어떤 가정이 침해 당하고 있는지 확실히 알게되면 단서를 찾아서 시작할 수 있습니다.
 이 섹션에서 우리가 보여줄 도구를 사용하여 객체와 구조체를 찌를 수 있습니다.
 그런 다음 앱에서 상태를 변경하고 문제를 발견했는지 확인하여 직감을 테스트하려고합니다.
 진짜 버그 인 샘플 버그부터 시작해 보겠습니다.
 Apple에서 여기서 작업 할 수있는 특권 중 하나는 스크린 샷 편집기입니다.
 최근에 우리는 스크린 샷 펜 도구가없는 문제를 디버깅하고있었습니다.
 벤,이 문제를 진단하는 데 사용할 수있는 도구가 있습니까? 전혀.
 Xcode에 바로 내장 된 View Debugger가 있습니다.
 하단 툴바에서이 아이콘을 클릭하기 만하면 시작할 수 있습니다.
 그리고 Xcode는 전체 뷰 계층을 3D로 표현합니다.
 여기서 볼 수 있듯이, 우리의 연필 컨트롤은 여전히 ​​존재하지만, 그것들은 앞에있는이 전체 화면보기에 의해 가려져 있습니다.
 그래서, 우리는이 UI를 구축하는 곳을 찾아보고 거기에서 주문이 어떻게되는지 살펴볼 필요가 있다고 Peter는 생각합니다.
 훌륭합니다.
 Xcode View Debugger는 앱의보기 문제를 디버깅하는 데 유용한 도구입니다.
 이 도구로 도움을받을 수 있습니다.
 UIView recursiveDescription, UIView parentDescription 및 클래스 메서드 UIViewController printHierarchy는 앱의보기 및보기 컨트롤러 문제를 디버깅하는 데 유용한 도구입니다.
 다시 말하지만, 앱 스토어에 제출할 때 포함시키지 않는 것도 좋은 점입니다.
 이들은 Objective-C 선택자라는 점에 유의해야합니다.
 따라서이 명령을 사용하기 전에이 명령을 사용하여 디버거를 Objective-C 모드로 전환해야합니다.
 UIView recursiveDescription부터 시작하여이 디버깅 방법을 단계별로 살펴보고 어떻게 도움을 줄 수 있는지 살펴 보겠습니다.
 따라서 UIView recursiveDescription은 수신기의 뷰 계층 구조, 즉 하위 뷰 계층 구조를 인쇄합니다.
 레이아웃 속성을 이해하는 데 도움이되는 몇 가지 속성이 있습니다.
 예제를 살펴 보겠습니다.
 스크린 샷 UI에 누락 된보기가있는 또 다른 버그가 있습니다.
 그래서 우리는 viewController의 뷰에서 recursiveDescription을 호출 할 것입니다.
 자, 이것은 디버그 텍스트의 벽처럼 보일지도 모릅니다.
 그러나 우리는 우리가 원하는 것을 알고 있습니다.
 우리의 스크린 샷보기가 있습니다.
 우리는 그것을 볼 수 있습니다.
 검사를 통해 현재 숨겨져 있음을 알 수 있습니다.
 따라서 우리는이 뷰에서 숨겨진 속성을 설정하는 모든 곳을 살펴보고 왜 이것이 나타나지 않는지 이해해야합니다.
 recursiveDescription 외에도 UIView에는 parentDescription도 있습니다. parentView는 뷰 계층을 상위 뷰로 이동하여 no-parent에 도달 할 때까지 부모 뷰로 이동합니다.
 같은 종류의 디버깅 정보를 출력합니다.
 RecursiveDescription 및 parentDescription은 UIView 문제에 유용합니다.
 그러나 때때로 UIViewController에 문제가 있습니다.
 그리고, 당신은 위대한 클래스 메서드 인 UIViewController printHierarchy를 사용할 수 있습니다.
 최근 우리 스크린 샷 에디터에서 viewController 중 하나가 viewDidAppear 메시지를받지 못했던 버그가있었습니다.
 그래서, 그것은 국가를 적절하게 세우지 못했습니다.
 UIViewController printHierarchy를 실행하면 우리가 제공하는 모든 viewController, 우리의 viewController, parentViewControllers와 childViewController, 그리고 우리의 presentationController의 출력을 얻을 수 있습니다.
 Controllerpalooza입니다.
 이제 스크린 샷 UI에서 printHierarchy를 실행 해 봅시다.
 여기서 viewController 계층을 볼 수 있습니다.
 그리고 우리가 문제가있는 viewController를 검사 할 때, 그것이 나타나는 상태에서 멈추는 것을 볼 수 있습니다.
 그래서 우리는 콜백을 놓쳤다.
 그래서 우리는이 콜백을 어디에서 호출 할 것인가를 살펴볼 필요가 있습니다. 그런 다음 문제를 발견했습니다.
 그래서 큰.
 이 메소드를 사용하여 view 및 viewController 문제를 식별 할 수 있습니다.
 하지만 때로는 앱에 근본적인 문제가 있습니다.
 그리고, 우리는 우리가 가지고있는 위대한 상태 디버깅 팁을 사용할 수 있습니다.
 LLDB의 표현 명령을 사용하면 디버거에서 임의의 코드를 실행할 수 있습니다.
 그것에 대해 생각해보십시오.
 소스 편집기에서 실행할 수있는 모든 코드는 디버거에서 직접 작성하고 프로그램이 실행되는 동안 실행할 수 있습니다.
 이것은 디버깅에 매우 유용합니다.
 구조체에서 함수를 호출하고 객체의 속성을 가져올 수 있으며 프로그램이 수행하는 작업을보다 잘 진단 할 수 있습니다.

디버깅에 대한 자세한 내용은 2012 년부터 LLDB를 사용하여 디버깅하는 방법과 2014 년 Swift를 사용하여 디버깅하는 방법에 대한 정보를 확인하십시오.
 표현 명령을 사용하여 LLDB 내부에서 실행할 수있는 몇 가지 훌륭한 기능이 있습니다. 우리가 가르쳐 줄 것입니다.
 그리고 첫 번째 것은 덤프입니다.
  덤프는 모든 Swift 객체와 구조체 속성을 인쇄합니다.
 우리가 사용자 정의 UI 중 일부에서 가지고있는 또 다른 버그를 살펴 보겠습니다.
 우리는 몇 가지 레이블과 imageView를 포함한 여러 가지 하위 뷰가있는 뷰를 가지고 있습니다.
 그리고, 지금 우리 레이블 중 하나가 없습니다.
 그래서 부모보기에서 덤프를 실행하고 여기에서 무슨 일이 일어나는지 살펴 보겠습니다.
 그래서 우리는 잃어버린 레이블을 발견했습니다.
 그것은 여기에 있습니다. 그러나 우리가 위로 가져 와서 그것과 나란히있는 이미지보기를 보면, 우리는이 두 가지의 틀, 둘 다 같은 기원을 가지고 있다는 것을 알게됩니다.
 그래서 여기에서 일어날 수있는 일은 라벨이 imageView에 의해 가려져 있다는 것입니다.
 따라서 레이아웃 코드를 다시 살펴 봐야합니다.
 Swift 객체에 대한 덤프 이외에, 여전히 Objective-C 코드가있는 경우 NSObject는 ivarDescription 메소드도 가지고 있습니다.
 그러면 Objective-C 오브젝트의 모든 인스턴스 변수가 인쇄됩니다.
 스크린 샷의 코드에 또 다른 버그가 있습니다. 우리는 자르기 핸들이 어떤 이유로 작동하지 않습니다.
 스크린 샷보기에서 ivarDescription을 호출하면 cropEnabled ivar이 현재 no로 설정되어 있음을 자세히 볼 수 있습니다.
 그래서 우리는이 버그를 조사하기 좋은 곳이 있습니다.
 훌륭합니다.
 dump와 ivarDescription을 사용하면 앱의 문제를 진단 할 수 있습니다.
 또 다른 멋진 디버깅 팁과 트릭은 중단 점입니다.
 중단 점을 사용하면 임의의 실행 상태에서 프로그램을 일시 중지하고 명령을 실행할 수 있습니다.
 LLDB 명령 줄 또는 Xcode UI를 사용하면 이러한 중단 점을 실행하기 전에 조건을 추가 할 수도 있고 중단 점에 도달 할 때마다 명령을 실행할 수도 있습니다.
 중단 점은 디버깅 워크 플로의 필수적인 부분입니다.
 그리고 Xcode에서 설정 한 중단 점과 함께 expression 명령 및 dump와 ivarDescription을 사용할 수 있습니다.
 다음 번에 앱으로 문제를 디버깅 할 때 중단 점을 사용하는 것이 좋습니다.
 그러나 가끔 view 또는 viewController에 문제가 없습니다.
 우리는 주 (state)에 문제가 없으며, 대신에 우리는 정말로 털이 많은 메모리 관리 문제가 있습니다.
 벤, 우리가 사용할 수있는 도구가 있습니까? 네가 Peter에게 물어 봤기 때문에 기쁩니다. Xcode에 훌륭한 툴이 내장되어 있기 때문입니다.
 Xcode 메모리 디버거.
 이 도구는 응용 프로그램에서 메모리를 사용하는 방식을 정확하게 시각화하는 데 도움을줍니다.
 피터와 저는 요 전날 우리가 누수있는 viewController가있는 문제를 디버깅하고있었습니다.
 그리고 우리는 그것이 블록에 의해 유지되고 있다는 것을 볼 수 있습니다.
 Malloc 스택 로깅을 활성화함으로써이 블록이 할당되었을 때의 정확한 백 트레이스를 볼 수있었습니다.
 확대하면이 블록이 해당 viewController에 의해 실제로 생성 된 것을 알 수 있습니다.
 그리고 그 블록은 그 viewController를 잡고 있습니다.
 그러나 그 viewController는 또한 블록을 잡고있다.
 그리고 우리의 유지주기가 있습니다.
 와우.
 큰! Xcode 메모리 그래프 디버거는 앱에서 이와 같은 문제를 진단하는 데 훌륭한 도구입니다.
 더 자세한 내용은 2017 년 Xcode 9 토론을 통한 디버깅을 확인하십시오.
 그래서 프로처럼 앱을 디버깅 할 수 있습니다.
 프로그램에 문제가 발생할 때마다 형사처럼 생각하십시오.
 Xcode 뷰 디버거 및 메모리 그래프 디버거를 사용하여 뷰 및 메모리 관련 문제를 심층적으로 살펴보십시오.
 그리고 LLDB의 expression 명령을 dump와 함께 사용하고 여기에서 언급 한 다른 모든 훌륭한 디버깅 방법을 사용하십시오.
 고맙습니다.
  오늘 오후에 여섯 개의 정말 흥미로운 주제를 다뤘습니다.
 그러나 우리는 간신히 표면을 긁었다.
 이 프레젠테이션에서 언급 한 대화를 확인하고 응용 프로그램에 더 많은 즐거움을 선사하는 것이 좋습니다.
 자세한 내용은 개발자 포털의 페이지를 확인하고 감사합니다.
 우리는 당신에게 훌륭한 컨퍼런스가 있기를 바랍니다.
 고맙습니다.
