알았어 [박수].
 감사합니다 [박수].
 안녕하십니까. 오늘 Core Image에 대한 세션에 참석해 주셔서 감사합니다.
 저는 David Hayward입니다. 저는 지난 한 해 동안 Core Image에 우리 팀이 추가 한 훌륭한 성능과 프로토 타이핑 기능에 대해 이야기하게되어 정말 기쁩니다.
 우리는 할 얘기가 많기 때문에 의제에 바로 들어가 봅시다.
 따라서 우리가 오늘 이야기하게 될 첫 번째 사항은 애플리케이션의 성능을 향상시키는 데 도움이되도록 Core Image에 추가 한 멋진 새 API입니다.
 그 후에 우리는 Core Image를 사용하여 새로운 알고리즘 개발의 프로토 타입을 도울 수있는 또 다른 주제로 나아갈 것입니다.
 마지막으로 우리는 다양한 기계 학습 응용 프로그램에서 Core Image를 어떻게 사용할 수 있는지에 대해 이야기 할 것입니다.
 괜찮아.
 이제 성능 API에 대해 이야기 해 보겠습니다.
 우리가 올해 실적에 대해 연구해온 두 가지 주요 영역이 있습니다.
 우선, 중간 버퍼 삽입을위한 몇 가지 새로운 컨트롤을 추가했습니다. 이에 대해 자세히 설명하겠습니다.
 그리고 두 번째로 우리는 당신이 이용할 수있는 새로운 CI 커널 언어 기능에 대해서 이야기 할 것입니다.
 먼저 중간 버퍼에 대해 살펴 보겠습니다.
 알고 계시 겠지만, 이전에 Core Image를 사용 해본 적이 있다면 Core Image를 사용하여 일련의 필터를 쉽게 연결할 수 있습니다.
 코어 이미지의 모든 필터는 하나 이상의 커널로 구성됩니다.
 Core Image가 성능을 향상시키는 데 사용하는 훌륭한 기능 중 하나는 중간 버퍼 수를 최소화하기 위해 커널을 연결하는 기능입니다.
 대부분의 경우 최상의 성능을 얻으려면 최소한의 버퍼 수가 필요합니다.
 그러나 가능한 한 많이 연결하지 않으려는 시나리오가 있습니다.
 예를 들어 필터 체인 초기에 응용 프로그램에 값 비싼 필터가있을 수 있습니다.
 그리고 주어진 순간에 응용 프로그램 사용자는 그래프에서 그 다음에 오는 필터를 조정할 수도 있습니다.
 그리고 이런 중간 위치에 중간 버퍼를 두는 것이 좋은 생각입니다.
 여기에 중간 버퍼를두면 보조 필터를 조정할 때 값 비싼 필터의 비용을 다시 지불 할 필요가 없다는 것입니다.
 그렇다면 응용 프로그램에서 어떻게합니까? 중간에 삽입하는 새로운 API가 있습니다.
 그래서 이것이 우리의 결과에 어떻게 영향을 미치는지 이야기 해 봅시다.
 가능한 한 많이 연결하는 대신 중간의 위치를 ​​존중하고 최대한 중간으로 연결합니다.
 이것에 대한 몇 가지 메모.
 한 가지 명심해야 할 것은, 기본적으로 Core Image는 모든 중간 버퍼를 캐쉬하기 때문에 후속 렌더링이 가능한 빨리 이루어질 수 있다는 가정입니다.
 그러나 때로는 중간체 캐싱을 끄려는 경우가 있습니다.
 예를 들어, 응용 프로그램에서 100 개의 이미지를 일괄 적으로 내보내는 경우 첫 번째 이미지를 캐싱하는 것이 거의 효과가 없습니다. 그 이유는 나중에 완전히 다른 이미지를 렌더링하기 때문입니다.
 따라서 컨텍스트 옵션 캐시 중간체를 사용하고 해당 값을 false로 설정하여 응용 프로그램에서 오늘 할 수 있습니다.
 그러나이 새 API를 사용하는 경우에도이 컨텍스트 옵션이 꺼져 있어도 중간체 캐싱을 사용할 수 있습니다.
 그래서, 이것은 여러분이 우리가 무언가를 캐시하고 다른 것을 캐시하지 않도록 확실히 해줍니다.
 다음 주제는 이미지 처리를 적용 할 수있는 커널 언어에 추가 한 몇 가지 새로운 기능입니다.
 코어 이미지에 커널을 작성하는 데에는 두 가지 다른 방법이 있습니다.
 전통적인 방법은 CI 커널 언어를 사용하는 것입니다.
 이 경우 소스 파일 내에 문자열이 있습니다. Swift 코드 또는 목적 C 코드.
 그리고 런타임에 여러분은 소스를 가진 커널을 호출합니다.
 그리고 나중에 커널을 기반으로 이미지를 만들 때 컨텍스트가 Metal 또는 Open GL에 의해 뒷받침되는지 여부와 상관없이 모든 유형의 Core Image 컨텍스트로 렌더링 할 수 있습니다.
 그러나 렌더링 할 시간이되면 해당 소스를 번역해야합니다.
 그것은 Metal이나 GLSL로 번역되어야하며, 그 단계는 비용이 든다.
 결국 그 코드는 GPU 명령어 세트로 컴파일 된 다음 실행됩니다.
 작년에 iOS 11부터 CI 커널을 작성하는 새로운 방법을 추가했습니다.이 방법에는 몇 가지 중요한 이점이 있습니다.
 금속 음영 언어를 기반으로하는 CI 커널입니다.
 이 경우 프로젝트에 소스가 있고 이것이 있습니다.이 소스는 런타임이 아닌 빌드시에 컴파일됩니다.
 이전과 같이, Metal 함수 이름과 이진 데이터가있는 커널을 사용하여이 코드를 기반으로 커널을 구체화합니다.
 이점은이 데이터가 추가 컴파일 비용을 지불하지 않고도 적용될 수 있다는 것입니다.
 단,주의해야 할 점은 금속 지원 CI 컨텍스트에서 작동한다는 것입니다.
 하지만 큰 성능 이점을 제공합니다.

이 릴리스부터는 CI 커널 언어를 더 이상 사용하지 않는 것으로 표시 할 것입니다. 왜냐하면 우리가이 언어를 계속 지원할 것이기 때문에 금속 커널을 작성하는 새로운 방법은 개발자에게 많은 이점을 제공한다고 생각합니다. .
 우선 앞에서 간략히 설명한 성능 이점을 얻을 수 있지만 Metal 소스로 작업 할 때 코드 및 훌륭한 디버깅 도구에서 빌드 타임 구문 색을 얻을 수 있다는 장점이 있습니다.
 그래서 큰.
 그래서, 그걸 염두에두고 우리가 커널 언어에 추가 한 몇 가지 다른 것들에 대해서 이야기하고 싶습니다.
 우선, 우리는 하프 플로트 지원을 추가했습니다.
 CI 플로어가 제공하는 정밀도에 CI 커널이 완벽하게 만족할 수있는 경우가 많이 있습니다.
 RGB 색상 값으로 작업하는 경우 반 부동 소수점 정밀도가 충분합니다.
 커널에서 반 플로트를 사용하면 특히 iPhone 10과 같은 A11 장치에서 작업을 빠르게 실행할 수 있다는 장점이 있습니다.
 커널에서 반 플로트를 사용하는 또 다른 이점은 레지스터 크기가 작아 GPU의 사용량이 증가하므로 성능에 도움이된다는 것입니다.
 올해 우리가 커널 언어에 추가 한 또 다른 훌륭한 기능은 그룹 읽기 지원을 추가하는 것입니다.
 이렇게하면 쉐이더에 하나의 명령어로 입력 이미지에서 4 개의 단일 채널 읽기를 수행 할 수 있으므로 실제로 도움이 될 수 있습니다.
 또한이를 보완하기 위해 픽셀 그룹을 작성하는 기능도 있습니다.
 이렇게하면 셰이더 내부에서 한 번의 호출로 이미지의 4 픽셀을 쓸 수 있습니다.
 따라서 세 가지 모든 기능을 쉐이더에서 사용하여 성능을 크게 향상시킬 수 있습니다.
 그래서, 그것이 어떻게 작동하는지에 대한 예제에 대해 조금 이야기하겠습니다.
 그래서 오늘 이미지의 한 채널에서만 작동하는 간단한 3 by 3 컨볼 루션 커널을 가지고 있다고 상상해보십시오.
 이것은 실제로 이미지의 휘도를 선명하게하려는 경우와 같이 매우 일반적인 작업입니다.
 그래서, 이와 같은 커널에서 일반적으로, 여러분은 커널이 불러올 때마다 하나의 출력 픽셀을 생성해야합니다.
 그러나 이것은 3 x 3 컨볼 루션이기 때문에 커널은 그 효과를 얻기 위해 9 픽셀을 읽어야합니다.
 따라서 우리는 1 픽셀 씩 쓰면서 9 픽셀을 읽습니다.
 그러나 새로운 그룹 쓰기 기능을 사용하여이를 향상시킬 수 있습니다.
 새로운 그룹 쓰기 기능으로 커널은 한 번의 회부로 2x2 픽셀 그룹을 쓸 수 있습니다.
 이제 2 x 2 그룹이 조금 더 커지므로 3 x 3 대신 4 x 4 픽셀 세트를 읽어야 4 픽셀을 쓸 수 있습니다.
 그러나 만약 당신이 수학을한다면, 우리는 4 픽셀 씩 쓰여진 16 픽셀을 읽었다는 것을 알게 될 것입니다.
 그래서, 이미 우위를 점하고 있습니다.
 우리가 가지고있는 또 다른 특징은 수집을 할 수있는 능력입니다.
 이 예에서는 4 x 4 또는 16 픽셀을 읽습니다.
 이 기능을 사용하면 단 4 개의 명령어로 16 픽셀을 빨간색으로 처리 할 수 ​​있습니다.
 다시 한번 말하지만, 이것에 대한 수학을 살펴보면, 이것은 4 픽셀 씩마다 4 번의 그룹 읽기를한다는 것을 의미합니다.
 그리고 이것은 실제로 성과를 도울 수 있습니다.
 이 과정을 실제 커널 코드로 안내하겠습니다.
 그래서, 여기에 설명 된 것과 같은 단순한 회선의 예가 있습니다.
 여기에서 우리가하는 일은 입력 이미지에서 9 개의 샘플을 만드는 것이고 우리는 그것의 빨간 채널만을 사용하고 있습니다.
 그런 다음 9 개의 값을 얻으면 9 개의 값을 평균화하고 vec4 픽셀 값 하나를 반환하여 전통적인 방식으로 출력합니다.
 이제이를 더 빠르게 만드는 첫 번째 단계는 이것을 Metal로 변환하는 것입니다.
 이것은 실제로 매우 간단합니다.
 그래서 우리는 전통적인 CI 커널 언어 인이 코드를 시작합니다.
 그리고 효과적으로 코드를 검색하고 대체하면 새로운 Metal 기반 CI 커널 언어로 업데이트 할 수 있습니다.
 여기서 주목해야 할 몇 가지 중요한 사항이 있습니다.
 커널에 대상 매개 변수를 추가했습니다. 셰이더 내부의 대상 좌표를 확인하는 경우이 매개 변수가 중요합니다.
 그리고 나서 우리는 sample - s을 말함으로써 입력에서 샘플링하기 위해 더 새롭고 더 현대적인 구문을 사용합니다.
샘플 및 s.
변환.
 그리고이 코드를 업데이트 할 때 마지막으로했던 일은 전통적인 vec4와 vec2 매개 변수 유형을 float 4와 float 2로 변경하는 것입니다.
 그러나 당신이 볼 수 있듯이, 코드의 전반적인 구조, 커널의 흐름은 동일합니다.
 괜찮아.
 2 단계는 반 플로트를 사용하는 것입니다.
 다시 말하지만,이 예제는 색상 값으로 작업하기 때문에 반 부동 소수점의 정밀도를 사용하여 손을 뗄 수있는 예제이며 다시 코드에 대한 간단한 변경을 다시 수행 할 것입니다.
 기본적으로 부동 소수점 정밀도를 사용하는 코드의 위치는 반 부동 소수점 정밀도를 사용합니다.
 즉, sampler 매개 변수와 대상 매개 변수에 밑줄 H 접미사가 있고 코드에 대소 문자가있는 경우가 있습니다.


즉, sampler 매개 변수와 대상 매개 변수에 밑줄 H 접미사가 있고 플로트 4를 사용하는 코드의 모든 경우가 이제 반 4가됩니다.
 다시 한번 말하지만, 이것은 매우 간단하고 쉽습니다.
 또 하나주의해야 할 점은 코드에서 일관성을 유지한다면 9로 나누는 것과 같이 끝 부분에 H를 추가해야한다는 것입니다.
0.
 다시 한번 이것도 - 이것은 또 다른 단순한 것입니다.
 이 예제에서 최상의 성능을 얻으려고 할 마지막 일은 그룹 읽기와 그룹 쓰기를 활용하는 것입니다.
 자, 코드를 작성해 보도록하겠습니다.
 다시 말하자면, 2x2 픽셀 그룹을 작성하고이를 통해 4x4 픽셀 그룹을 읽어야합니다.
 따라서 우리가 할 첫 번째 일은 그룹 대상을 지정하는 것입니다.
 함수 선언을 보면 그룹 대상 인 H 데이터 유형이 있습니다.
 그런 다음 이전과 같이 대상 좌표를 가져 오려고합니다. 그러면 픽셀의 중심을 가리 킵니다.
 그러나이 좌표는 실제로 2x2 픽셀 그룹의 좌표를 나타냅니다.
 이 2 x 2 픽셀 그룹을 채우려면 다음으로해야 할 일은 이미지에서 여러 번 읽는 것입니다.
 따라서 첫 번째 수집은 2 x 2 픽셀 그룹에서 읽을 것입니다.이 경우 16 개의 하위 왼쪽 모서리입니다.
 그리고 붉은 색 채널의 값을 2/3 배열로 반환 할 것입니다.
 네 개의 매개 변수는 반 시계 방향으로 X, Y, Z, W 순서로 저장됩니다.
 메탈에서 수집 작업에 익숙하다면 이것은 메탈에서 사용되는 것과 같은 방향입니다.
 그래서 다시 한 번 지시로 4 번 읽었고 다른 4 개의 그룹에 대해서도이 과정을 반복 할 것입니다.
 그래서 우리는 그룹 2, 그룹 3, 그룹 4로 갈 것입니다.
 이제 16 개의 모든 읽기를 완료 했으므로 어떤 값이 어떤 위치에 있는지 파악해야합니다.
 그래서, 우리가 할 첫 번째 일은 3x3 하위 그룹의 적절한 채널을 얻어서 함께 평균화하는 것입니다.
 그런 다음 결과 값 1 변수에 해당 채널을 저장합니다.
 그리고이 과정을 우리가 작성하고자하는 다른 네 개의 결과 픽셀, 즉 R1, R2, R3 및 R4에 대해 반복 할 것입니다.
 그리고 우리가 할 마지막 일은 "Destination Write"라고 불리며 4 픽셀을 한 번에 쓸 수 있습니다.
 따라서 이것은 일반적인 CI 커널과 약간 다르다. 커널에서 값을 반환하고 대신 "Destination Write"라고 부르기로했다.
 괜찮아.
 따라서이 모든 작업의 ​​큰 결과는 아주 적은 노력으로이 정확한 쉐이더에서 두 배의 성능을 얻을 수 있다는 것입니다.
 이것은 매우 간단한 셰이더입니다.
 많은 다른 유형의 셰이더, 특히 콘볼 루션을 수행하는 셰이더에서 실제로 유사한 결과를 얻을 수 있습니다.
 따라서 커널에 성능을 추가하는 좋은 방법입니다.
 그래서 저는 seg로 갈 것입니다 - 전통적인 커널 커널 언어와 Metal을 기반으로하는 CI 커널 언어 모두에 대해 커널 언어에 대해 가지고있는 위대한 새로운 문서를 사람들에게 알려주고 싶습니다.
 이 문서를 읽고 읽어 보시기 바랍니다.
 이제 커널을 실행할 수있는 방법의 성능을 향상시키는 방법에 대해 이야기 했으므로 Emanuel을 무대로 불러 내고 새로운 알고리즘의 개발 프로세스를보다 빠르게 만들 수있는 방법을 알려줄 것입니다. .
  고마워, 데이빗.
 여러분 좋은 오후입니다.
 여기 와서 반갑습니다.
 저는 Emmanuel입니다. 저는 Core Image 팀의 엔지니어입니다.
 따라서 이번 세션의 다음 반 동안, 우리는 Core Image Engine에서 벗어나 Core Image를 사용하여 프로토 타입을 만드는 새로운 방법을 모색 할 것입니다.
 우리는 또한 귀하의 기계 학습 응용 프로그램에서 Core Image를 어떻게 활용할 수 있는지 보여줄 것입니다.
 시작하겠습니다.
 프로토 타이핑에 대해 이야기하고 싶으므로 이미지 처리 필터의 수명주기를 살펴 보겠습니다.
 그래서, 전경에서 배경까지의 세분화가 필요하다고 가정 해 봅시다.
 그리고 여기서, 이것은 정확히 1이라는 가면을 얻고 싶다는 것을 의미합니다.
포 그라운드에서 0; 0.
0의 값을 가지며 그 사이에 연속적인 값을가집니다.
 이러한 필터를 구현하는 데 따른 어려움은 사용 가능한 데이터의 성격에 따라 크게 좌우됩니다.
 예를 들어, RGB 이미지 옆에 추가 깊이 버퍼가 있으면 작업이 더 쉬워 질 수 있습니다.
 그리고 RGB 이미지와 깊이 정보를 결합하는 데 관심이 있다면이를 사용하여 사진 및 비디오 효과를 만드는 방법에 대해 세션을 살펴 보시기 바랍니다.
 오늘날 나는 이러한 다른 정보 소스에 집중하고 싶지 않지만 일반적으로 프로토 타이핑에 초점을 맞추기를 원합니다. 그래서 그렇게 가정 해 봅시다.이 필터는 잘 작성되었으며, 우리는 그 효과를 알고 있습니다. 우리는이 특별한 경우에 전경과 배경 마스크를 생각해냅니다.

매우 자연스러운 단계는 구현을 시도하는 것입니다. 스택에서 가장 좋아하는 프로토 타입을 선택하면 해킹을 시작하고 여러 필터를 결합하여 사용자가보고있는 필터 효과를 얻을 수있는 방식으로 보여줍니다.
 그래서, 여러분이 그렇게했다고 가정 해 보겠습니다. 여기에 배경 마스크와 같은 전경의 예가 있습니다.
 이제 iOS 또는 Mac OS 환경에있는 경우 매우 자연스러운 단계는 해당 알고리즘을 배포하는 것입니다.
 따라서 Core Image, Metal-with-Metal 성능 쉐이더 및 VImage와 같은 다양한 기능을 사용하여 CPU에 머무를 수 있습니다.
 프로토 타입에서 프로덕션까지의 초기 포트는 상당히 많은 시간이 소요될 수 있습니다. 첫 번째 렌더링은 예상 한 것과 완전히 다르게 표시 될 수 있습니다.
 그리고 이러한 픽셀 차이에 기여할 수있는 다양한 소스가 있습니다. 그 중 하나는 필터가 프레임 워크에서 구현되는 방식이 상당히 다를 수 있다는 것입니다.
 여기 왼쪽에서 예제를 들으면 전경에서 배경으로이 멋진 페더 링을 적용하는 [들리지 않음] 흐림 효과가 있습니다.
 그리고 이것은 훨씬 더 빠르게 만들기 위해 두드러진 성능 최적화의 그리드 다양성을 활용할 수있는 필터의 예입니다.
 이러한 모든 최적화는 필터 스택에서 전파되는 수치 오류를 유발하여 잠재적으로 필터 출력에 극적인 변화를 일으킬 수 있습니다.
 코드를 작성할 때 일반적으로 발생하는 또 다른 문제는 프로토 타입 환경에서 많은 메모리 관리가 처리된다는 것입니다.
 따라서 게임에서 꽤 늦을 때까지 메모리 압력과 메모리 소비 문제에 자주 빠지지는 않습니다.
 물론 또 하나의 주제는 성능입니다.
 흔히 프로토 타입은 이미 CPU 코드를 사용하고 있으며 때로는 CP 코드를 GP 코드로 가리킬 때 얻을 수있는 성능의 양을 과대 평가하여 모든 것이 실시간으로 처리 될 것이라고 생각합니다.
 그렇다면 프로토 타이핑과 워크 플로우에서 이러한 관심사를 잡을 수 있다면 어떨까요? 우리에게는 당신을위한 해결책이 있다고 믿습니다.
 PyCoreImage라고 불립니다.
 코어 이미지 용 파이썬 바인딩.
 따라서 Core Image의 고성능 렌더링과 Python 프로그래밍 언어의 융통성을 결합하는 것입니다.
 또한 Core Image를 사용하여 200 개 이상의 내장 필터와 함께 iOS 및 Mac OS에 대한 지원을 이어받습니다.
 PyCoreImage의 내용을 살펴 보겠습니다.
 따라서 PyCoreImage는 세 가지 주요 부분으로 구성됩니다.
 렌더링 백엔드를 위해 Core Image를 사용합니다.
 그것은 프로그래밍 인터페이스를 위해 파이썬을 사용합니다.
 또한 기존 코드 기반과의 상호 운용성을 허용하는 [인식 할 수없는] 코드의 얇은 레이어가 있습니다.
 PyCoreImage를 사용하면 프로토 타이핑과 제품 준비 코드 간의 마찰을 줄일 수 있습니다.
 스위프트 중심의 환경에 머물고 싶으면 스위프트 놀이터를 사용하여 많은 것을 할 수 있으며, 자신 만의 스위프트 놀이터 구독을 만드는 세션을 살펴 보는 것이 좋습니다.
 괜찮아.
 PyCoreImage의 주요 구성 요소를 살펴 보겠습니다.
 그래서 PyCoreImage는 객관적인 C, PyObjC를위한 파이썬 바인딩을 활용하며 흥미롭게도 Mac OS 10부터 PyObjC를 출시했습니다.
5 레오파드.
 처음에는 Python과 Objective C 사이의 양방향 브리지로 구현되었으며 Coco 앱 개발과 관련하여 [들리지 않음]으로 구현되었습니다.
 그러나 그 이후로 대부분의 Apple 프레임 워크를 지원하도록 확장되었습니다.
 PyObjC의 호출 구문은 매우 간단합니다. 기존의 Objective C 코드를 사용하고 열을 밑줄로 표시합니다.
 몇 가지 복잡한 점이 있습니다. 자세한 정보를 원하시면 API를 살펴 보시기 바랍니다.
 CIVector 클래스를 예로 들어 보겠습니다.
 CIVector, Vector를 X, Y, Z, W로 호출하여 CIVector의 인스턴스를 생성하는 Objective C 코드가 있습니다.
 PyObjC 코드를 살펴 보겠습니다.
 그것은 매우 유사합니다.
 Quartz 우산 패키지에서 CIVector를 가져 오면 X, Y, Z, W 및 CIVector 클래스가있는 벡터를 직접 호출 할 수 있습니다.
 여기서 주목할 점은 코드가 파이썬처럼 보이지 않는다는 것입니다.
 그래서 우리는 몇 분 안에 그 문제를 해결할 것입니다.
 이제 PyCoreImage의 [들리지 않음] 그램을 살펴 보겠습니다.
 따라서 다시 렌더링 할 때 Core Image를 사용하기 때문에 Core Image는 하드웨어에 매우 가깝기 때문에 가능한 한 많은 성능을 제공하기 위해 필터링 된 호출을 가장 적절한 렌더링 백엔드로 리디렉션 할 수 있습니다.
 PyObjC는 Core Image 위에 존재하며 Quartz 우산 패키지로 Core Image 용 Python 바인딩을 통해 PyObj와 통신 할 수 있습니다.

그리고 Quartz는 Core Graphics와 같은 다양한 이미지 처리 프레임 워크와 CIVector, CIImages, CI Context와 같은 Core Image를 사용하는 모든 클래스를 포함하고있는 패키지입니다.
 PyCoreImage는 PyObjC 위에 존재하며, 기본적으로 PyObjC를 활용하여 Core Image와 통신 할 수 있으며 사용자를 위해 많은 단순화 작업을 수행하므로 설치 코드가 많지 않습니다. Core Image로 작업합니다.
 그리고 우리는 잠시 후에 이것을 살펴볼 것입니다.
 이 중 많은 부분이 CIMG 클래스를 통해 이루어지며 이는 벤더 호출을 통해 NumPy로 해석 할 때도 사용할 수 있습니다.
 또한 클래스 생성자를 직접 사용하여 NumPy 버퍼를 래핑 할 수도 있습니다.
 괜찮아.
 따라서, PyCoreImage를 사용하여 필터를 적용하는 방법을 예로 들어 보겠습니다. 프레임 워크가 얼마나 단순하고 강력한 지 알 수 있습니다.
 따라서 가장 먼저해야 할 일은 PyCoreImage 패키지에서 CIMG 클래스를 가져와 파일에서 이미지를로드하는 것입니다.
 이 시점에서 픽셀 버퍼는 없습니다.
 Core Image는 이미지를위한 레시피를 생성하고 레서피는 단지 파일로부터 이미지를로드하라는 지시를 내리고 있습니다.
 필터를 적용하고 그 위에 CI 필터 이름을 호출하고이 경우 입력 우선자인 반경을 전달하여보다 복잡한 그래프를 만들 수 있습니다.
 그리고 우리는 더 복잡한 그래프를 조립할 수 있습니다.
 그리고 그것을 확대하면 중간에 프로세서가 흐려지는 것을 볼 수 있습니다.
 픽셀 버퍼 표현을 원한다면 CIMG 인스턴스에서 렌더링을 호출하면됩니다.
 그리고 당신이 나가는 것은 완충 장치에 의한 적절한 단위입니다.
 따라서 가능한 한 Core Image가 호출되는 방식을 간단히 설명하거나 약간의 설정 코드를 작성해야합니다.
 따라서 Core Image에 이미 익숙한 사용자의 경우 놀라지 않을 것입니다. 익숙하지 않은 사용자의 경우 끝까지 나와 함께 있어야합니다.
 우리가 만든 몇 가지 단순화를 볼 수 있습니다.
 따라서 Core Image는 iOS 및 Mac OS는 물론 다양한 렌더링 백엔드를 지원하는 고성능 GPU 이미지 처리 프레임 워크입니다.
 대부분의 픽셀 형식이 지원됩니다.
 이는 물론 다양한 공급 업체의 원시 파일뿐만 아니라 비트 맵 데이터를 의미합니다.
 대부분의 파일 형식이 지원되므로 많은 벤더의 비트 맵 데이터와 원시 형식과 마찬가지로 대부분의 픽셀 형식이 분리되어 있습니다.
 따라서 예를 들어, 계산 및 1/2 부동 및 전체 32 비트 부동의 최종 렌더링 중에 부호없는 8 비트로 이미지를로드 할 수 있습니다.
 Core Image는 캡처 시간과 같은 이미지 메타 데이터를 추출 할 수 있습니다. 존재하는 태그 및 인물 메타 데이터 (예 : 인물지도 및 세로 깊이 정보)가 있습니다.
 Core Image는 색상 관리를 잘 처리합니다.
 많은 프레임 워크가 처리하지 못하는 어려운 주제입니다.
 Core Image는 많은 배터리 상태, 무한한 이미지를 지원하며 사용할 수있는 200 개 이상의 내장 필터가 있으므로 바퀴를 발명 할 필요가 없습니다.
 좋습니다. 그렇다고해서 많은 정보가 필요하다는 것을 확신 할 필요가 없습니다. 프로토 타입과 워크 플로우에서 Core Image를 사용하려고한다면 학습 곡선이 꽤 가파르다.
 그래서 우리가 한 일은 우리가 그 목록을 최상으로 유지하면서 몇 가지 단순화를 만들었습니다. 기억해두면, 이러한 단순화는 모두 한 번에 무시할 수 있습니다.
 그리고 가중치 부여 된 코드를 제공 할 것이므로 프로토 타입 스택 인 경우 이러한 변경 사항을 실제로 하드 코딩 할 수 있습니다.
 우리가 한 첫 번째 일은 Core Image의 고성능 기능을 여전히 가지고 있다는 것입니다.
 우리는 여전히 메탈 백엔드로 렌더링합니다.
 대부분의 모든 형식은 여전히 ​​지원되며 데이터의 캡처 시간과 세로 깊이 및 매트 정보를 추출 할 수 있습니다.
 마지막으로, 사용할 수있는 200 개 이상의 기본 제공 필터가 있습니다.
 우리가 처음 변경 한 것은 기본적으로 모든 렌더링이 32 비트 부동 소수점을 사용하여 완료된다는 것입니다.
 두 번째 변경 사항은 SRGB 색상 공간을 사용하여 모든 작업이 완료됩니다.
 셋째, 모든 경계 조건은 클램핑 및 자르기로 처리됩니다.
 즉, 예를 들어 회선 또는 생성을 적용하면 이미지가 무한히 반복됩니다.
 필터가 적용되고 결과 이미지가 입력 크기로 다시 자릅니다.
 이 설정은 한 번에 재정의 할 수도 있습니다.
 마지막으로 무한한 이미지가 유한 해져서 픽셀 버퍼 표현을 얻을 수 있습니다. 이것이 바로 PyCoreImage가 실제 적용되는 이미지입니다.
 따라서이 모든 기능을 실제로 경험하기 전에 PyCoreImage에 대한 치트 시트를 빨리보고 싶습니다.
 이제 API를 살펴 보겠습니다.
 따라서 앞에서 보았 듯이 pycoreimage 패키지에서 CIMG 클래스를 가져옵니다.
 이 파일을 사용하여 [inaudible] 파일의 이미지를로드 할 수 있습니다.
 궁금한 당신들을위한 스위프트 동등 물이 있습니다.
 파일 내용에 CIImage를 사용할 수 있습니다.

fromfile을 사용하여 usepth 및 usematte 옵션 인수를 사용하여 세로 방향 매트 정보뿐만 아니라 세로 방향 깊이를로드 할 수 있습니다.
 NumPy를 사용하여 NumPy 버퍼를 CIImage 생성자로 래핑하거나 CIImage 인스턴스에서 render를 직접 호출하여 다른 방법으로 해석 할 수 있습니다.
 Swift에 있다면 좀 더 많은 코딩 작업이 필요합니다.
 먼저 CI 렌더 대상을 만들어야합니다.
 버퍼를 이전에 할당했는지 확인하십시오.
 올바른 버퍼 속성을 제공하고 CI Contex 및 Qtest 렌더링의 발생률을 시작하고 생성하십시오.
 그래서, 그 모든 것들이 당신을 위해 두려운 곳에서 처리됩니다.
 Core Image는 색상에서 이미지를 생성하거나 생성기에서 이미지를 만드는 것과 같은 잔상을 지원합니다.
 이제 필터를 적용하는 방법을 살펴 보겠습니다.
 따라서 필터를 적용하는 것이 결코 쉬운 일은 아닙니다.
 CIImage 인스턴스를 가져 와서 필터 이름을 직접 호출하고 입력 프라이 머리 목록을 전달합니다.
 모든 CIImage 인스턴스에는 코어 이미지 필터에 직접 매핑되는 200 개 이상의 람다 표현식이 추가되었습니다.
 스위프트에 있다면, 필자는 필터를 적용하고 필터 이름과 입력 인수 목록을 키 값 쌍의 사전으로 전달하기 전에 본 구문을 사용합니다.
 커널을 적용하려면 CIMG 인스턴스에서 applykernel을 실행하여 커널 코드가 들어있는 소스 문자열과 입력 매개 변수 목록을 해당 커널에 전달하면됩니다. 잠시 후에 살펴 보겠습니다.
 그런 다음 샘플링중인 버퍼에서 샘플링중인 관심 영역뿐만 아니라 커널을 적용하는 범위를 지정하면됩니다.
 PyCoreImage는 복합 연산과 같이 사용할 수있는 유용한 API를 제공합니다.
 여기에는 번역, 크기 조정, 회전 및 자르기와 같은 기하학적 연산뿐만 아니라 소스 오버가 있습니다.
 괜찮아.
 GPU 커널에서 좀 더 많은 시간을 보내고 싶습니다. 특히 프로 타이핑의 경우 매우 강력한 기능입니다.
 그래서 여기에 GPU 프래그먼트에 대한 코드가 들어있는 문자열이 있습니다.
 그리고 우리가 가진 것은 근본적으로 그 효과가 무엇인지 실시간으로 프로토 타이핑 할 수있는 방법입니다.
 이것은 5 개의 탭 Laplacian의 예이며 우리는 이것을 선명하게하기 위해 사용할 것입니다.
 그래서 각 픽셀의 근처에 5 개의 샘플을 만듭니다.
 우리의 세부 사항이 될 지역 파생 상품을 계산하는 방식으로 이들을 결합하면 중앙 픽셀 위에 온백을 추가 할 수 있습니다.
 필터 자체에 너무 집중하고 싶지는 않지만 필터를 호출하는 방법.
 그래서 CIMG 인스턴스에서 검은 색 커널이라고 부릅니다.
 Bass 소스 코드는 삼중 [비가 취] 파이썬 문자열을 사용하여 위에 앉아있을뿐입니다.
 [들리지 않음] 우리가 커널을 적용 할 범위.
 그리고 관심 영역을 정의하는 것은 우리가 샘플링 할 표현을 따르는 것입니다.
 관심 분야뿐만 아니라 대상 도메인의 개념에 익숙하지 않은 경우 Core Image 및 이전 WWDC 세션에 대한 온라인 설명서를 참조하십시오.
 그러나 여기에 컨볼 루션 커널이 있습니다. 경계에서 한 픽셀 떨어져서 읽으므로 Core Image에 경계 조건을 올바르게 처리 할 수 ​​있도록 지시해야합니다.
 괜찮아.
 그래서 많은 정보와 API를 보면서 항상 마를 것입니다. 따라서 데모를 살펴보고이 모든 것을 실천합시다.
 괜찮아.
 따라서이 데모에서는 브라우저 기반 실시간 파이썬 인터프리터 인 Jupiter Notebook을 사용할 것입니다.
 따라서 여러분이 보게 될 모든 결과는 백엔드에서 Core Image를 사용하여 실시간으로 렌더링됩니다.
 따라서이 중 어느 것도 사전 계산되지 않았습니다. 이 모든 것이 실시간으로 이루어집니다.
 그래서 여기서 가장 먼저해야 할 일은 우리가 사용하려고하는 유틸리티 클래스를 임포트하는 것입니다. 가장 중요한 것은 내 PyCoreImage 패키지를위한 CIMG 클래스입니다.
 그런 다음 실제로는 노트북에서 이미지를 시각화 할 수 있도록 약간의 설정 코드 만 있습니다.
 시작하자.
 먼저 이미지를로드하는 방법을 보여주고 싶습니다.
 따라서 여기에서 파일을 사용하여 내 객체의 유형이 PyCoreImage CIMG임을 알 수 있습니다.
 그리고 우리는 그것이 실제로 적절한 Core Image 객체에 의해 뒷받침된다는 것을 알 수 있습니다.
 우리는 이미지를 렌더링 할 수 있고, 실제로 볼 수 있습니다. Matte [inaudible] lib를 사용하여 픽셀을 표현한 것입니다.
 이것이 우리의 입력 이미지입니다. 이제 필터를 적용하려고합니다. 따라서 Core Image에서 지원되는 200 개의 더하기 필터를 살펴 보겠습니다.
 여기에 GaussianBlur를 적용하는 데 관심이 있다고 가정 해 보겠습니다. 그러면이 필터에서 지원되는 매개 변수를 알고 싶습니다. 따라서 CIMG 클래스의 입력을 호출 할 것이고 입력 이미지를 지원한다는 것을 알 수 있습니다. 입력 반경뿐만 아니라 놀랄 필요도 없습니다.
 그래서 저는 여기서 그것을 할 것입니다.
 내 입력 이미지를 가져 가라.
 반경 100 픽셀의 GaussianBlur 필터를 적용한 다음 두 이미지를 나란히 표시하십시오.

그럼, 꽤 쉽지, 그렇지? 괜찮아.
 계속 가자.
 이전에 언급했듯이 Core Image를 사용하여 절차 이미지를 생성 할 수 있습니다.
 그래서 우리는 코어 이미지 생성기를 살펴볼 것입니다.
 그리고 여기서 우리가하는 일은 발전기에서 호출하는 것입니다 - 발전기의 이름을 지정하십시오.
 이 경우 CIQR 코드를 만들고 인코딩하려는 메시지에 전달합니다.
 여기에 실시간으로 표시되므로 해당 메시지를 변경하고 그 메시지가 생성되는 QR 코드에 어떤 영향을 미치는지 확인할 수 있습니다.
 Core Image는 이미지 라벨 지정을 지원하기 때문에 CI 텍스트 이미지 생성기를 사용하여 이미지를 지정할 수 있습니다.
 여기 예제가 있습니다.
 WWDC 및 SFLO 글꼴 사용
 좋아, 계속 가자.
 언급했듯이, 우리는 NumPy와의 상호 운용성을 지원합니다. 그래서 이것이 우리가 여기서 먼저 할 일입니다.
 우리는 이미지로 시작하여 흥미롭고 사소한 영향을 적용 할 것입니다.
 이 경우 와류 왜곡.
 다음으로해야 할 일은, 버퍼에서 NumPy 영역을 가져 오는 것입니다.
 여기에 그 유형뿐만 아니라 모양, 깊이, 그리고 그것에 대한 몇 가지 통계를 볼 수 있습니다.
 최소값, 중간 값 및 최대 값입니다.
 다른 방법으로 NumPy에서 Core Image로 이동할 수도 있습니다.
 이를 위해 NumPy 배열로 시작해 봅시다. 이는 사소한 일입니다.
 이 경우 임의 값 - 75 %의 값이 검정으로 보이지 않는 임의의 버퍼.
 여기서 내가하는 첫 번째 작업은 NumPy 배열을 CIMG 생성자에 래핑하는 것입니다. 우리는 CIMG 클래스 인스턴스와 CIMming 클래스를 다시 사용할 수 있음을 알 수 있습니다.
 이제는 CIImage가 있으므로 다양한 필터를 적용 할 수 있습니다.
 그래서, 제가하는 첫 번째 일은 제가이 흐림 효과를 적용 할 것입니다.
 나는 와이어 필터를 사용할 것이다. 빛 터널.
 내 이미지의 명암 변화.
 감마값뿐만 아니라 노출 조정.
 이러한 필터를 나란히 살펴 보겠습니다.
 그래서이 흐림, 가벼운 터널, 노출 조정; 감마 조정, 여기에 최종 효과가 있습니다.
 꽤 재미 있고 정말 쉽게 작업 할 수 있습니다.
 그래서 우리는 그것을 모두 정리해 봅시다.
 이제 여기서 새로운 이미지로 시작하겠습니다.이 데모에서 보여줄 내용은 어떻게 벤드 프로세싱을 할 수 있는가입니다.
 파이썬에서 이미지를 잘라내는 것으로 여기에있는 사람들을 위해, 이것이 바로 우리가하려고하는 것입니다.
 이미지의 가로 분할 영역 인 밴드 또는 슬라이스를 정의하고 필터 만 적용 할 것입니다.
 먼저 코드를 살펴 보겠습니다.
 여기에 밴드 추가 기능이 있습니다.
 그리고 우리는 그 밑바닥이 실제 NumPy 버퍼 인 두 개의 합성물로 이미지를 렌더링한다는 것을 알 수 있습니다.
 그러나 오른쪽은 CII 이미지입니다.
 이와 같이 슬라이싱을 사용함으로써 코어 이미지가 전체 이미지가 아닌 해당 밴드에서 렌더링을 수행하도록함으로써 훨씬 더 뛰어난 결과를 얻게되었습니다.
 자,이 작업을하고 이미지에 다섯 가지 다른 밴드를 만들고 최종 합성물을 보여 드리겠습니다.
 꽤 놀라워.
 그리고 우리는 상단에 다른 레이블을 붙였습니다. 적용되는 필터에 해당합니다.
 PyCoreImage로 작업하는 것이 정말 간단합니다.
 괜찮아.
 그리고 이전에 성능에 대해 언급 했으므로이를 간단히 살펴 보겠습니다.
 먼저 CIImage 인스턴스에서 렌더링을 호출 할 때마다 NumPy가 구워지고 후드 아래에 캐시됩니다.
 예를 들어 여기에서는 GaussianBlur와 마찬가지로 축소 된 이미지를 만들었으므로 첫 번째 호출에는 56 밀리 초가 걸렸습니다. 두 번째 것은 단지 2 밀리 초입니다.
 큰 회선을 살펴 봅시다.
 Core Image는 매우 빠르며 마치 큰 것처럼 복잡한 컨볼 루션을 처리 할 수 ​​있습니다.
 여기서 우리는 시그마에 대해 200의 시그니처를 갖는 CIBlur, 즉 반경이 200 인 CIGaussianBlur를 사용합니다.
 내가보기에 당신에게 이미지를 보여 주면서 여기에 감각을주기 위해서, 저는 실제로 scikit 이미지를 사용하여 동등 물을 실행하고 있습니다.
 그리고 우리는 16 초의 러닝 타임을 보냈습니다.
 그러나 이번에는 CoreImage를 사용하는 동일한 작업; 130 밀리 초.
 그래, 그게 빠르 네 [박수] - 200X 예.
 고맙습니다.
 좋아, 계속 가자.
 따라서 PyCoreImage의 가장 강력한 기능 중 하나는 맞춤형 GP 커널을 인라인으로 만들고 즉시 실행하고 즉시 수정하는 기능입니다.
 자, 이제 살펴 보겠습니다.
 괜찮아.
 그래서, 내가 보여주고 싶은 첫 번째 것은 컬러 커널을 사용하는 방법입니다.
 따라서 색상 커널은 픽셀을 가져 와서 픽셀을 침을 튀기는 커널이며 그 픽셀 주위에 다른 샘플을 만들지 않습니다.
 여기에 우리의 입력 이미지가 있습니다. 여기에 우리의 커널이 있습니다.
 그래서 우리가 실제로 들어가는 것은 색깔이며 우리는 색깔을 바꿉니다.
 여기에서이 효과를 살펴 보겠습니다.
 나는 붉은 색과 붉은 색 채널을 청색과 적색 채널로 바꿀 것이며, 우리는 그것을 반전시킬 것입니다.
 대단히 흥미 진진한 효과는 아니지만 내가 보여 주려는 것은 내가 할 일을하고, 타이핑을 시작하고, 말하자면, 내 빨간 채널을 내 푸른 채널로 확장하려는 것일 수 있습니다. scaling 나는 여기서 놀고있어, 우리는 갈 수있다.

그럼, 꽤 쉽지, 그렇지? 괜찮아.
 계속 가자.
 이전에 언급했듯이 Core Image를 사용하여 절차 이미지를 생성 할 수 있습니다.
 그래서 우리는 코어 이미지 생성기를 살펴볼 것입니다.
 그리고 여기서 우리가하는 일은 발전기에서 호출하는 것입니다 - 발전기의 이름을 지정하십시오.
 이 경우 CIQR 코드를 만들고 인코딩하려는 메시지에 전달합니다.
 여기에 실시간으로 표시되므로 해당 메시지를 변경하고 그 메시지가 생성되는 QR 코드에 어떤 영향을 미치는지 확인할 수 있습니다.
 Core Image는 이미지 라벨 지정을 지원하기 때문에 CI 텍스트 이미지 생성기를 사용하여 이미지를 지정할 수 있습니다.
 여기 예제가 있습니다.
 WWDC 및 SFLO 글꼴 사용
 좋아, 계속 가자.
 언급했듯이, 우리는 NumPy와의 상호 운용성을 지원합니다. 그래서 이것이 우리가 여기서 먼저 할 일입니다.
 우리는 이미지로 시작하여 흥미롭고 사소한 영향을 적용 할 것입니다.
 이 경우 와류 왜곡.
 다음으로해야 할 일은, 버퍼에서 NumPy 영역을 가져 오는 것입니다.
 여기에 그 유형뿐만 아니라 모양, 깊이, 그리고 그것에 대한 몇 가지 통계를 볼 수 있습니다.
 최소값, 중간 값 및 최대 값입니다.
 다른 방법으로 NumPy에서 Core Image로 이동할 수도 있습니다.
 이를 위해 NumPy 배열로 시작해 봅시다. 이는 사소한 일입니다.
 이 경우 임의 값 - 75 %의 값이 검정으로 보이지 않는 임의의 버퍼.
 여기서 내가하는 첫 번째 작업은 NumPy 배열을 CIMG 생성자에 래핑하는 것입니다. 우리는 CIMG 클래스 인스턴스와 CIMming 클래스를 다시 사용할 수 있음을 알 수 있습니다.
 이제는 CIImage가 있으므로 다양한 필터를 적용 할 수 있습니다.
 그래서, 제가하는 첫 번째 일은 제가이 흐림 효과를 적용 할 것입니다.
 나는 와이어 필터를 사용할 것이다. 빛 터널.
 내 이미지의 명암 변화.
 감마값뿐만 아니라 노출 조정.
 이러한 필터를 나란히 살펴 보겠습니다.
 그래서이 흐림, 가벼운 터널, 노출 조정; 감마 조정, 여기에 최종 효과가 있습니다.
 꽤 재미 있고 정말 쉽게 작업 할 수 있습니다.
 그래서 우리는 그것을 모두 정리해 봅시다.
 이제 여기서 새로운 이미지로 시작하겠습니다.이 데모에서 보여줄 내용은 어떻게 벤드 프로세싱을 할 수 있는가입니다.
 파이썬에서 이미지를 잘라내는 것으로 여기에있는 사람들을 위해, 이것이 바로 우리가하려고하는 것입니다.
 이미지의 가로 분할 영역 인 밴드 또는 슬라이스를 정의하고 필터 만 적용 할 것입니다.
 먼저 코드를 살펴 보겠습니다.
 여기에 밴드 추가 기능이 있습니다.
 그리고 우리는 그 밑바닥이 실제 NumPy 버퍼 인 두 개의 합성물로 이미지를 렌더링한다는 것을 알 수 있습니다.
 그러나 오른쪽은 CII 이미지입니다.
 이와 같이 슬라이싱을 사용함으로써 코어 이미지가 전체 이미지가 아닌 해당 밴드에서 렌더링을 수행하도록함으로써 훨씬 더 뛰어난 결과를 얻게되었습니다.
 자,이 작업을하고 이미지에 다섯 가지 다른 밴드를 만들고 최종 합성물을 보여 드리겠습니다.
 꽤 놀라워.
 그리고 우리는 상단에 다른 레이블을 붙였습니다. 적용되는 필터에 해당합니다.
 PyCoreImage로 작업하는 것이 정말 간단합니다.
 괜찮아.
 그리고 이전에 성능에 대해 언급 했으므로이를 간단히 살펴 보겠습니다.
 먼저 CIImage 인스턴스에서 렌더링을 호출 할 때마다 NumPy가 구워지고 후드 아래에 캐시됩니다.
 예를 들어 여기에서는 GaussianBlur와 마찬가지로 축소 된 이미지를 만들었으므로 첫 번째 호출에는 56 밀리 초가 걸렸습니다. 두 번째 것은 단지 2 밀리 초입니다.
 큰 회선을 살펴 봅시다.
 Core Image는 매우 빠르며 마치 큰 것처럼 복잡한 컨볼 루션을 처리 할 수 ​​있습니다.
 여기서 우리는 시그마에 대해 200의 시그니처를 갖는 CIBlur, 즉 반경이 200 인 CIGaussianBlur를 사용합니다.
 내가보기에 당신에게 이미지를 보여 주면서 여기에 감각을주기 위해서, 저는 실제로 scikit 이미지를 사용하여 동등 물을 실행하고 있습니다.
 그리고 우리는 16 초의 러닝 타임을 보냈습니다.
 그러나 이번에는 CoreImage를 사용하는 동일한 작업; 130 밀리 초.
 그래, 그게 빠르 네 [박수] - 200X 예.
 고맙습니다.
 좋아, 계속 가자.
 따라서 PyCoreImage의 가장 강력한 기능 중 하나는 맞춤형 GP 커널을 인라인으로 만들고 즉시 실행하고 즉시 수정하는 기능입니다.
 자, 이제 살펴 보겠습니다.
 괜찮아.
 그래서, 내가 보여주고 싶은 첫 번째 것은 컬러 커널을 사용하는 방법입니다.
 따라서 색상 커널은 픽셀을 가져 와서 픽셀을 침을 튀기는 커널이며 그 픽셀 주위에 다른 샘플을 만들지 않습니다.
 여기에 우리의 입력 이미지가 있습니다. 여기에 우리의 커널이 있습니다.
 그래서 우리가 실제로 들어가는 것은 색깔이며 우리는 색깔을 바꿉니다.
 여기에서이 효과를 살펴 보겠습니다.
 나는 붉은 색과 붉은 색 채널을 청색과 적색 채널로 바꿀 것이며, 우리는 그것을 반전시킬 것입니다.
 대단히 흥미 진진한 효과는 아니지만 내가 보여 주려는 것은 내가 할 일을하고, 타이핑을 시작하고, 말하자면, 내 빨간 채널을 내 푸른 채널로 확장하려는 것일 수 있습니다. scaling 나는 여기서 놀고있어, 우리는 갈 수있다.


대단히 흥미 진진한 효과는 아니지만 내가 보여 주려는 것은 내가 할 일을하고, 타이핑을 시작하고, 말하자면, 내 빨간 채널을 내 푸른 채널로 확장하려는 것일 수 있습니다. 스케일링 여기에서 연주하고 있습니다. 그래서 우리가 원한다면 .25에서 꽤 높은 값으로 갈 수 있습니다. 여기서 흥미로운 효과를 생성 할 수 있습니다.
 매우 강력하며이 모든 것이 들리지 않으므로 필터를이 방법으로 미세 조정할 수 있으며 원하는 효과를 얻을 수 있습니다.
 좀 더 복잡한 커널을 보도록하겠습니다.
 그래서 우리는 앞에서 보았던 [들리지 않음]과 같은 일반적인 커널을 보게 될 것입니다. 커널은 각 픽셀의 인접 부분에서 추가 탭을 만듭니다.
 그래서 우리가 이전에 보았던 것과 같은 이미지 인 파일로부터 시작하여 우리는 여기에 커널 코드를 가지고 있습니다.
 디테일에 들어가지 않고, 이것은 블라스팅 필터보다 한층 더 강조되는 양측 필터입니다.
 그래서 코드를 넣고, 아주 좋은 효과를 얻을 수있는 매개 변수와 함께 적용 커널을 사용합시다.
 그리고 우리가 여기에서 한 것은 본질적으로 이미지의 비 중복 고주파수를 클리핑 한 것입니다.
 그리고 우리가 살펴 본다면 좀 더 자세히 살펴 보도록하겠습니다.
 여기 작물 좀 봐.
 우리는 강한 모서리가 어떻게 여전히 존재 하는지를 볼 수 있지만, 중복되지 않는 좋은 주파수들은 사라져 버렸습니다.
 그리고 양면 필터는 많은 다른 목적으로 사용될 수 있습니다.
 이 특별한 경우, 우리는 그것을 사용하여 선명하게합니다.
 그리고이 필터를 사용하여 선명하게하기 위해 왼쪽의 이미지를 가져 와서 오른쪽의 이미지를 빼내어 고주파 또는 이미지의 세부적인지도를 제공 할 수 있습니다.
 그냥 해보 죠.
 그래서, 여기서 제가하고있는 일은 제가 이미지를 렌더링하는 것입니다, 그것은 NumPy 버퍼입니다.
 내 필터링 된 이미지를 렌더링하고 우리는 NumPy와 함께 제공되는 연산자 오버로딩을 사용하여 이들을 뺍니다.
 세부 레이어를 살펴 보겠습니다.
 따라서 전체 이미지의 경우 왼쪽에 세부 정보가 있고 이미지의 가운데에 자르기가있는 경우
 이제 우리가 할 수있는 것은 원본 이미지 위에 추가 할 수 있다는 것입니다.
 우리는 여기서 그것을 할 것입니다.
 우리는 그것을 두 번 추가 할 것입니다.
 이렇게함으로써, 우리는 형성 된 샤프닝을 달성합니다.
 정말 간단합니다.
 원한다면 필자는 필자의 필터 커널 문자열로 되돌아 가서 해킹을 시작하고 실시간으로 변경 작업을 시작할 수 있습니다.
 내가 보여주고 싶은 또 다른 점은 이미지에서 메타 데이터를로드하는 방법입니다.
 그래서, 여기에 세로 효과 매트뿐만 아니라 세로 깊이 데이터가있는 이미지가 있습니다.
 여기에 이미지가 나란히 있습니다.
 왼쪽 이미지는 RGB 이미지입니다.
 가운데에는 깊이 데이터가 있습니다.
 오른쪽에는 고품질 인물 효과 맵이 있습니다.이지도는 오늘 다른 세션에서 소개되었습니다.
 또한 CIMG 인스턴스 및 호출 속성에서 기본 CIImage를보고 직접 존재하는 태그를 볼 수도 있습니다.
 여기서 우리는 실제 캡처 자체에 관한 정보를 얻습니다.
 제가 말씀 드렸듯이, 우리는 다른 세션에서 초상화 효과 매트를 소개합니다, 세션 503, 그래서 당신이 그것을 보길 강력히 권합니다.
 여기에 세부 사항을 설명하지 않고이 필터를 선택할 것입니다.
 우리가 어떻게했는지 알고 싶다면이 세션을 살펴 보는 것이 좋습니다.
 꽤 재미있는 것들 [박수].
 고맙습니다.
 괜찮아.
 다시 프레젠테이션으로 돌아가겠습니다.
 여기에 장비를 조금씩 바꾸고 CoreImage와 CoreML을 함께 사용하겠습니다.
 Portrait Matte 및 Portrait Depth 정보 작업에 대한 자세한 정보를 얻으려면 사진 및 비디오 효과 만들기에 대한 세션을 참조하십시오. [들리지 않음]
 괜찮아.
 Core Image와 CoreML을 함께 가져와 봅시다.
 올해 우리는 새로운 필터 인 CI CoreML 모델 필터를 제안한다는 사실을 발표하게 된 것을 대단히 기쁘게 생각합니다.
 이것은 매우 간단하면서도 강력한 필터로서 두 개의 입력을 필요로합니다.
 첫 번째 입력은 필터와 입력 CoreML 모델을 가진 이미지 자체이며, 기본 뉴런 네트워크를 통해 실행 된 출력을 얻습니다.
 정말 간단합니다. 매우 강력합니다.
 코드가 얼마나 간단한 지 보여주기 위해 Swift를 살펴 보겠습니다.
 왼쪽에 입력 이미지가 있습니다. 필터 적용을 호출하면됩니다.
 그러나 우리가 입력 한 새로운 필터가 올해 소개되어 모델에 [들리지 않음]을 제공합니다.
 정말 간단합니다.
 그리고 이미지 프로세싱 어플리케이션에서 기계 학습을 활용하는 다른 방법을보고 싶다면 Turis Guide to CoreML과 함께 Vision의 다른 세션을 살펴 보시기 바랍니다.
 괜찮아.
 관련 주제에 대해서는 기계 학습에서 교육 데이터 세트에서 수행하는 일반적인 작업 중 하나가 데이터 증가입니다.
 데이터 증가로 인해 신경 네트워크의 견고성이 크게 향상 될 수 있습니다.

이 특별한 경우에, 우리가 물체 분류를하고 있고 그 이미지가 다리인지 물이 있는지를 결정하려고한다고 가정 해 봅시다.
 따라서 원래의 추세 데이터 집합에 기능을 추가하면 새 이미지를 수집 할 필요없이 해당 데이터 집합에 포함 된 이미지의 수가 증가합니다.
 당신은 본질적으로 그것들을 무료로 얻습니다.
 따라서 많은 작업을 수행 할 수 있습니다.
 그 중 하나는 외관을 바꾸는 것입니다.
 예를 들어, 이미지의 시제, 온도 및 흰색 점.
 노이즈를 추가하여 이미지의 스펙트럼 특성을 변경합니다.
 또는 변형을 적용하여 이미지의 기하학적 모양을 변경합니다.
 글쎄요, 이것들은 모두 코어 이미지를 사용하는 것이 쉽지 않은 것으로 밝혀졌습니다.
 몇 가지 필터를 살펴보고 데이터 확대 용도로 사용할 수있는 방법을 살펴 보겠습니다.
 여기에 입력 이미지가 왼쪽에 있습니다.
 CI 온도와 색조를 사용하여 온도와 색조를 변경할 수 있습니다.
 CI 색상 컨트롤을 사용하여 이미지의 밝기, 대비 및 채도를 조정할 수 있습니다.
 CI 디더뿐만 아니라 CI GaussianBlur를 사용하여 이미지의 주파수 스펙트럼을 변경하십시오.
 그리고 아핀 변환을 사용하여 이미지의 기하학을 변경하십시오.
 실제로이 모든 것을 살펴 보겠습니다.
 괜찮아.
 그래서 우리는 목성 노트북으로 돌아 왔습니다.
 이전과 같은 설정.
 먼저 핵심 이미지를 사용하여 보완하는 방법을 보여 드리겠습니다.
 이제 이미지를로드하고 여기에 기능 보강 기능을 정의 할 것입니다.
 그리고 여기서 기본적으로 수행 할 작업은 여기에 정의 된 각 필터의 ​​임의의 공간에서 샘플링하는 것입니다.
 그래서 우리는 GaussianBlur를 적용 할 것입니다. 회전을 조절하고, 피사체를 조절하고, 노이즈를 디더링하는 몇 가지 조정 방법 - 노출 조절 -을 적용 할 것입니다.
 괜찮아? 그 기능을 캐쉬하고 그 기능을 몇 가지 실현시켜 봅시다.
 그래서 여기에있는 나의 슬라이더는 내가 백 엔드에서 사용하고있는 [들리지 않음]을 제어합니다.
 좋아, 꽤 근사해.
 얼마나 효율적인 지 확신 할 수 없으므로 여기에서 실시간으로 200 개의 추가 기능을 처리 할 것입니다. 여기에서 살펴 보겠습니다 - 실제로 어떻게 진행되고 있습니까? 실제로 실시간으로 디스크에 저장됩니다 .
 그러니 그냥 해보 죠, 얼마나 빠를 지에 대한 감각을주기 위해서입니다.
 정말 강력합니다.
 괜찮아.
 코어 이미지를 사용하여 CoreML을 사용하는 방법을 보여 드리겠습니다.
 먼저 코어 ML 모델을로드해야합니다. 여기에서 수행했습니다.
 우리는 흥미로운 효과를 내기 위해 사용할 유리 모델을 가지고 있습니다.
 먼저 절차 적 이미지부터 살펴 보겠습니다.
 우리는 전에 이것을 보았습니다.
 그리고 좀 더 재미있게하기 위해 텍스처를 추가 할 것입니다.
 그래서 우리는 멀티 밴드 노이즈를 추가 할뿐만 아니라 페더 링과 일부는들을 수 있습니다.
 좋습니다, 이것이 우리가 신경망에 공급할 입력 이미지입니다 - 우리가 미리 훈련 한 CoreML 모델.
 괜찮아? 자, 이걸 실행합시다.
 그리고 너 거기 간다.
 WWDC 2018, 당신만을위한 것입니다.
 괜찮아.
 그 메모에 오늘이 세션에 참석해 주셔서 감사드립니다.
 이 슬라이드를 준비하는 동안 즐거웠기를 바랍니다.
 내일 3시에 Core Image Technical Lab에서와 주셔서 대단히 감사드립니다. 감사합니다.
