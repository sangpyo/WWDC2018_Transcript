안녕 모두.
 세션 221, TextKit 모범 사례에 오신 것을 환영합니다.
 나는 도나 톰이야.
 그리고 저는 TextKit 엔지니어입니다.
 그리고 저의 동료 인 Emily Van Haren이 저와 함께합니다.
 또한 우리는 TextKit을 사용하기위한 몇 가지 모범 사례를 여러분과 공유하게되어 매우 기쁩니다.
 시작하겠습니다.
 먼저 TextKit 작업의 주요 개념을 살펴 보겠습니다.
 그런 다음 몇 가지 예를 들어 앱의 핵심 개념을 적용하는 방법을 설명합니다.
 마지막으로 정확성, 성능 및 보안 분야에 대한 모범 사례를 마무리하겠습니다.
 먼저 주요 개념부터 살펴 보겠습니다.
 이제 우리가 같은 페이지에 있는지 확인하기 위해 처음부터 시작할 것입니다.
 TextKit은 무엇입니까? 그리고 첫 번째 본능은 Xcode에서 반짝이는 새로운 놀이터를 열어서 import TextKit을 입력하는 것일 수도 있습니다. 실제로 이것을 시도한 경우를 제외하고는 작동하지 않는 것으로 나타났습니다.
 TextKit은 사용했던 다른 프레임 워크와 약간 다릅니다.
 그것을 사용하기 위해 특별한 것을 가져올 필요는 없습니다.
 UIKit 및 AppKit의 텍스트 컨트롤은 TextKit 위에 구축됩니다.
 그리고 레이블, 텍스트 필드 또는 텍스트보기를 사용한 적이 있다면 실제로 TextKit을 사용했습니다.
 TextKit은 Core Text, Core Graphics 및 Foundation과 같은 강력한 기본 기술을 결합하여 응용 프로그램에서 텍스트를 쉽고 원활하게 보여줍니다.
 이러한 기본 제공 컨트롤 중 하나를 사용할 때마다 TextKit을 사용하여 이러한 기본 기술을 직접 사용하거나 복잡한 스크립트의 복잡성을 이해하지 않고도 완벽하게 국제화되고 지역화 할 수있는 방식으로 텍스트를 표시하거나 편집 할 수 있습니다.
 그리고 여기에있는 모든 디스플레이 기능과 마찬가지로 무료로 얻을 수있는 많은 것들이 있습니다.
 또한 편집을 위해 액세스 가능성, 맞춤법 검사 등 OS에서 지원하는 모든 기술 서비스에 액세스 할 수 있습니다.
 그리고 한 줄의 코드를 작성하지 않고도 위의 모든 기능을 활용할 수 있습니다.
 따라서이 모든 기능을 손쉽게 사용할 수 있으므로 사용하려는 컨트롤을 어떻게 결정합니까? 그래서 당신의 상황에 맞는 컨트롤을 선택하는 것에 대해 이야기 해 봅시다.
 그리고 옵션은 UIKit 또는 AppKit 중 어느 것을 사용하는지에 따라 조금씩 다릅니다.
 그럼 개별적으로 검토해 보겠습니다.
 괜찮아.
 UIKit부터 시작하겠습니다.
 먼저 텍스트 입력이 필요한지 여부를 고려해야합니다.
 텍스트 입력이 필요하지 않은 경우 선택 또는 스크롤이 필요한지 고려하십시오.
 그리고 이들이 필요 없다면 UILabel을 사용해야합니다.
 UILabels는 몇 마디 또는 몇 줄과 같이 소량의 텍스트를 대상으로합니다.
 그리고 만약 당신이 텍스트보다 더 많은 텍스트를 가지고 있거나 이러한 선택이나 스크롤링 기능이 필요하다면, UITextView를 편집이 불가능하게 사용해야합니다.
 이제 위로 가기.
 텍스트 입력이 필요한 경우 보안 텍스트 입력이 필요한지 여부를 고려하십시오.
 그리고 이것은 텍스트가 가려져 있고 복사가 불가능한 암호 필드와 같습니다.
 그래서 필요한 경우 보안 텍스트 입력을 지원하는 유일한 컨트롤이기 때문에 UITextField를 사용하십시오.
 그렇지 않으면 입력 할 텍스트의 양을 생각해보십시오.
 그리고 라인이 필요한 형식 필드 입력과 같은 것을 원하면 UITextField를 사용하십시오.
 그리고 UITextField는 한 줄의 텍스트 입력 만 지원합니다.
 그렇지 않으면 그 이상이 필요하면 UITextView를 사용할 수 있습니다.
 이제는 AppKit에 대한 동일한 의사 결정 프로세스가 있습니다.
 UIKit 프로세스와 비슷하지만 약간의 차이점이 있습니다.
 다시 말하지만, 텍스트 입력이 필요한지 여부를 고려하여 시작할 것입니다.
 AppKit에는 라벨 컨트롤이 없습니다.
 따라서 텍스트를 표시해야하는 경우 NSTextField를 사용하고 편집 및 선택을 모두 해제하여 해당 레이블 동작을 가져올 수 있습니다.
 이제 다시 여기로 돌아가십시오.
 텍스트 입력이 필요한 경우 보안 텍스트 입력이 필요한지 다시 한 번 확인하십시오.
 그렇다면 NSSecureTextField를 사용할 수 있습니다.
 그렇지 않으면 우리가 가장 좋아하는 질문을 할 것입니다. 얼마나 많은 텍스트를 기대합니까? 따라서 NSTextView는 많은 양의 텍스트로 성능에 최적화되어 있습니다.
 많은 텍스트가 필요하다면 NSTextView를 사용해야합니다. 그렇지 않으면 NSTextField를 사용할 수 있습니다.
 이제는 UIKit과 달리 NSTextField는 여러 줄의 텍스트를 지원하지만 더 짧은 문자열에 대해서는 여전히 최적화되어 있으므로 많은 텍스트가있는 경우 NSTextView를 사용해야합니다.
 TextKit을 사용하여 블록을 몇 번 돌 봤던 사람들은 흐름 차트에 옵션이없고 문자가 문자열임을 알 수 있습니다.
 그리고 드로잉 포인트를 직접 호출하여 문자열 드로잉을 사용하거나 NSString 또는 NSAttributedString 아래 rect 메서드를 그립니다.
 그리고 많은 사람들이 키트 레벨에서 뷰 객체의 오버 헤드를 피하기 위해 성능 이점을 위해 이것을 사용할 수도 있습니다.
 따라서이 길로 가려면 다음 사항을 명심하십시오.
 소량의 정적 텍스트에 사용하고 싶습니다.

그리기 방법을 호출하는 빈도를 제한하려고합니다.
 이제 문자열 그리기 메서드를 많이 호출하는 경우 레이블 또는 텍스트 필드에서 더 나은 성능을 얻을 수 있습니다. 이러한 컨트롤은 특히 자동 레이아웃을 사용하는 경우보다 나은 캐싱을 제공하기 때문입니다.
 또한 사용자 정의 속성이 많은 속성 문자열을 그리는 경우 텍스트 시스템이 렌더링 전에 모든 속성의 유효성을 검사해야하므로 최상의 성능을 얻으려면 추가 속성을 제거해야하므로 문자열 드로잉 속도가 느려질 수 있습니다 그리기 전에 글꼴이나 같은 색상과 같은 시각적 모양을 결정하는 데 필요한 것들만 전달합니다.
 마지막으로 문자열 그리기를 사용하면 텍스트 컨트롤에서 제공하는 모든 무료 기능을 놓칠 수 있으므로 가능한 경우 텍스트 컨트롤을 사용해야합니다.
 이제는 내장 컨트롤을 사용하여 TextKit으로 무엇을 할 수 있는지 알았습니다.
 그러나 이러한 컨트롤이 제공하는 범위를 넘어서려면 텍스트 스택 내에서 올바른 사용자 지정 지점을 찾아야합니다.
 TextKit은 코코아와 마찬가지로 모델 뷰 컨트롤러 디자인 패턴을 기반으로합니다.
 그리고 텍스트 시스템은 NBC에 직접적으로 대응하는 3 가지 단계, 즉 저장, 표시 및 레이아웃으로 나눌 수 있습니다.
 이제 각각의 단계를 구성하는 TextKit 객체를 자세히 살펴 보겠습니다.
 그리고 모델에 해당하는 스토리지부터 시작하겠습니다.
 이제 NSTextStorage는 문자열 데이터와 속성을 보유합니다.
 이것은 가변 속성 문자열의 서브 클래스이므로 속성 문자열과 함께 작업하는 방법을 이미 알고있는 것과 같은 방법으로 작업 할 수 있습니다.
 그리고 제 동료 인 Emily는 텍스트 저장 장치를 약간 나중에 사용자 정의하는 정말 강력한 방법을 보여 드릴 것입니다.
 이제 NSTextContainer는 텍스트가 배치 될 영역의 기하학을 모델링합니다.
 기본적으로 직사각형이지만 여기에 표시된대로 텍스트 레이아웃의 흐름이나 모양을 사용자 정의 할 수 있습니다.
 스토리지 오브젝트 작업에 대한 자세한 내용은 위의 WWDC 세션 및 문서를 확인하십시오.
 그리고 그들은 세션이 끝나면 더 많은 정보 링크에서 얻을 수 있습니다.
 다음은 디스플레이 단계이며보기에 해당합니다.
 그리고 우리는 적절한 컨트롤을 선택하는 것에 대해 이야기했을 때 이미 디스플레이 단계에 대해 이야기했습니다.
 추가 정보를 얻으려면이 문서 리소스를 다시 확인하십시오.
 세션이 끝나면 더 많은 정보 링크를 통해 액세스 할 수 있습니다.
 마지막으로 컨트롤러에 해당하는 레이아웃 단계가 있습니다.
 NSLayoutManager는이 단계의 유일한 구성 요소입니다.
 그리고 그것이 짐승이라고 말해 줄께.
 그리고 그것이 의미하는 바가 너무 굉장하기 때문에 좋은 방법으로 말입니다.
 따라서 전체 작동의 두뇌입니다.
 모든 단계의 변경 사항을 조정하고 레이아웃 프로세스 자체를 제어합니다.
 레이아웃 프로세스가 어떻게 작동하는지에 대한 간단한 개요가 있습니다.
 따라서 텍스트 레이아웃은 시스템이 텍스트 저장소의 속성을 수정하여 문자열의 모든 문자가 해당 문자 표시를 지원하는 글꼴로 덮여 있는지 확인하는 등의 불일치를 제거한 후에 발생합니다.
 이 예에서는 Times New Roman 글꼴이 전체 문자열에 대해 지정되었지만이 글꼴은 일본어 한자 또는 그림 이모티콘을 표시하지 않습니다.
 그리고 속성을 수정 한 후에는 일본어 문자에 지정된 적절한 일본어 글꼴과 이모티콘 문자에 지정된 이모티콘 글꼴로 텍스트 저장소가 이와 유사하게 보입니다.
 괜찮아.
 따라서 속성이 고정되면 레이아웃 프로세스를 시작할 수 있습니다.
 그리고 우리는 두 단계로 레이아웃을 생각할 수 있습니다 : 글리프 생성과 글리프 레이아웃.
 일단 배치되면 디스플레이 준비가 완료됩니다.
 그러나 잠깐.
 문양이란 무엇입니까? 백업하고 검토해 보겠습니다.
 글리프는 하나 이상의 문자를 시각적으로 표현한 것입니다.
 여기에서 볼 수 있듯이 문자와 글리프 사이의 매핑은 항상 일대일이 아닙니다.
 그래서 여기에이 문자열 ffi에는 세 개의 문자가 있지만 합자에 대한 단일 글리프로 나타낼 수 있습니다.
 그리고 다른 방향으로 갈 수도 있습니다.
 여기서 우리는 여러 개의 글리프로 표현 될 수있는 단일 문자 인 n [inaudible]을 가지고 있습니다. 하나는 n, 하나는 물결표입니다.
 여기에 우리의 다이어그램으로 돌아 가면, NSLayoutManager는 글리프 생성과 글리프 레이아웃을 수행합니다.
 글리프 생성은 레이아웃 관리자가 문자를 가져 와서 그립을 그릴 필요가있는 문자를 파악하는 곳입니다.
 그리핀 레이아웃은 레이아웃 관리자가보기에 표시 할 글리프를 배치하는 위치입니다.
 그리고이 과거의 WWDC 세션과 문서에서 레이아웃 관리자에 대해 배울 점이 많습니다.
 그리고 세션이 끝날 때 더 많은 정보 링크를 통해 추측하여 액세스 할 수 있습니다.
 괜찮아.
 이제 텍스트 시스템의 단계를 이해합니다.
 또한 각 단계를 구성하는 TextKit 구성 요소를 알고 있습니다.

이제는 이러한 구성 요소의 올바른 구성을 선택하여 다양한 효과를 만들어 보겠습니다.
 이것이 표준 구성입니다.
 인터페이스 빌더에서 텍스트보기를 끌어다 놓으면 여기에 표시된대로 각 구성 요소 중 하나가 자동으로 표시됩니다.
 그리고 대부분은 이것이 당신이 필요로하는 모든 것입니다.
 여러 페이지 또는 여러 열 레이아웃이 필요한 경우 각 페이지 또는 열에 한 쌍씩 텍스트 컨테이너 및 텍스트보기 쌍을 사용할 수 있습니다.
 그리고 이들을 모두 동일한 텍스트 저장소에있는 동일한 레이아웃 관리자에 연결하여 보조 저장소의 레이아웃 정보를 공유 할 수 있습니다.
 그리고 각기 다른 레이아웃을 원하면 여러 레이아웃 관리자를 사용하면됩니다.
 텍스트는 동일한 배킹 스토어를 공유하므로 텍스트를 업데이트하면 모든 뷰가 업데이트됩니다.
 이제는 이미 완료된 위대한 세션이 있기 때문에 이러한 구성에 대해 너무 자세히 설명하지 않았습니다. WWDC 2010 세션 고급 코코아 텍스트 팁 및 트릭을 확인하십시오.
 그리고 세션의 끝에서 더 많은 정보 링크를 통해 접근 할 수 있습니다.
 괜찮아.
 그래서 우리는 내장 된 텍스트 컨트롤을 살펴 보았습니다.
 TextKit의 구성 요소를 살펴 보았습니다.
 다양한 효과를 내기 위해 이러한 구성 요소를 구성하는 방법을 살펴 보았습니다.
 이미 그 지식으로 할 수있는 일이 많지만 더 많이 필요한 경우 TextKit의 일부를 직접 확장하고 사용자 정의해야합니다.
 이제는이를 수행하기위한 올바른 접근 방법을 선택하는 것에 대해 조금 이야기하겠습니다.
 올바른 방법을 선택하는 것은 텍스트 도구 상자를 구축하는 것과 같습니다.
 망치가 필요하기 때문에 가게에가는 것과 같습니다.
 그리고 당신이 거기에 도착하면, 당신은 선택할 수있는이 거대한 망치 벽을 만나게됩니다.
 그리고 당신은 일을 할 수있는 망치를 골라야하고 당신이 필요로하는 것을 할 수있는 가장 저렴한 사람을 이상적으로 골라야합니다.
 그리고 이것들은 우리에게 사용 가능한 망치입니다.
 위임은 끝 부분에 손톱이있는 표준 망치와 같으며 여러 작업을 수행하는 데 사용됩니다.
 따라서 대표단은 서로 다른 커스터마이징 후크를 많이 가지고 있으며 대부분의 경우 사용자가 작업을 완료하게됩니다.
 알림은 볼펜 망치와 같습니다.
 그리고 이것은 클로 (claw) 대신에 끝 부분에 볼을 가지고 있기 때문에 좀 더 전문적이며 특정 작업에 더 적합합니다.하지만 표준 망치 위임과 같이 다용도가 아닙니다.
 그리고 마지막으로 서브 클래 싱은 당신의 큰 허물입니다.
 슬레지 해머는 매우 강력하며 망치가 필요한 모든 것에 대해 사용할 수 있습니다. 그러나 많은 일들에 대해 과잉 공격 일 수 있습니다.
 그리고 그걸로 에밀리를 초대하여 여러 종류의 망치를 사용하는 방법을 보여 주려고합니다.
 에밀리.
  고마워요, 도나.
 따라서 개발자로서 선택할 수있는 컨트롤 모음, 다양한 구성 및 필요한 사용자 정의 옵션을 제공합니다.
 그래서 우리 도구 상자는 가득 차 있지만, 선택할 도구를 어떻게 알 수 있습니까? 이제 TextKit의 힘을 활용하는 앱의 몇 가지 예를 살펴 보겠습니다.
 그리고 우리가 사용하는 거의 모든 앱이 텍스트를 표시하거나 편집하기 때문에 아주 멀리 볼 필요가 없습니다.
 우리는 모두 익숙한 두 가지 응용 프로그램을 살펴보고 먼저 자신 만의 응용 프로그램을 만드는 단계를 밟을 것입니다.
 그래서 우리가 살펴볼 첫 번째 앱은 iOS의 Apple News입니다.이 앱은 개인화되고 선정 된 기사에 텍스트를 표시하는 아름다운 앱입니다.
 여기 스포트라이트 탭에 실린 기사의 예가 있습니다.
 이제 앱의 상단에이 기사에 대한 세부 정보가 표시됩니다.
 이제 TextKit을 사용하여이 룩앤필을 다시 만들 수 있습니까? 이제 Donna가이 예제에 가장 적합한 컨트롤을 선택하기 위해 앞서 보여준 흐름도를 고려해 보겠습니다.
 따라서 우리는 선택할 수있는 텍스트 컨트롤을 몇 개 가지고 있습니다. 그러나 한 줄에 소량의 텍스트를 표시하고자하므로 레이블을 사용합니다.
 이제 인스펙터 패널에 커스터마이즈 옵션이 많이 있음을 알 수 있습니다.
 그래서 우리는 계속해서 텍스트를 주목할만한 것으로 바꿀 것입니다.
 우리는 본문 스타일을 사용하도록 글꼴을 변경하려고합니다.
 그리고 접근성 설정이 가능한 사용자가 자신의 필요에 맞는 글꼴 크기와 스타일로 텍스트를 볼 수있는 동적 유형을 활성화 할 것입니다.
 이제 인터페이스 빌더에서이 라벨을 사용자 정의 할 수는 있지만, Swift에서 이러한 모든 속성을 볼 수도 있습니다.
 그래서 우리는 런타임에 텍스트와 서식 속성을 동적으로 설정할 수 있습니다.
 이제 인터페이스 빌더로 돌아가서 두 가지 레이블을 더 추가 할 것입니다.
 이제는 모든 것이 잘 들어 맞습니다. 그러나 여기서해야 할 일이 하나 더 있습니다.
 Apple News를 보면 오른쪽의 텍스트가 실제로 두 가지 색상으로 표시된다는 것을 알 수 있습니다.
 그것의 일부는 검은 색이고 일부는 흰색입니다.
 이제는 두 개의 별도 레이블을 사용하여이 작업을 수행 할 수 있었지만 하나의 레이블 만 사용하려면 Interface Builder에서이 작업을 수행 할 수 없었습니다.

그러면 우리가 어떻게이 일을 할 수 있을까요? 음, 우리는 속성 문자열의 힘과 유연성을 이용할 수 있습니다.
 이제 속성이 지정된 문자열은 특성 범위를 문자 범위에 적용 할 수있는 문자의 실행입니다.
 이제 기본 글꼴 및 텍스트 색상과 같이 무료로 얻을 수있는 속성이 있지만, 이러한 속성을 자체 값으로 재정의 할 수 있습니다.
 이 경우 문자열의 텍스트 색상 부분을 흰색으로 설정합니다.
 이제 작동중인 속성 문자열을 보려면 NSMutableAttributedString의 add 속성 메소드를 사용하여 원하는 범위의 텍스트 색상을 흰색으로 설정합니다.
 이번에는 레이블에 속성이 지정된 텍스트 속성을 설정합니다.
 런타임에, 이것은 꽤 멋져 보입니다.
 이제 UILabels는 이런 종류의 텍스트를위한 훌륭한 선택이었습니다.
 이제 화면 하단을 보면 헤드 라인이 보입니다.
 이제 이것은 텍스트이지만 조금 더 커지고 여러 줄에 걸쳐 있습니다.
 이 텍스트를 다른 것으로 만드는 또 다른 방법은 선택할 수 있다는 것입니다.
 그래서 우리는이 시간을 사용해야합니까? 이제 텍스트 필드와 텍스트보기 모두 선택을 지원하지만 텍스트 필드는 대개 단 한 줄을 의미합니다.
 이 경우 헤드 라인이 여러 줄에 걸쳐있을 수 있으므로 텍스트보기를 사용합니다.
 이제 스토리 보드에 텍스트보기를 배치하면 기본적으로 많은 ipsum 텍스트를 얻을 수 있습니다.
 이제 우리는 inspector panel의 텍스트를 변경하려고합니다.
 우리는 또한 글꼴을 Apple News와 조금 더 비슷하게 변경하려고합니다.
 그리고 헤드 라인이 실제로 편집 가능하지 않기 때문에 편집 기능을 사용하지 않기를 원합니다.
 UITextView는 UIScrollView의 하위 클래스이므로 기본적으로 스크롤됩니다.
 그러나 자동 레이아웃을 사용하여 텍스트보기를 잘 나타내려면 스크롤을 비활성화해야합니다.
 따라서 텍스트보기의 범위를 텍스트에 맞게 조정할 수 있습니다.
 마지막으로,이 흰색 배경은 정말로 필요합니다. 그래서 우리는 그것을 투명하게 설정할 것입니다.
 이제 Interface Builder를 사용하면이 텍스트보기를 쉽게 사용자 정의 할 수 있었지만 이전 레이블과 마찬가지로 코드에서이 모든 것을 설정할 수 있습니다.
 Swift에서는 런타임에 텍스트와 서식 속성을 동적으로 설정할 수 있습니다.
 그래서 우리는 Apple News에서 올바른 컨트롤을 선택하는 방법을 살펴 보았습니다. 이제는 익숙한 다른 응용 프로그램을 살펴보고 올바른 구성을 선택해야합니다. TextEdit입니다.
 이제 TextEdit은 리치 텍스트 컨텐츠의 표시 및 편집을 처리하는 macOS의 응용 프로그램입니다.
 이제 대부분의 사람들은 TextEdit이 사실 NSTextView를 감싸는 정말 얇은 래퍼라는 것을 모릅니다.
 그래서 저는 TextKit으로 무료로 얼마를 얻을 수 있는지 잠시 생각해보고 싶습니다.
 따라서 이것은 검사기 바이며 인터페이스 빌더의 확인란을 선택하면 무료입니다.
 그리고 바로 아래에있는 통치자의 견해는 우리가 그것을 가능하게 함으로서 무료로 얻을 수 있습니다.
 그 아래 모든 내용은 텍스트보기입니다.
 사실, 텍스트보기, 텍스트 컨테이너, 레이아웃 관리자 및 텍스트 저장소입니다.
 이제 이것은 NSTextView와 UITextView 모두에 대한 표준 구성이지만 유사점은 대부분 거기에서 멈 춥니 다.
 예를 들어 테이블은 NSTextView에서만 지원됩니다.
 우리가 무료로 얻을 수있는 힘을 다시 한번 생각해 보면, TextKit은 우리에게 힘든 일을하는 테이블 편집기를 제공합니다.
 이제 TextEdit을 사용할 때 대용량의 텍스트를 편집하는 경우가 있습니다.
 때때로 우리는 많은 lorem ipsum을 붙여서 우리가 무료로 맞춤법 검사기를 얻는 것을 보게됩니다.
 그러나 실제로 우리가보고 싶은 것은 포맷 메뉴를 사용하여 페이지로 감싸기를 선택하면 페이지가 조금 더 복잡해집니다.
 텍스트 컨테이너가 용지의 크기와 일치하도록 크기가 조정 된 것을 볼 수 있습니다.
 이제 아래로 스크롤하면 텍스트가 첫 번째 페이지에서 두 번째 페이지로 이동하는 것을 볼 수 있습니다.
 이제 표준 구성은 실제로 이와 같은 레이아웃을 지원하지 않습니다.
 물론이 레이아웃은 두 개의 텍스트보기와 텍스트 컨테이너를 사용합니다.
 이제는 동일한 레이아웃 관리자와 텍스트 저장소에 의해 관리되므로 텍스트를 한 페이지에서 다음 페이지로 자유롭게 이동할 수 있습니다.
 이제 TextEdit의 작동 방식에 대해 더 자세히 알고 싶다면 가이드 및 샘플 코드 라이브러리에서 소스를 찾을 수 있습니다.
 올바른 컨트롤을 선택 했으므로 적절한 구성을 선택했습니다. 그러나 때로는 우리가 원하는 것을 성취하기 위해 이들을 망칠 필요가 있습니다.
 그러나 우리는 어느 망치를 사용할 지 어떻게 결정할 것인가? 그래서 우리는 저널 앱을 함께 만드는 단계를 밟을 때 그 일에 맞는 망치를 고르려고 노력할 것입니다.
 오늘 날짜를 창에 표시하는 것으로 시작하겠습니다.
 이제는 AppKit에 UILabels가 없지만 텍스트 필드를 레이블처럼 작동하게 만들 수 있습니다.
 우리가해야 할 일은 편집을 불가능하게하는 것뿐입니다.
 이제 윈도우의 분개 항목에 대해 텍스트보기를 사용합니다.
 따라서 관리자는 텍스트보기를 편집하고 선택할 수 있는지 확인하고 서식있는 텍스트를 지원하고 실행 취소 할 수 있습니다.
 우리는 얼마나 많은 단어가 쓰여 졌는지 보여줄 수 있도록 몇 개의 텍스트 필드를 창 하단에 추가 할 것입니다.

그리고 우리는 굵은 글꼴을이 새로운 문자열에 do not라는 단어에 적용했습니다. 우리는이 잘못된 결과로 단어가 Comic Sans 굵은 글꼴 24로되어 있고 나머지 문자열이 기본 글꼴로되어 있습니다. 헬 베티 야 12.
 그래서 우리가 올바르게 할 수있는 두 가지 다른 방법이 있습니다. 한 가지 방법은 평범하고 속성이있는 텍스트를 함께 사용하지 않는 것입니다.
 따라서 원래 속성을 사용하여 새 속성 문자열을 초기화하면 원래 특성을 유지하게됩니다.
 그런 다음 기본 속성으로 재설정 효과를 사용하지 않고 새 속성을 적용 할 수 있습니다.
 그러나 평범하고 속성이있는 텍스트를 혼합하는 것을 피하는 것이 항상 가능하지는 않습니다.
 따라서 혼합해야하는 경우 일반 텍스트 문자열에서 새 속성 문자열을 만들 때 명시 적으로 특성을 제공 할 수 있습니다.
 원본 텍스트에서 동일한 속성을 적용하면 올바른 결과를 얻을 수 있습니다.
 그러나이 리셋 효과는 글꼴뿐만 아니라 기본값을 갖는 모든 특성에서 발생할 수 있다는 것을 알고 있어야합니다.
 보시다시피 기본값이있는 많은 특성이 있습니다.
 그래서 여기서 단락 스타일을 부적절한 리셋 포인트로 부르고 싶습니다.
 그리고 이유를보기 위해 이전 예제를 다시 살펴 보겠습니다.
 그러나 글꼴을 변경하는 대신 아무도 혐오를 좋아하지 않으므로 단락 스타일을 변경하여 혐오 단어를 자릅니다.
 따라서 우리는 텍스트를 이와 같이 보이기를 원하지만이 코드를 실행하면 Helvetica 12의 모든 텍스트와 기본 줄 바꿈 스타일을 사용하여 줄 바꿈이라는 기본 줄 바꿈 모드를 사용하여 결과를 얻습니다.
 다시 말하지만, 이것은 만화에서 완전히 제거 되었기 때문에 Comic Sans를 싫어하는 사람들에게는 정말 좋습니다.하지만 잘못된 것입니다.
 지난번과 다른 방식으로 잘못되었습니다.
 그리고 차이점을 이해하기 위해, 레이아웃 전에 속성 수정이 일어나고 시스템이 일관성없는 속성을 수정한다는 점을 기억하십시오.
 그래서 여기에있는 우리의 귀속 문자열에는 여러 개의 단락 스타일을 가진 단락이 있습니다. 이것은 꽤 일관성이 없습니다.
 따라서 시스템이이 문자열의 속성을 수정하면 찾은 첫 번째 단락 스타일을 전체 단락에 적용합니다.
 이것이 기본 단락 스타일로 표시되는 속성 문자열의 결과입니다.
 그리고 여기에서 중요한 부분은 속성을 명시하는 것입니다. 특히 평범하고 속성이있는 텍스트를 혼합하는 경우 더욱 그렇습니다.
 따라서 이렇게하면 기본 속성으로이 재설정 효과를 피할 수 있습니다.
 AppKit 개발자의 경우 앱을 어두운 모드로 업데이트하는 경우 실제로는 매우 중요합니다.
 그래서 NSColor와 같은 동적 인 색상과 함께 명시 적 속성을 사용합니다.
textColor를 사용하면 문맥에 맞는 색상으로 텍스트를 그려야합니다.
 그래서 계속 나아 갔다.
 다음 주제는 성능입니다.
 많은 양의 텍스트로 작업하는 경우 앱 성능을 향상시키는 좋은 방법은 비 연속 레이아웃을 사용하는 것입니다.
 그리고 그것이 의미하는 바를 이해하기 위해, 우리의 오랜 친구 인 레이아웃 과정을 다시 살펴 봅시다.
 레이아웃 프로세스는 글리프 생성과 그립 레이아웃으로 구성됩니다.
 그리고 연속 레이아웃을 사용하면 레이아웃 관리자는 텍스트 저장 장치의 시작 부분에서 시작하여 글리프 생성 및 글리프 레이아웃을 수행합니다.
 그리고 처음부터 끝까지 순차적으로 진행됩니다.
 그리하여 앱을 사용하는 누군가가 텍스트보기의 중간 지점으로 스크롤하면 레이아웃 관리자는 빨간색 직사각형으로 표시된 지점 이전의 모든 글리프에 대한 글리프를 생성하고 레이아웃해야합니다.
 또한 텍스트 저장소의 시작 부분까지 화면 맨 위로 스크롤되는 것을 볼 수없는 텍스트도 여기에 포함됩니다.
 텍스트가 많은 경우 가난한 사람이 앱이 레이아웃을 완료하는 동안 잠시 기다려야 할 수도 있지만 다행스럽게도 비 연속 레이아웃을 사용하면 이러한 상황을 피할 수 있습니다.
 이름에서 알 수 있듯이 비 연속 레이아웃을 사용하면 레이아웃 관리자는 텍스트 저장 장치의 시작 부분부터 순서대로 글리프 생성 및 레이아웃을 수행 할 필요가 없습니다.
 이제 사용자가 앱을 사용하여 텍스트보기의 중간으로 스크롤하면 레이아웃 관리자는 중간 섹션에 대한 글리프 생성 및 레이아웃을 바로 수행 할 수 있습니다.
 따라서 텍스트 저장소에 많은 텍스트가 포함되어있는 경우 비 연속 레이아웃을 사용하면 성능이 크게 향상됩니다.
 큰.
 그럼 이걸 어떻게 켜는거야? 음, 비 연속 레이아웃은 NSLayoutManager의 속성입니다.
 NSTextView의 경우 레이아웃 관리자를 사용하기 위해 텍스트에 액세스 한 다음 해당 속성을 설정할 수 있습니다.
 UITextView의 경우 기본적으로 설정되어 있기 때문에 일반적으로 아무 것도 할 필요가 없지만 기억해야 할 중요한 사항이 하나 있습니다.
 UITextView는 UIScrollView의 하위 클래스이므로 비 연속 레이아웃에서는 스크롤을 활성화해야합니다.

그리고 스크롤을 사용하지 않도록 설정하면 텍스트보기의 본질적인 콘텐츠 크기를 묻는 것은 모든 텍스트를 배치해야하므로 처음에는 비 연속 레이아웃의 성능 이점을 얻지 못할 것이기 때문입니다.
 그리고 그것은 저를 정말로 중요한 포인트로 이끌어줍니다.
 비 연속 레이아웃을 사용하는 경우 텍스트의 전체 또는 대부분에 대한 레이아웃을 요청하지 않아야합니다. 그 이유는 처음부터이 레이아웃을 사용하는 목적을 상쇄하기 때문입니다.
 따라서 텍스트 컨테이너가 하나뿐이라면 전체 레이아웃을 요구하지 마십시오.
 그리고 텍스트의 끝을 포함하는 큰 범위의 글자 또는 글자에 대한 레이아웃을 요구하지 마십시오.
 그리고 저는 작년에 WWDC 2017, Frameworks와의 효율적인 논평에서 위대한 연설을했기 때문에 여기에서 텍스트 퍼포먼스의 주제를 깊이 파고 들지 않았습니다.
 그리고 세션이 끝나면 더 많은 정보 링크에서 비디오에 액세스 할 수 있습니다.
 괜찮아.
 이제 모든 사람이 좋아하는 주제, 보안에 대해 이야기 할 시간입니다.
 따라서 인터넷을 사용하는 일부 사람들이 우리 소프트웨어의 버그를 악용하여 제품을 사용하는 사람들에게 문제를 일으킨 사건이 최근에있었습니다.
 이에 대응하여 이러한 종류의 공격을 완화하기위한 기술을 계속 개발하고 있지만, 오늘은 이러한 공격에 대해보다 강력한 방어책을 제공하기 위해 어떻게 협력 할 수 있는지에 대해 이야기하고자합니다.
 따라서 당신은 개념 방어에 대해 깊이 들어야 할 것입니다.
 용어에 익숙하지 않은 경우 위협에 대한 방어를 위해 여러 계층의 보호 기능을 만드는 것을 의미합니다.
 그리고이 개념은 수세기 동안 주변에있었습니다.
 중세 성의 디자인에서 볼 수 있습니다.
 외부의 땅에는 나무가 없으므로 공격자가 오는 것을 볼 수 있습니다.
 그리고 성을 접근하기가 더 어렵게하고 그 아래에서 터널링을 방지하기위한 해자가 있습니다.
 그리고 벽은 또 다른 방어입니다.
 그들은 등반하기가 어렵도록 키가 튼튼합니다.
 그리고 벽에 화살표가 새겨 져 있고 상단에 사다리꼴이있어 방어자가 보호 된 지역의 공격자에게 발포하도록 허용합니다.
 이제 이들 개인 보호 장치 중 어느 하나가 공격을 방어하기에 충분하지 않을 수도 있지만 집단적으로는 강력한 방어 장치를 제공합니다.
 그리고 성 (Castle)과 마찬가지로 Apple은 공격으로부터 여러 층의 방어를 제공하지만, 앱이나 프레임 워크에서 자신의 방어 조치를 취하지 못하게하는 것도 없습니다.
 이렇게하면 보호 수준을 높이고 제품 보안을 향상시킬 수 있습니다.
 모두가 이기고.
 여기에서 할 수있는 것에 대해 이야기 해 봅시다.
 그리고 내가 고려해보고 싶은 것은 앱이나 프레임 워크에서 텍스트 입력에 대한 제한을 설정하는 것입니다.
 이제는 이것이 항상 의미있는 것은 아니라고 강조하고 싶습니다.
 예를 들어, 앱이 에밀리가 이전에 보여준 저널 앱과 같은 저작 도구 인 경우 텍스트의 길이에 제한을 설정하는 것은 실제로 의미가 없습니다.
 그래서 이해가되지 않는다면, 그렇게해서는 안됩니다.
 그러나 휴대 전화 앱에 닉네임을 계정에 할당하기위한 텍스트 필드가있는 경우 합당한 제한이 무엇인지 알 수 있습니다.
 모든 텍스트 입력이 신뢰할 수 없으므로 이러한 제한을 설정하는 것이 좋습니다.
 텍스트 입력을 허용하면 복사하여 붙여 넣을 수 있습니다.
 거기에 붙여 넣을 수있는 텍스트의 종류를 알지 못합니다.
 그것은 무엇이든 수 있습니다.
 그것은 악의적 인 문자 조합이있는 문자열 일 수도 있고, 실제로는 정말로 길기도 한 문자열 일 수 있습니다.
 그런 긴 문자열이 그 자체로 악의적이지는 않지만 앱이 멈추거나 멈출 수 있습니다.
 따라서 한 줄의 입력을위한 텍스트 필드가 있고 누군가가 "전쟁과 평화"의 전체 내용을 붙여 넣으면 약 3입니다.
영어로 1 백만 자, 그게 합리적입니까? 아마도 그렇지 않습니다.
 따라서 이것은 자신의 한계를 부과하는 것이 타당한 경우의 좋은 예입니다.
 그리고 이러한 종류의 한계를 설정하기위한 권장 접근법이 있습니다.
 입력 문자열이 텍스트 필드에 설정되기 전에 유효성을 검사하려고합니다.
 UITextFields의 경우 UITextFieldDelegate를 사용하여이 작업을 수행 할 수 있습니다.
 NSTextFields의 경우 사용자 정의 NSFormatter를 사용하여 유효성 검사 논리를 구현해야합니다.
 오, 그리고 우리는 당신의 방법으로 오는 몇 가지 추가적인 보안 강화 기능을 가지고 있습니다.
 따라서 출시 노트에 계속 주목하고 질문이 있으면 이번 주에 실험실에서 만나십시오.
 괜찮아.
 우리는 막 막 빠져 나오고 있습니다.
 올바른 컨트롤, 사용자 지정 포인트 및 사용자 지정 방법을 선택하는 방법을 알고 올바른, 성능 및 보안 분야에서 따라야 할 최상의 방법을 알고 있습니다.
 따라서이 지식을 사용하여 TextKit으로 멋진 것을 만들어보십시오.
 오, 그리고 가기 전에, 여기에 우리가 참조한 위대한 과거 세션과 문서를 모두 찾을 수있는 더 중요한 정보 링크가 있습니다.
 목요일과 금요일 실험실에서 우리를 방문하십시오.
