안녕, 여러분.
 나는 벤이야.
 스위프트 표준 라이브러리에서 작업하고 있습니다.
 그리고 컴파일러 팀의 동료 Doug와 함께 Swift generics에 관해 이야기 할 것입니다.
 따라서 Swift의 최근 릴리스에는 조건부 적합성 및 재귀 프로토콜 제약 조건을 비롯한 몇 가지 중요한 새로운 기능이 추가되었습니다.
 사실, 스위프트가 출시 될 때마다 우리는 제네릭 시스템을 개선하여 더욱 풍부한 표현력을 보여주었습니다.
 그리고 우리는 그것이 4라고 느낍니다.
2 릴리스는 중요한 포인트입니다.
 그것은 우리가 마침내 표준 라이브러리를 위해 구상 되어온 수많은 디자인을 마침내 완전히 구현할 수있는 지점입니다.
 Swift의 API 안정성 목표를 달성하는 데 중요한 역할을합니다.
 그래서 우리는 과거에 제네릭에 관해 많은 이야기를 나누었습니다. 그러나 우리는 한 발 뒤로 물러나지 않았고 제네릭 전체에 관해 한동안 이야기했습니다.
 따라서 오늘날 우리는 신생아와 노령의 제네릭 시스템의 몇 가지 다른 기능을 통해 이들이 어떻게 잘 어울리는 지 이해할 수 있도록 할 것입니다.
 나는 제네릭에 대한 동기를 간략하게 요약 할 것이다.
 표준 라이브러리에서 가져온 예제를 사용하여 여러 가지 구체적인 유형을 제공하면서 프로토콜을 디자인하는 방법에 대해 이야기 할 것입니다.
 프로토콜 상속을 검토하고 조건부 준수의 새로운 기능 및 프로토콜 상속과 상호 작용하는 방법에 대해 설명합니다.
 그리고 마지막으로 수업과 제네릭에 대한 토론을 마무리하겠습니다.
 왜 제네릭은 스위프트의 중요한 부분입니까? 음, 영향을 보는 한 가지 방법은 유형과 같은 간단한 컬렉션을 디자인하는 것입니다.
 버퍼라고 부르며 표준 라이브러리의 배열 유형과 유사합니다.
 이제는 버퍼의 읽기 부분에 사용할 수있는 가장 간단한 API에는 요소 수의 계산과 각 요소를 인덱스의 지정된 위치로 가져 오는 방법이 포함될 수 있습니다.
 그러나 우리는 그 리턴 타입을 무엇으로 만들 것인가? 이제 우리가 제네릭을 가지고 있지 않다면, 우리는 버퍼 안에 넣고 싶은 것을 표현할 수있는 일종의 타입으로 만들어야 할 것입니다.
 해당 유형 ID를 호출하거나 확인하거나 별표 표시를 제거 할 수 있습니다.
 스위프트에서 우리는 이것을 Any라고 부릅니다. Swift에서는 다른 유형의 다른 유형에 대해서 서있을 수있는 유형입니다.
 따라서 버퍼에서 아무 것도 처리하지 않으려는 경우 하위 스크립트에서 Any를 반환 할 수 있습니다.
 그러나 물론, 그 사실은 정말 불쾌한 사용자 경험으로 이어질 수 있습니다.
 어느 시점에서 실제로 사용하려면 상자 안의 해당 유형을 꺼내야합니다.
 그리고 이것은 성가신 것이 아니라 오류가 발생하기 쉽습니다.
 실수로 코드의 어딘가에 정수 문자열을 버퍼의 버퍼로 넣으면 어떨까요? 그러나 사용 편의성뿐만 아니라 이러한 값이 메모리에 어떻게 표시되는지에 관한 몇 가지 문제를 해결하기를 원합니다.
 이제 문자열의 버퍼를 나타내는 이상적인 표현은 메모리의 인접한 블록 일 것입니다. 각 요소는 서로 나란히 놓여 있습니다.
 그러나 유형이 지정되지 않은 접근 방식에서는 버퍼가 어떤 유형의 타입을 포함할지 미리 알 수 없기 때문에 이것이 제대로 작동하지 않습니다.
 따라서 Any와 같은 유형을 사용해야하며, 그 중 하나의 가능성을 설명 할 수 있습니다.
 그리고 Any에서 추적, 복싱 및 언 박싱에 많은 오버 헤드가 있습니다.
 여기서 정수 버퍼를 원했을 지 모르지만 컴파일러에 표현할 방법이 없습니다.
 그래서 저는 그것에 관심이 없지만 융통성을 지불하고 있습니다.
 더 중요한 것은 Any는 자체 내부 저장소에 들어 가지 않을만큼 너무 큰 유형을 포함하여 다른 종류의 유형을 고려해야하기 때문에 때때로 간접 사용을 사용해야합니다.
 값에 대한 포인터를 보유해야하며 그 값은 메모리 전체에 위치 할 수 있습니다.
 따라서 우리는 사용의 용이성과 정확성뿐만 아니라 성능상의 이유로 이러한 문제를 해결하기를 정말로 원합니다.
 그리고 우리는 파라 메트릭 다형성 (parametric polymorphism)이라는 기법을 사용합니다. 스위프트 (Swift)의 제네릭 (generics)을 참조하는 또 다른 용어입니다.
 일반적인 접근 방식을 사용하면 버퍼에 더 많은 정보를 넣어 버퍼가 포함 할 유형을 나타냅니다.
 우리는이 요소를 Element라고 부를 것입니다.
 요소는 유형의 일반 매개 변수이므로 매개 변수 다형성의 용어입니다.
 컴파일 시간 인자와 같다고 생각하면 버퍼에 무엇을 포함할지 알 수 있습니다.
 이제는 해당 요소 유형을 참조하는 방법이 있습니다.
 이전에 Any를 사용하고 있던 곳이라면 어디서나 사용할 수 있습니다.
 즉, 버퍼에서 유형을 가져올 때 변환 할 필요가 없다는 의미입니다.
 그리고 실수로 타입을 잘못 지정하거나 비슷한 문제가 생기면 컴파일러가 여러분을 잡을 것입니다.
 이제 관련 요소 유형이없는 버퍼와 같은 유형이 없습니다.
 그런 식으로 선언하려고하면 컴파일 오류가 발생합니다.
 약간 놀라운 점은 요소 유형이없는 버퍼와 같은 유형을 선언 할 수 있음을 알 수 있기 때문입니다.


그러나 이는 컴파일러가 요소 유형이 컨텍스트에서 무엇이어야 하는지를 추론 할 수 있기 때문입니다.
 이 경우 오른쪽의 리터럴에서 가져옵니다.
 그 요소는 여전히 존재하며 암시 적입니다.
 버퍼와 같은 타입의 타입에 대한 지식은 컴파일과 런타임 모두에 걸쳐 수행됩니다.
 그리고 이것은 우리가 모든 유형의 요소가 임의로 커도 오버 헤드없이 연속 된 메모리 블록에 모든 요소를 ​​보유한다는 목표를 달성 할 수 있음을 의미합니다.
 그리고 컴파일러는 버퍼에 포함 된 요소 유형을 항상 정확하게 파악할 수 있기 때문에 그렇지 않은 경우 사용할 수있는 최적화 기회가 있습니다.
 그래서 여기에 정수 버퍼를 선언 한 곳에서 루프는 매우 효율적인 CPU 명령어로 컴파일되어야합니다.
 이제 이와 같은 루프를 작성하여 정기적으로 정수 버퍼를 합산하는 경우이를 메소드로 추출하는 것이 좋습니다.
 더 많은 단위 테스트가 가능한 버퍼의 확장이며 실제로 호출 할 때 더 읽기 쉽습니다.
 그러나 이와 같은 코드를 작성했다면 모든 요소 유형을 이렇게 요약 할 수는 없으므로 컴파일 문제가 발생한다는 것을 알고있을 것입니다.
 이 메소드를 버퍼에서 사용 가능하게하려면 요소에 필요한 기능에 대해 컴파일러에 더 알릴 필요가있다.
 이제는 가장 쉬운 방법은 요소 유형을 원래 루프의 int와 같은 특정 유형으로 제한하는 것입니다.
 이 쉬운 접근법을 사용하여 확장 프로그램을 시작하고 실행하는 경우 나중에 두 가지 버퍼를 합산하거나 부동 한 것과 같은 다른 작업이 필요할 때 쉽게 일반화 할 수 있습니다.
 귀하가 제약 한 유형을 살펴보십시오.
 준수하는 프로토콜을 살펴보고 작업을 수행하는 데 필요한 모든 것을 제공하는 가장 일반적인 프로토콜을 얻을 때까지 프로토콜을 따르십시오.
 이 예제에서는 여기에 의존하는 두 가지 기능을 제공하는 숫자 프로토콜, 값 0을 갖는 새로운 요소를 생성하는 기능 및 숫자의 일부로 오는 요소를 추가 할 수있는 기능을 제공합니다 실험 계획안.
 이제 다양한 유형의 프로토콜을 분해하는 과정에 대해 이야기 해 보겠습니다.
 그래서 우리는이 버퍼 유형에 대해 이야기 해 왔으며 다른 요소에 대해 일반적인 것으로 만들 수 있습니다. 그러나 다른 방향으로 일반적인 제네릭 코드를 작성하는 것은 어떻습니까? 다른 종류의 컬렉션에서 작동하는 코드 작성 중? 버퍼 유형과 매우 유사하지만 키 값 쌍의 모음 인 사전 또는 데이터 유형이나 문자열과 같은 다른 요소 유형과 같이 일반 유형이 아닌 유형과 같은 다양한 유형이 있습니다. 특정 요소 유형을 반환합니다.
 우리는 모든 공통 기능을 포착하는 프로토콜을 만들고 싶습니다.
 우리는 표준 라이브러리 자체 컬렉션 프로토콜의 단순화 된 버전을 작성하려고합니다.
 그래서 우리는 다양한 종류의 구체적인 유형을 우선 고려했습니다.
 이제 우리는 모두 함께 참여할 수있는 일종의 프로토콜에 대해 생각하고 있습니다.
 그리고 이런 식으로 물건을 생각하는 것이 중요합니다.
 몇 가지 구체적인 유형으로 시작한 다음 프로토콜로 통합 해보십시오.
 그 유형에는 공통점이 있습니까? 그들은 공통점이 무엇입니까? 이와 같은 프로토콜을 설계 할 때 계약 협상과 같은 것이라고 생각할 수 있습니다.
 한편으로는 계약을 이행하는 데 가능한 한 많은 유연성을 원하고, 프로토콜의 사용자는 확장 기능을 수행하기 위해 정말 멋지고, 단단하고, 단순한 프로토콜을 원한다는 당연한 유형들 사이에서 자연스럽게 밀고 당깁니다 .
 그렇기 때문에 프로토콜을 설계 할 때 여러 가지 서로 다른 가능한 준수 유형과 여러 가지 다양한 유스 케이스를 염두에 두는 것이 중요합니다.
 그것은 균형 잡힌 행동이기 때문입니다.
 이제 콜렉션 프로토콜을 시작하겠습니다.
 먼저 요소 유형을 표현해야합니다.
 이제 프로토콜에서 관련 유형을 사용합니다.
 각 순응 유형은 요소를 적절한 것으로 설정해야합니다.
 스위프트 4의 버퍼 또는 어레이의 경우.
2, 이것은 자동으로 발생합니다.
 왜냐하면 일반 매개 변수도 요소이기 때문입니다.
 이것은 요소라는 단어와 같은 공통된 규칙을 따르는 의미있는 이름을 일반적인 인수에 제공하는 것보다 유리합니다. T와 같이 임의로 T 요소와 같은 임의의 요소를 지정하는 대신 요소 유형을 별도로 지정해야합니다.
 다른 데이터 유형의 경우 약간 더 구체적으로해야 할 수도 있습니다. 예를 들어, 사전은 요소 유형을 키 및 값 유형 쌍으로 설정해야합니다.
 다음으로 아래 첨자 연산을 추가하는 것에 대해 설명합니다.
 이제 배열과 같은 유형의 프로토콜에 대해서만 말하면, subscript가 int를 인수로 사용하도록 유혹받을 수 있습니다.
 그러나 아래 첨자를 int로 만드는 것은 매우 강력한 계약을 의미합니다.

모든 순응 형은 정수로 표현 된 요소의 주어진 위치를 가져 오는 기능을 제공해야합니다.
 그리고, 배열과 같은 타입들에 대해 잘 작동합니다.
 프로토콜 사용자가 쉽게 이해할 수 있습니다.
 그러나 사전과 같이 약간 더 복잡한 유형의 경우 충분히 유연합니까? 자, 어떻게 모델링했는지에 상관없이, 사전은 아마도 하나의 요소에서 다음 요소로 이동하기위한 특정 논리를 가진 상당히 복잡한 내부 데이터 구조에 의해 뒷받침 될 것입니다.
 예를 들어, 어떤 종류의 내부 버퍼에 의해 뒷받침 될 수 있으며, 그 버퍼에 오프셋을 저장 한 인덱스 유형을 사용할 수 있습니다. 그런 다음 인덱스를 사용하여 요소를 가져 와서 위치에 가져 오거나 그 오프셋.
 그러나 사전의 색인 유형은 사전 만 제어 할 수있는 은폐 형이어야합니다.
 누군가가 꼭 오프셋에 1을 더하고 싶지는 않을 것입니다.
 그것은 반드시 사전의 다음 요소로 이동하지는 않습니다.
 그것은 사전의 내부 저장 장치의 임의의, 아마도 초기화되지 않은 부분을 이동할 수 있습니다.
 대신 사전을 사용하여 색인을 전진 시켜서 컬렉션을 통해 앞으로 나아갈 수있게하고 싶습니다.
 그리고 그렇게하기 위해 색인을 제공하는 또 다른 메소드를 추가하고 그 뒤에 위치를 표시하는 색인을 제공합니다.
 이 단계를 수행하면 몇 가지 더 필요한 것이 있습니다.
 시작 인덱스 속성과 끝 인덱스 속성이 필요합니다.
 왜냐하면 우리가 끝까지 도달했다는 것을 말해주기 위해 간단한 계산이 더 이상 작동하지 않을 것이기 때문입니다.
 이제 int를 인덱스 유형으로 사용하지 않습니다.
 따라서 수집 프로토콜로 되돌려 보겠습니다.
 그래서 우리는 위치를 표현하기 위해 인덱스 타입을 취하는 첨자를 가지고 거기에 요소를 제공합니다.
 그리고 우리는 그 입장을 앞으로 나아갈 수있는 방법을 가지고 있습니다.
 그러나 색인에 어떤 유형의 문자를 사용할 지 유형을 제공해야합니다.
 우리는 또 다른 연관된 유형으로 그렇게합니다.
 적합 형 타입은 적절한 타입을 제공 할 것이기 때문에 배열이나 데이터는 int를 인덱스 타입으로, 반면 사전은 자체 내부 로직을 처리하는 자체 커스텀 구현을 제공한다.
 이제 색인 생성 모델을 일반화하기 위해 1 분 전에 계산 한 값으로 돌아가 보겠습니다.
 가지고있는 것은 여전히 ​​유용한 자산입니다.
 그래서 우리는 그것을 콜렉션의 확장으로 다시 추가하기를 원할 것입니다.
 컬렉션을 돌아 다니며 인덱스를 앞으로 이동시키고 카운터를 증가시켜 반환합니다.
 이제 우리가 이것을 시도하고 구현한다면, 우리는 또 하나 빠진 요구 사항을 갖게되었습니다.
 int에서 일반 인덱스 유형으로 이동 했으므로 더 이상 인덱스 유형이 동일하지 않다고 가정 할 수 없습니다.
 삽입은 가능하지만 임의의 인덱스 유형은 필수는 아닙니다.
 그리고 우리는 우리가 끝까지 도달했음을 알기 위해 그것을 필요로합니다.
 이제 우리는 인덱스 유형이 동등 할 때만 작동한다고 이전에했던 것과 동일한 방식으로이 문제를 해결할 수있었습니다.
 그러나, 그것은 옳다고 생각하지 않습니다.
 우리는 프로토콜을 사용하기 쉽도록 만들고 싶습니다. 그리고 우리가 작성한 모든 확장에 항상 제약 조건을 두어야한다면 정말 자극적이 될 것입니다.
 우리는 거의 항상 두 개의 인덱스를 비교할 수 있어야합니다.
 대신, 우리의 인덱스 관련 유형에 대한 제약 조건으로 프로토콜의 요구 사항으로 표현하는 것이 더 낫습니다.
 이 제약 조건을 프로토콜에 적용하면 프로토콜을 준수하는 모든 유형이 해당 인덱스에 대해 동등한 유형을 제공해야합니다.
 그렇게하면 확장 프로그램을 작성할 때마다 지정하지 않아도됩니다.
 이것은 프로토콜 계약을 협상하는 또 다른 예입니다.
 프로토콜 사용자는 실제로 인덱스를 비교할 수 있어야한다는 요구 사항이있었습니다.
 그리고 형식을 준수하면서 그들은 너무 많은 유연성을 포기하지 않고 합리적으로 수용 할 수 있는지 확인했습니다.
 이 경우, 그들은 확실히 할 수 있습니다.
 인치, 데이터 및 배열은 이미 동일하게 사용됩니다.
 그리고 스위프트 4.
2의 동등한 적합성에 대한 새로운 자동 합성은 사전이 색인 유형을 동등하게 만들 수 있도록합니다.
 다음으로, 사용자 정의 포인트를 사용하여이 계산 작업을 최적화하는 방법에 대해 설명 합니다.
 그래서 count의 버전을 작성했습니다.이 컬렉션은 전체 컬렉션을 거쳐 컬렉션의 요소 수를 계산합니다.
 그러나 분명히 많은 컬렉션이 훨씬 더 빠르게 할 수 있습니다.
 예를 들어, 사전이 자체적으로 보유한 요소의 수를 내부적으로 유지한 가정이 있다고 가정합니다.
 이 정보가있는 경우 자체 계산에서 제공 할 수 있습니다.
 즉, 사람들이 사전 계산을 요청할 때 어떤 컬렉션에서도 작동하는 원래 버전의 선형 시간 대신 빠른 일정 시간이 걸립니다.
 그러나 이와 같은 최적화를 추가 할 때 알고 있어야 할 사항이 있습니다. 프로토콜 요구 사항을 충족시키는 것과 특정 유형에 많은 오버로드를 추가하는 것의 차이입니다.

지금까지이 새로운 버전의 사전은 과부하 일뿐입니다.
 즉, 사전을 가지고있을 때 사전임을 알면보다 최신의 더 나은 버전을 얻을 수 있습니다.
 그러나 일반 알고리즘 내에서 호출하는 것은 어떻습니까? 예를 들어, 표준 라이브러리 맵의 버전을 작성하기를 원한다고 가정합시다. 아직 익숙하지 않은 경우 컬렉션의 각 요소를 변형하고 새로운 배열로 다시 제공하는 것은 매우 유용한 작업입니다.
 구현은 매우 간단합니다.
 새 배열을 만들고 컬렉션을 이동하고 각 요소를 변형 한 다음 배열에 추가합니다.
 이제 배열을 이처럼 배열에 추가하면 배열이 자동으로 커집니다.
 또한 새로운 요소를 수용 할 수있는 여유 공간을 확보하기 위해 내부 스토리지를 재 할당해야하는 경우가 있습니다.
 이런 루프에서는 얼마나 큰가에 따라 여러 번 반복해야 할 수도 있습니다.
 그리고 그 일을하는 데는 시간이 걸립니다.
 메모리를 할당하는 것은 상당히 비쌀 수 있습니다.
 이 구현으로 할 수있는 좋은 최적화 기법이 있습니다.
 최종 배열의 크기가 정확히 정확히 무엇인지 이미 알고 있습니다.
 그것은 우리의 원래 컬렉션과 정확히 같은 크기가 될 것입니다.
 그래서 우리는 배열에 앞쪽의 공간을 정확하게 예약 할 수 있습니다. 추가하기 시작하기 전에 멋진 속도 향상을 얻을 수 있습니다.
 그리고 이것을 위해서 우리는 카운트를 부릅니다.
 하지만 여기서 우리는 총칭 컨텍스트 (generic context)라고 불리는 것을 사용합니다.
 즉, 콜렉션 유형이 구체적이지 않은 완전히 일반적인 컨텍스트입니다.
 그것은 배열, 사전, 또는 [들리지 않음]리스트, 또는 무엇이든 될 수 있습니다.
 컴파일러가이 코드를 컴파일 할 때 더 많은 카운트를 사용할 수 있다는 것을 알 수 없습니다.
 그리고이 경우 호출 될 count 버전은 실제로 count의 일반 버전입니다. 이는 모든 컬렉션에서 작동하고 전체 컬렉션에서 반복됩니다.
 사전에지도를 호출하면 방금 작성한 더 나은 버전의 계산을 호출하지 않습니다.
 이와 같이 커스터마이징 된 메소드 나 프로퍼티가 일반 컨텍스트에서 호출되기 위해서는 프로토콜 자체에 대한 요구 사항으로 선언되어야합니다.
 우리는 특정 콜렉션이 최적화 된 버전의 카운트를 제공 할 수있는 방법이 있음을 입증 했으므로 프로토콜에 대한 요구 사항으로 추가하는 것이 좋습니다.
 이제는 구현할 필요가 있지만 모든 컬렉션은 자체 컬렉션을 제공 할 필요가 없습니다. 우리는 이미 컬렉션에서 작동하는 Extension을 통해 컬렉션을 제공했기 때문입니다.
 프로토콜에 요구 사항을 추가하고 그와 함께 확장을 통해 기본 구현을 추가하는 것은 사용자 정의 포인트라고 부릅니다.
 커스터마이징 포인트를 사용하면 컴파일러는 사용할 수있는 메서드 나 속성을 더 잘 구현할 수 있다는 것을 알 수 있으므로 일반 컨텍스트에서 프로토콜을 통해 해당 구현에 동적으로 디스패치합니다.
 자 이제 사전에지도를 호출하면 완전히 일반적인 함수 임에도 불구하고 더 잘 구현 될 것입니다.
 이와 같은 커스터마이징 포인트를 확장을 통해 기본 구현과 함께 추가하는 것은 클래스, 구현 상속 및 메소드 덮어 쓰기로 얻을 수있는 것과 동일한 이점을 얻는 매우 강력한 방법입니다.
 그러나이 기술은 클래스뿐만 아니라 구조체와 열거 형에서 작동합니다.
 이제 모든 방법이 이와 같이 최적화 될 수있는 것은 아닙니다.
 또한 사용자 지정 지점의 컴파일러 런타임 성능은 바이너리 크기에 작지만 0이 아닌 영향을 미칩니다.
 따라서 맞춤화 할 수있는 기회가있을 때는 맞춤화 지점을 추가하는 것이 좋습니다.
 예를 들어 방금 작성한지도 연산에는 다른 종류의 콜렉션이 실제로 더 나은 구현을 제공 할 수있는 합리적인 방법이 없습니다.
 따라서 맞춤 설정 지점으로 추가하는 것은 의미가 없습니다.
 확장 기능을 유지할 수 있습니다.
 그래서 우리는이 콜렉션 유형을 만들었습니다. 실제로 이제는 완전히 완벽하게 기능했습니다.
 그것은 가능한 많은 다른 적합한 유형을 가지고 있으며 여러분이 쓸 수있는 다양한 유용한 알고리즘을 가지고 있습니다.
 그러나 때로는 유형의 패밀리를 분류하기 위해 단일 프로토콜 이상이 필요합니다.
 프로토콜 상속이 필요합니다.
 그리고 그것에 대해 더 이야기하기 위해, 여기 더그입니다.
 고마워, 벤.
 따라서 프로토콜 상속은 Swift 시작 이후로 진행되었습니다.
 프로토콜 상속이 필요한 부분을 생각해보기 위해 우리가 작성한이 콜렉션 프로토콜을 살펴 보겠습니다.
 좋은 프로토콜입니다.
 그것은 잘 디자인되어 있습니다.
 그것은 준수 유형 집합을 설명하고 흥미로운 제네릭 알고리즘을 작성할 수있는 기능을 제공합니다.
 그러나 지금까지는 수집 프로토콜 측면에서 구현할 수없는 다른 컬렉션과 유사한 알고리즘을 찾기 위해 먼 곳에 도달 할 필요는 없습니다.

예를 들어, 어떤 술어와 일치하는 콜렉션에서 마지막 요소의 색인을 찾으려면 가장 좋은 방법은 마지막부터 시작하여 뒤로 이동하는 것입니다.
 수집 프로토콜로는 그렇게 할 수 없습니다.
 또는 무작위로 컬렉션의 요소를 임의로 뒤섞는 셔플 작업을 만들고 싶다고 가정 해 보겠습니다.
 글쎄, 그건 돌연변이가 필요하고, 수집은 그렇게하지 않습니다.
 이제는 콜렉션 프로토콜이 잘못되었다는 것이 아니라, 이러한 추가 일반 알고리즘을 설명하는 데 더 많은 것이 필요하다는 것입니다. 이것이 바로 프로토콜 상속의 요점입니다.
 따라서 여기에서 bidirectionalCollection 프로토콜은로부터 상속 받거나 콜렉션입니다.
 즉, bidirectionalCollection 프로토콜을 준수하는 모든 유형이 콜렉션을 따르며 이러한 콜렉션 알고리즘을 사용할 수 있다는 것입니다.
 그러나 bidirectionalCollection은 콜렉션에서 뒤로 이동할 수 있다는 추가 요구 사항을 추가합니다.
 각 컬렉션이 실제로이 특정 요구 사항을 구현할 수있는 것은 아닙니다.
 singlyLinkedList를 생각해보십시오.이 포인터는 한 위치에서 다른 위치로 호핑하는 포인터입니다.
 이 순서를 뒤쪽으로 돌아 다니는 효율적인 방법은 없으므로 bidirectionalCollection이 될 수 없습니다.
 일단 상속을 도입하면 적합 유형 세트를 제한했지만보다 흥미로운 알고리즘을 구현할 수있게되었습니다.
 그래서,이 마지막 색인 뒤에있는 코드가 있습니다 (어디에서 작동하는지.
 그것은 매우 간단합니다.
 이제 bidirectionalCollection 프로토콜의 새로운 요구 사항을 사용하여 컬렉션을 거꾸로 걷고 있습니다.
 보다 흥미로운 알고리즘을 살펴 보겠습니다.
 자, 셔플 작업입니다.
 그래서 Swift 4에서 컬렉션을 위해 소개되었습니다.
2.
 직접 구현할 필요는 없지만 알고리즘 자체를 살펴보고 프로토콜을 의미있는 방식으로 분류하는 방법을 파악하기 위해 어떤 종류의 요구 사항이 도입되는지 살펴볼 것입니다.
 따라서 Fisher-Yates 셔플 알고리즘은 꽤 오래된 알고리즘입니다.
 그것은 또한 매우 간단합니다.
 컬렉션의 첫 번째 요소에 대한 인덱스부터 시작합니다.
 그런 다음 컬렉션의 다른 요소를 무작위로 선택하고 두 요소를 서로 바꿉니다.
 다음 반복에서는 왼쪽 인덱스를 앞으로 이동시키고, 무작위로 거기와 끝을 선택하여 해당 요소를 교체하십시오.
 그리고 알고리즘은 매우 간단합니다.
 컬렉션을 통해 선형 적으로 행해지는 것으로, 다른 요소를 무작위로 선택하여 스왑합니다.
 그리고 이것의 끝에, 당신은 멋지게 뒤섞인 컬렉션으로 끝납니다.
 따라서 여기에서 코드를 실제로 볼 수 있습니다.
 그것은 약간 관련되어 있습니다.
 그것에 대해 걱정하지 마십시오.
 그리고, 우리는 그것을 어떤 종류의 컬렉션으로 구현할 것입니다.
 여기서는 핵심 작업을 살펴 ​​보겠습니다.
 그래서, 먼저이 임의의 기능을 사용하여 콜렉션에있는 곳과 콜렉션의 끝 사이에 무작위 수를 붙잡을 수 있어야합니다.
 그러나 그것은 정수입니다.
 그리고 우리가 필요로하는 것은 컬렉션에 대한 인덱스입니다.
 우리는 그것들이 다르다는 것을 압니다.
 따라서 우리는 몇 가지 연산이 필요합니다 - 인덱스를 offsetBy--라고 부르 자, 시작 인덱스에서 우리가 선택한 위치로 빠르게 넘어 갑니 다.
 우리가 필요로하는 다른 작업은 두 요소를 교환 할 수있는 능력입니다.
 큰.
 shuffle을 구현할 수 있도록 콜렉션 개념에 추가해야하는 두 가지 작업이 있으므로 새로운 shuffleCollection 프로토콜이 있습니다.
 제발 하지마.
 그래서 이것은 우리가 보는 반 패턴입니다.
 그리고 여기서 안티 패턴은 하나의 알고리즘을 가지고 있습니다.
 우리는 그 요구 사항을 발견하고, 그 프로토콜을 단지 하나의 프로토콜로 포장했습니다. 하나의 알고리즘만을 설명합니다.
 당신이 이것을한다면, 당신은 많은 것을 가지고 있으며, 그 주위에 많은 프로토콜들이 흥미로운 의미를 가지고 있지 않습니다.
 당신은 그 프로토콜에서 아무것도 배울 수 없습니다.
 그래서, 여기서해야 할 일은 우리가 실제로 여기에 독특한 능력을 가지고 있다는 것입니다.
 그래서 셔플은 무작위 접근을 사용하고 있으며 돌연변이를 사용하고 있습니다.
 그러나 이것들은 별개이며, 우리는 그들을 분리 된 프로토콜로 분류 할 수 있습니다.
 예를 들어, randomAccessCollection 프로토콜은 인덱스를 빠르게 움직여 콜렉션을 뛰어 넘을 수있는 곳입니다.
 그리고, 당신에게 무작위 접근을 줄 수있는 unsafeBufferPointer와 같은 유형이 있습니다.
 그러나 어떤 돌연변이도 허용하지 마십시오.
 그것은 별도의 기능입니다.
 그래서 mutableCollection 프로토콜도 있습니다.
 그리고 이전에 얘기 한 singlyLinkedList와 같이 무작위 액세스가 아니라 돌연변이를 허용하는 유형을 여기에서 생각할 수 있습니다.
 이제 우리는 본질적으로 상속 계층을 분리했다는 것을 알았습니다.
 랜덤 액세스, 양방향 등의 액세스 측면이 있습니다.
 그리고 나서, 우리는이 돌연 변이를 가지고 있습니다.
 클라이언트 자체가 수행하는 일반적인 알고리즘을 구현할 수있는 여러 프로토콜을 작성할 수 있기 때문에 완벽합니다.
 그래서, 우리는 셔플 알고리즘으로 되돌아갑니다.
 그리고 self-type을 가진 randomAccessCollection의 확장으로 쓰여질 수있다.

이것은 randomAccessCollection을 준수하는 유형이며 mutableCollection 프로토콜을 준수합니다.
 이제 우리는이 두 가지 기능을 모두 활용했습니다.
 자, 여러분이 여러 종류의 규범을 따르고 많은 종류의 generic 알고리듬을 가지고 있다면 프로토콜 계층을 형성하는 경향이 있습니다.
 이제 이러한 계층 구조는 너무 커야 만합니다.
 그들은 너무 세밀해서는 안됩니다.
 도메인에 표시되는 유형의 종류를 실제로 설명하는 소수의 프로토콜이 정말로 필요하기 때문입니다. 맞습니까? 이제는 이러한 프로토콜 계층 구조를 작성할 때주의해야 할 사항이 있습니다.
 따라서 계층 구조의 맨 아래에서 맨 위로 갈수록 요구 사항이 적은 프로토콜로 이동하게되므로 이러한 요구 사항을 구현할 수있는보다 적합한 형식이 있습니다.
 이제는 계층 구조를 아래로 이동하고 계층 구조와 다른 프로토콜을 결합 할 때 고급 기능을 필요로하는보다 복잡하고보다 특수화 된 알고리즘을 구현할 수 있지만 자연스럽게 더 적은 수의 형식으로 작업합니다.
 승인.
 조건부 적합성에 대해 이야기 해 봅시다.
 이것은 Swift의 새로운 기능입니다.
 그리고 슬라이스를 다시 살펴 봅시다.
 그래서, 당신이 가지고있는 어떤 콜렉션이라도, 특정 범위의 인덱스로 서브 스크립팅함으로써 그 콜렉션의 조각을 형성 할 수 있습니다.
 그리고 그 조각은 근본적으로 컬렉션의 일부분에 대한 뷰입니다.
 자, 이것들은 당신이 조각을자를 때 얻게되는 기본 타입이며, 조각이라고 부릅니다.
 그리고 slice는 일반적인 어댑터 유형입니다.
 따라서 기본 컬렉션 형식에서 매개 변수화되며 컬렉션 자체입니다.
 따라서 조각에 대한 우리의 기대는 기본 컬렉션에 할 수있는 모든 것을 슬라이스에 할 수 있다는 것입니다.
 원하는 것은 합리적입니다.
 그래서 우리는 인덱스와 같은 순방향 검색 연산을 사용할 수 있습니다. (어디에서 술어와 일치하는 것을 찾을 수 있으며 컬렉션과 해당 컬렉션의 모든 조각에서 작동합니다.
 따라서 역방향 검색을 사용하여 동일한 작업을 수행하려고합니다. 그러나 여기에서는 문제가 발생합니다.
 따라서 버퍼가 bidirectionalCollection 인 경우에도 슬라이스가 bidirectionalCollection이라고 아무것도 선언하지 않았습니다.
 우리는 그것을 고칠 수 있습니다.
 bidirectionalCollection 프로토콜을 따르도록 슬라이스를 확장합시다.
 우리는 기본 인덱스를 기반으로 구현할 수있는 인덱스 인덱스를 구현해야합니다.
 컴파일러가 여기서 불평 할 것을 제외하고.
 우리가 기본 컬렉션에 대해 알고있는 유일한 사실은 그것이 컬렉션이라는 것입니다.
 조작 전에 인덱스가 없습니다.
 우리는이 문제를 해결하는 방법을 알고 있습니다.
 우리가해야 할 일은 기본 확장이 양방향 콜렉션이어야한다는 요구 사항을이 확장에 도입하는 것입니다.
 이것은 조건부 적합성입니다.
 모든 것은 프로토콜에 대한 적합성을 선언하는 확장이며, 그 적합성이 실제로 적용되는 제약 조건입니다.
 그리고 조건부 적합성에 대한 훌륭한 점은 이러한 프로토콜 계층 구조를 가질 때 스택이 멋지므로 해당 기본 유형이 randomAccessCollection 인 경우 해당 slice가 randomAccessCollection임을 나타낼 수 있습니다.
 자, 여기서 두 개의 다른 확장을 작성했음을 주목하십시오.
 자, 일반적으로 좋은 스타일입니다.
 확장을 작성하고, 하나의 프로토콜을 따르도록하십시오. 그러면 확장이 무엇인지 알 수 있습니다. 그 의미를 알 것입니다.
 이러한 확장에 대한 요구 사항이 다르기 때문에 조건부 요구 사항 인 적합성이 특히 중요합니다.
 그리고, 이것은 합성 가능성을 허용합니다.
 밑에있는 기본 콜렉션이 할 수있는 것이 무엇이든, 슬라이스 유형도 할 수 있습니다.
 표준 라이브러리에서도 조건부 준수의 또 다른 적용을 살펴 보겠습니다.
 그래서 범위는 Swift에서 영원히 계속되었습니다.
 그리고 예를 들어 이들을 사용하여 범위를 형성 할 수 있습니다.
.
운영보다 작습니다.
 그래서, 당신은 복식의 범위를 형성 할 수 있습니다, 당신은 정수 범위를 형성 할 수 있습니다.
 그러나 일부 범위는 다른 것보다 강력합니다.
 따라서 정수 범위의 요소를 반복 할 수 있습니다.
 글쎄, 왜 그걸 할 수 있니? intRange가 컬렉션을 준수하기 때문입니다.
 자, 타입을 실제로 본다면, 그 타입에 의해 생성됩니다.
.
미만의 운영자.
 범위 형식이라고 적절하게 명명됩니다.
 다시 말하지만, 기본 바인딩 유형에 대해 일반적입니다.
 따라서이 경우 두 배 범위의 범위가 있으며 상한 및 하한을 저장합니다.
 그것은 매우 간단합니다.
 그러나 스위프트 4 이전.
2, 정수 범위, 실제로 다른 형식에서 얻을 것이다.
 이것은 countableRange 유형입니다.
 이제 구조적으로 범위 유형과 같습니다.
 하나의 유형 매개 변수가 있습니다.
 그것은 lower와 upperBound를 가지고 있지만 바인딩 된 타입에 몇 가지 추가적인 요구 사항을 추가합니다.
 바운드가 딱딱 해지는 거지? 의미는 당신이 모든 요소를 ​​통해 걷고 열거 할 수 있음을 의미합니다.
 자, 이제는 필요한 능력에 따라 countableRange가 randomAccessCollection을 따르도록 할 수 있습니다.

그것은 .forEach 반복 루프 및 다른 것들을 가능하게합니다.
 그러나 조건부 적합성을 사용하면 물론 더 잘할 수 있습니다.
 바운드 형식이이를 준수 할 때 기본 범위 형식을 컬렉션으로 변환 해 보겠습니다.
 조건부 준수의 간단한 적용이지만 더 나은 유형 매개 변수와 함께 사용하면 범위 유형이 더 강력 해집니다.
 자, 이제 randomAccessCollection에 순응하고 있음을 주목하십시오.
 실제로 collection 또는 bidirectionalCollection에 대해서는 언급하지 않았습니다.
 무조건 조건을 준수하면 OK입니다.
 randomAccessCollection에 대한 적합성 선언은 상속받은 프로토콜에 대한 준수를 의미합니다.
 이 경우 bidirectionalCollection 및 collection.
 그러나 조건부 준수를 사용하면 실제로 오류가 발생합니다.
 이제 슬라이스 예제로 되돌아 가면 collection 대 ​​bidirectionalCollection 대 ​​randomAccessCollection의 서로 다른 계층 구조에 대해 서로 다른 제약 조건이 필요했습니다.
 그래서 컴파일러는 여러분이 이것에 대해 생각해 보았고 조건부 적합성에 대한 올바른 제약 조건을 설정했는지 확인했습니다.
 이 경우 전체 계층 구조의 제약 조건은 동일합니다.
 그래서 우리는 명시 적으로 collection과 bidirectionalCollection을 작성하여 이것이 모든 이러한 적합성이 어디에 있는지 알 수 있습니다. 또는 우리는 스타일 상 더 나은 것을 할 수 있고 다른 적합성을 분리 할 수 ​​있습니다.
 자,이 시점에서 우리의 범위 유형은 꽤 강력합니다.
 그것은 countableRange가하는 모든 것을합니다.
 그렇다면 countableRange로 무엇을해야합니까? 우리는 그것을 버릴 수 있습니다.
 이 경우 우리는 표준 라이브러리에 대해 이야기하고 있으며 실제로 countableRange를 사용하는 많은 코드가 있으므로 일반 유형 별칭으로 유지할 수 있습니다.
 이것은 정말 좋은 해결책입니다.
 따라서 제네릭 타입 별칭은 범위를 셀 수있게 만드는 데 필요한 추가 요구 사항을 모두 추가합니다.
 요구 사항을 컬렉션으로 변환해야하지만 기본 범위 유형의 대체 이름 일뿐입니다.
 코드가 여전히 countableRange를 사용할 수 있기 때문에 이것은 소스 호환성을 위해 유용합니다.
 반면에 randomAccessCollection이라는 추가 기능이있는 범위에 이름을 지정하는 것도 좋습니다.
 실제로이 코드를 사용하여 다른 코드를 정리할 수 있습니다.
 우리는 셀 수있는 범위가 무엇인지 알고 있습니다.
 이 여분의 스트라이드 기능이있는 범위이기 때문에 countableRanges를 확장 할 수 있습니다. 이는 randomAccessCollection과 일치하는 경우입니다.
 그래서 Swift 4에서 이것을 소개했습니다.
2를 사용하면 처리 할 유형 세트를 단순화하고 범위와 같은 기존 핵심 유형을보다 구성 가능하고 유연하게 만들 수 있습니다.
 승인.
 마지막 주제 하나.
 따라서 Swift는 다중 패러다임 언어입니다.
 우리는 지금 제네릭에 관해서 독점적으로 이야기 해 왔습니다.
 물론 Swift는 객체 지향 프로그래밍도 지원합니다.
 그래서 잠시 시간을내어이 두 기능의 상호 작용, Swift 언어로 함께 작동하는 방법에 대해 이야기하고 싶습니다.
 따라서 클래스 상속을 통해 클래스 상속이 어떻게 작동하는지 알 수 있습니다.
 그것은 매우 간단합니다.
 Vehicle과 같은 수퍼 클래스를 선언 할 수 있습니다.
 Taxi 및 PoliceCar와 같은 일부 하위 클래스를 선언 할 수 있습니다.
 둘 다 차량에서 물려 받았습니다.
 그리고 일단 이렇게하면 객체 지향 계층 구조를 갖게됩니다.
 하위 클래스를 사용할 수있는 위치에 대한 기대가 있습니다.
 따라서, Vehicle을 새로운 메소드로 확장하고 Drive를 들려면, 나는 그 메소드를 내 하위 클래스 인 Taxi 중 하나에서 호출 할 수 있다고 완전히 예상합니다.
 따라서 이것은 객체 지향 프로그래밍의 기본 요소입니다.
 그리고 바바라 리 스코프 (Barbara Liskov)는 80 년대 강의에서이 사실을 잘 설명했습니다.
 그 이후로, 우리는이를 Liskov 대체 원칙으로 언급했습니다.
 그리고이 아이디어는 실제로 매우 간단합니다.
 따라서 프로그램에서 Vehicle과 같은 상위 유형 또는 수퍼 클래스를 참조하는 어딘가에있는 경우 Taxi 또는 PoliceCar와 같은 하위 유형 또는 하위 클래스의 인스턴스를 가져 와서 대신 사용할 수 있어야합니다.
 그리고, 프로그램은 여전히 ​​유형 검사를 계속하고 올바르게 실행되어야합니다.
 따라서 여기서의 대체는 서브 클래스의 인스턴스이며, 수퍼 클래스가 예상되어 테스트 될 수 있어야합니다.
 그리고, 이것은 정말로 간단한 원리입니다.
 우리는 모두 그것을 내부화했지만, 또한 정말 강력합니다.
 당신이 그것에 대해 생각한다면.
 그리고 프로그램의 어느 시점에서든 잘 생각해 보면 다른 서브 클래스를 얻었을 때 어떤 일이 벌어 지는지, 아마도 여기서 생각해 보지 못한 서브 클래스 일 수 있습니다.
 그래서 제네릭으로 돌아가서 Liskov 대체 원칙을 일반 시스템에 적용 할 때 우리가 기대하는 것은 무엇입니까? 우리는 새로운 프로토콜 Drivable을 추가 할 것입니다.
 도대체 무엇이.
 그리고 차량을 연장하여 주행 가능하도록하십시오.
 우리는 무엇을 기대합니까? 음, 우리는 여러분이 그 프로토콜, Drivable에 대한 Vehicle의 적합성, 그 하위 클래스들에 대해서도 사용할 수 있기를 기대합니다.
 예를 들어, sundayDrive로 이동하기 위해 Drivable 프로토콜에 간단한 일반 알고리즘을 추가하십시오.

이제는 PoliceCar에서 API를 사용할 수 있어야합니다. 단, 이것이 최상의 아이디어는 아닐지라도 말입니다.
 따라서 여기에있는 프로토콜 준수는 서브 클래스에 의해 효과적으로 상속되고 있습니다.
 그리고 이것은 적합성에 제약을가합니다.
 당신이 쓰는 하나의 적합성, 즉 Vehicle Drivable을 만드는 것은 Vehicle의 모든 하위 클래스와 나중에 그와 함께 나오는 모든 사람들을 위해 작동해야합니다.
 대부분의 경우, 그저 작동합니다.
 그러나 실제로 하위 클래스에 새로운 요구 사항이 추가되는 경우도 있습니다.
 가장 일반적인 방법은 초기화 프로그램 요구 사항을 다룰 때입니다.
 따라서 디코딩 가능한 프로토콜을 살펴 본다면 하나의 흥미로운 요구 사항이 있습니다. 이는 디코더에서 준수 유형의 새 인스턴스를 만드는 데 필요한 이니셜 라이저 요구 사항입니다.
 우리는 이것을 어떻게 사용합니까? 자, 디코딩 가능한 프로토콜에 편의 메소드를 추가하겠습니다.
 이것은 디코더에서 새로운 인스턴스를 생성하는 정적 메소드 디코드이며, 이니셜 라이저에 필수적인 래퍼 (wrapper)가있어서 사용하기 쉽습니다.
 이 특별한 방법에 대해 알아야 할 두 가지 흥미로운 점이 있습니다.
 첫째, 그것은 자본 S로 셀프를 돌려 주는가?
 이것은 적합 형식임을 기억하십시오.
 정적 메서드를 호출하는 것과 같은 형식입니다.
 이제 두 번째 흥미로운 점은 어떻게 구현할 것인가입니다. 자, 우리는 위의 이니셜 라이저를 호출하여 우리가 가지고있는 디코딩 가능 형식의 새 인스턴스를 만든 다음 반환합니다.
 공정하다.
 우리는 차량 유형을 디코딩 가능하게 만들 수 있습니다.
 그리고 Liskov 치환 원칙을 적용 할 때 우리가 프로토콜 적합성을 통해 구축 한 새로운 API로 Vehicle의 하위 클래스를 사용할 수 있다는 것을 기대합니다.
 따라서 우리는 택시에 대한 디코드를 호출 할 수 있습니다. 우리가 얻은 것은 비히클 [비가 청의] 차량 인스턴스가 아니라 택시의 인스턴스 인 택시입니다.
 이것은 훌륭하지만 어떻게 작동합니까? 택시가 가지고 있을지도 모른 지 봅시다.
 어쩌면 여기에 시간당 요금이 있고 택시라고 부를 때도 있습니다.
디코드가 끝나면 프로토콜 초기화 과정을 거치며 실제로 호출 할 수있는 초기화 프로그램이 하나뿐입니다. 여기에는 수퍼 클래스의 Vehicle 클래스에 선언 된 초기화 프로그램이 있습니다.
 그래서 이니셜 라이저는 차량의 모든 상태를 디코딩하는 방법을 알고 있습니다.
 그러나 택시 하위 클래스에 대해서는 아무 것도 모릅니다.
 따라서이 이니셜 라이저를 직접 사용하는 경우 hourlyRate가 완전히 초기화되지 않은 문제가 발생하여 결국 청구서를받을 때 다소 불행한 오해를 불러올 수 있습니다.
 그럼 어떻게 해결할 수 있을까요? 자, 스위프트는 당신이이 문제에 빠지게하지 않는다는 것이 밝혀졌습니다.
 자동차가 디코드 가능한 프로토콜을 따르도록 만들 때이 이니셜 라이저에 실제로 문제가 있다는 점을 진단 할 것입니다.
 필요한 것으로 표시해야합니다.
 이제 모든 하위 클래스에서 필요한 초기화 프로그램을 구현해야합니다.
 직접 하위 클래스뿐만 아니라 하위 클래스도 포함됩니다. 앞으로 어떤 하위 클래스라도 알 수 없습니다.
 이제는 그 요구 사항을 추가함으로써 Taxi가 Vehicle에서 상속받을 때 동일한 이름의 이니셜 라이저를 도입해야 함을 의미합니다.
 이제는이 초기화 프로그램이 hourlyRate를 디코딩 한 다음 수퍼 클래스 이니셜 라이저를 연결하여 나머지 Vehicle 유형을 디코딩해야하기 때문에 중요합니다.
 승인.
 자, 만약 당신이 정말로 빨갛게 그 상자를 읽고 있다면, 당신은 subphrase non-final을 알아 채 셨을 것입니다.
 따라서 최종 클래스에는 하위 클래스가 없습니다.
 그래서, 그것들은 본질적으로 나중에 그들을 대체하지 못하게합니다.
 즉, 하위 클래스가 없다는 것을 알기 때문에 필요한 초기화 프로그램을 사용하는 것은 의미가 없습니다.
 따라서 최종 클래스는 디코딩 가능 또는 기타 초기화 프로그램 요구 사항을 처리 할 때 좀 더 쉽게 작업 할 수 있습니다. 이러한 초기화 메소드는 필수 초기화 프로그램이없는 이러한 규칙에서 제외되기 때문에 조금 더 쉽습니다.
 따라서 클래스를 사용할 때, 참조 의미에 대해 상속 메커니즘을 통해 클래스를 더 이상 사용자 정의 할 필요가 없을 때 final을 사용해보십시오.
 이제, 나중에 클래스를 사용자 정의 할 수 없다는 의미는 아닙니다.
 여전히 확장 기능을 작성할 수 있습니다.
 구조체 또는 열거 형을 확장 할 수있는 것과 같은 방법입니다.
 보다 동적 인 디스패치를 ​​위해 준수를 추가 할 수도 있습니다.
 그러나 final은 일반 시스템과의 상호 작용을 단순화하고 런타임에 컴파일러의 최적화 기회를 열 수 있습니다.
 그래서 우리는 오늘 스위프트 제네릭에 관해 이야기했습니다.
 Swift 제네릭의 아이디어는 정적 유형 정보를 유지하면서 코드를 재사용 할 수있는 기능을 제공하고, 올바른 프로그램을 작성하기 쉽도록하고, 효율적으로 실행되는 프로그램을 컴파일하는 것입니다.

프로토콜을 디자인 할 때는 프로토콜에 대해 작성하려는 일반 알고리즘을 밀고 당기고 프로토콜을 구현해야하는 준수 유형은 디자인을 의미있는 추출로 안내합니다.
 준수 유형의 하위 집합에서만 지원할 수있는 새 제네릭 알고리즘을 구현하기 위해 좀 더 특수화 된 기능이 필요할 때 프로토콜 상속을 도입하십시오.
 제네릭 형식을 작성할 때 특히 프로토콜 계층 구조로 작업 할 때 잘 작성 될 수 있도록 조건부 적합성.
 마지막으로 클래스 상속과 일반 시스템 사이의 까다로운 상호 작용에 대해 추론 할 때 Liskov 대체 원칙으로 돌아가서 내가 적합성을 작성한 수퍼 클래스가 아닌 하위 클래스를 도입 할 경우 여기에서 일어나는 일을 생각해보십시오.
 고마워요.
 알고리즘 채택과 더 나은 코드 작성을 돕는 방법에 대한 이해, 일상적인 프로그래밍에서 Swift 컬렉션을 효과적으로 사용하는 방법에 대한 몇 가지 관련 세션이 있습니다.
 고맙습니다.
