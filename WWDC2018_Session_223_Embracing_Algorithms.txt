안녕, 여러분.
 오늘 여기 모두 만나 뵙게되어 반갑습니다.
 나는 Dave이고 다음 40 분은 우리 프로그램이 실제로 작동하게 만드는 것을 이해하고 존중하는 것에 관한 것입니다.
 실용적인 조언이있을 것입니다. 그러나 팁과 기술 또는 특정 알고리즘에 대한 이야기는 아닙니다. 몇 가지만 살펴 보겠습니다.
 근본적인 무언가를 드러내는 것입니다. 잠재력은 이미 코드에 있습니다.
 적어도 몇 분은 프로그래밍 실천과 새로운 관계가 시작되기를 바랍니다.
 개인적으로 말하자면,이 접근법을 발견했을 때, 그것은 내 인생과 내 경력의 과정을 바 꾸었습니다.
 이것이 소프트웨어 라이브러리에 대해 많은 관심을 가지고있는 이유이기도하지만 필자가 작성한 모든 구체적인 코드에서 책임, 유지 관리 및 성능의 원천이기도합니다.
 그러나 우리가 그것에 들어가기 전에, 내 친구에게 소개시켜 드리겠습니다.
 이것은 Crusty입니다.
 Crusty는 오래된 학교입니다.
 그는 디버거를 신뢰하지 않거나 통합 된 개발 환경을 뒤적 거리지 않습니다.
 아니오, 평범한 텍스트로 된 80 x 24 터미널 창을 선호합니다. 정말 고마워요.
 자, Crusty는 최신 프로그래밍 유행에 대한 희미한 시각을 가지고 있기 때문에 때로는 그를 21 세기로 이끌 기위한 노력이 될 수 있습니다.
 그는 단지 다르게 생각합니다.
 그러나주의 깊게 경청하면, 한두 가지를 배울 수 있습니다.
 이제는 때로는 "프로그래밍과 같은 그의 숨겨진 선언문이 신비주의에 대한 실제 경계를 드러내는 경우가 있습니다.
"그리고 그를 이해하기 위해 실제로 코드를 작성하는 것이 도움이된다는 것을 발견했습니다.
 그래서 요즘 저는 Shapes라는 작은 프로그램을 연구하고 있습니다.
 완전한 기능을 갖춘 벡터 그리기 프로그램으로 만들기를 희망하지만 지금까지는 무한 캔버스에서 모양을 정렬 할 수 있습니다.
 이제는이 선택 기능을 구현하는 데 많은 것을 배웠기 때문에 삭제 선택 명령에 대해 이야기하고 싶습니다.
 나는 우리가 배열에서 물건을 제거하는 방법을 배우는 동안 아마 프로그래머로서의이 진행의 일부를 겪었을 것이라고 생각한다.
 모두 이런 식으로 일을 시작합니다.
 삭제 선택 명령입니다.
 우리는 0에서부터 셀 수까지 반복하고, 삭제할 것을 발견하면 우리는 그것을 제거하고 우리가 끝까지 걸어 갈 때까지 루프를 계속합니다.
 배열은 짧아졌지만 루프가 시작될 때 반복 횟수를 선택했습니다.
 다행스럽게도 코드를 신속하게 테스트하여 트랩 할 것이므로이 버그를 놓칠 수 없습니다.
 하지만 내가했던 것처럼이 교훈을 C 프로그래머로 배워야한다면, 그렇게 운이 좋지는 않을 것입니다.
 괜찮아.
 그래서 for 루프를 while 회 돌이로 대체하여 문제를 해결할 수 있습니다. 반복을 할 때마다 카운트를 검사 할 수 있습니다.
 그러나 이것에도 미묘한 버그가 있습니다.
 두 개의 연속 요소가 선택되면 첫 번째 요소를 제거한 다음 바로 다음 요소로 넘어갑니다.
 이제이 버그는 테스트가 실행되지 않는 한 숨겨지기 때문에 좀 더 교활합니다.
 그러나 우리가 그것을 알아 차릴만큼 운이 좋다면, 우리는 앞서 나가고 else 블록의 증가분을 지킴으로써 구현을 다시 고칩니다.
 이제 끝났습니까? 이게 맞을 까? 나는 그것이 작동한다는 것을 나 자신에게 증명할 수 있다고 생각한다.
 어쨌든,이 고난을 겪으면서 우리는 무엇을합니까? 음, 물론, 우리는 우리가 뭔가를 삭제해야 할 때마다 우리가 그것을 밖으로 산책 수있는 우리의 두뇌에이 9 라인 패턴을 잠급니다.
 이제는 많은 사람들이 제게 소리 지르는 것에서 몸살을 씻고 있습니다. 왜냐하면 훨씬 더 우아한 방법이 있기 때문입니다.
 나는이 속임수를 발견 한 날을 기억합니다. 한번 발견하면,이 9 줄 댄스를 다시는 할 수 없기 때문입니다.
 i (i)가 i 이후에 배열의 일부를 변경하기 때문에 검사 ​​할 다음 항목의 인덱스와 반복 제한이 우리 발 아래에서 계속 이동합니다.
 그러나 뒤로 이동하면 아직 변경하지 않은 배열 부분 만 반복합니다.
 매끄러운, 맞죠? 그리고 이것은 깨끗하고, 몇 달 전까지는 결코 실패하지 않았기 때문에 제가 사용 해본 패턴입니다.
 어느 날 아침, 나는 아보카도 토스트를 끝냈고, 정말 복잡한 캔버스에서 절반 정도의 모양을 삭제하려고 시도했을 때 내 앱을 속이고 있었다.
 내 iPad, 3 초 동안 얼어 붙었다.
 그래서, 나는 대나무 열 통근 컵에서 나의 절반 caf 트리플 샷 라떼 한 모금을 마셨다. 나는 나의 선택을 고려했다.
 이것은 불안했다.
 내 말은, 그것은 매우 직선적 인 동작이며, 코드는 매우 깨끗합니다. 어떻게 잘못 될 수 있습니까? 프로파일 링은 핫스팟이 바로 여기에 있음을 보여 주었지만 그 이상으로 나는 곤란을 겪었습니다.
 그래서, 그때 막 피씨는 그의 매일 양조주를 위해 현지 슈퍼마켓에서 떨어진 브랜드 커피 깡통을 들고 나 뒤에 걸어 갔다.
 "갇혔어요?" 그는 말했다.
 "그래,"나는 한숨을 쉬었다. 나는 그 상황을 설명했다.
 "글쎄, 당신도 그 문서를 보았 니?" 글쎄, 나는 가지지 않았다. 그래서 나는 Remove At, Crusty에 대한 빠른 도움말을 들었다.
 "네 문제가있다, 바로 거기에있다."그는 내 화려한 망막 디스플레이에 얼룩을 남겼다.

자, 나는 손수 제작 된 이탈리아 마이크로 화이버 천으로 지문을 조심스럽게 지워 버렸다. Crusty가 말했다. "그게 뭐야, 아들?" "글쎄, 나는 엘리먼트를 제거하는 것이 배열의 길이에 비례하는 많은 단계를 취한다는 것을 의미한다.
"배열은 다음 요소를 모두 새로운 위치로 밀어 넣어야하기 때문에 일종의 의미가 있습니다.
 "그렇다면 삭제 선택 명령은 무엇을 의미합니까?" 그는 물었다.
 "어,"나는 말했다.
 그 때 그가 mentholated 마약을 꺼내 내 책상에 줄 지어 때.
 "직접 해보십시오.
"그래서 나는 그의 질문에 대답하려고 노력하면서 그 과정을 겪었다.
 "삭제 선택은 n 단계를 수행해야하기 때문에 각 선택된 요소에 대해 한 번씩, n 개의 요소까지 선택할 수 있습니다. 따라서 총 계단 수는 n 제곱에 비례합니다.
"Crusty는 덧붙였다,"그것은 당신이 못생긴 앞으로의 길을하든 멋진 바지를 뒤로하든, 이차원입니다.
"10 ~ 20 개의 작은 테스트 케이스에 대해 몇 백 스텝 만 이야기했을뿐 아니라 단계가 빠르기 때문에 큰 것처럼 보였습니다.
 그러나 문제는 그것이 잘 확장되지 않는다는 것입니다.
 50 제곱은 2,500이고 100 제곱은 10,000입니다.
 따라서 여기이 작은 영역에서 모든 테스트를 수행하면 사용자가 볼 수는 없겠지만 사람들이 휴대 전화와 iPad를 사용하여 점점 더 많은 데이터를 관리하고 있기 때문에 확장 성이 중요한 문제입니다. 그들이 그것을 할 수 있도록 도와주세요.
 확장 성은 사용자에게 예측 가능성이므로이 점에 유의하십시오.
 그래서, 지금, 나는 그 문제를 이해했다. 그러나 나는 아직도 그것에 관해 무엇을 해야할지 잘 모르고있다.
 "이제 뭐?" 나는 Crusty에게 물었다.
 "알다시피, 꼬마 야."그는 진탕 마개를 터뜨렸다. "그 알고리즘이 있습니다.
"나는 그에게 말했다."Crusty, 나는 앱 개발자이다.
 당신은 객체 지향을하지 않는다고 말합니다.
 글쎄, 나는 알고리즘을하지 않는다.
"직업을 얻을 때가 언제인지 알기 때문에 알고리즘 수업에서 데이터 구조에주의를 기울이십시오. 면접관이 당신에게 물어볼 것입니다.
 그러나 실제 프로그래밍 세계에서 엘리트와 초보자를 구분하는 것은 컨트롤러, 델리게이트 및 응답자를 연결하여 작동 시스템을 구축하는 기능입니다.
 "Bonkey,"그는 말했다. 그가 왜 나를 컴퓨터라고 부르는 지 모르겠다. "그들은 계산합니다.
""이제는 어디에서 계산을 할 수 있습니까? ""글쎄, 나는 내 코드에서 알고리즘처럼 보이는 것은 아무것도 없다고 생각한다.
"그러나 Crusty는 그것을 가지지 않고 있었다.
 "오, 당신의 앱은 그것들로 가득차있다."그가 내 책상에 오래된 죽은 나무 사전을 떨어 뜨렸다 고 말했다.
"나는 평온함을 찾은 후에 책을 한쪽으로 조심스럽게 밀어 넣고 Define Algorithm을 Spotlight에 입력했습니다. Crusty 생각은 깔끔한 트릭이었습니다.
 흠.
 계산 또는 기타 문제 해결 작업에 따라야 할 프로세스 또는 규칙 집합입니다.
 글쎄, 생각 해보니, 대부분의 코드처럼 들리지만 여전히 확실하지 않았습니다.
 "당신은 이제까지 긴 부분을합니까?" Crusty에게 물었다.
 "이것은 알고리즘입니다.
"나는 스포트라이트를 다시 입력하기 시작했으나 그는 종이에"찍었습니다.
"나 자신을 당혹스럽게하고 싶지 않아서, 나는 주제를 나의 코드로 되돌려 놓았다.
 "흠.
"나는 성능 문제를 해결할 수있는이 마법 알고리즘은 무엇인가?"라고 물었습니다. "잠깐 동안 TTY에서 저를 보내 주시면,"어떻게이 일을합니까? 오, 트랙 패드예요.
 나는 그것을 만지지 않으려 고 노력할 것이다.
 먼저, 당신은이 어리 석음을 버립니다.
 자, 모양.
모양이 선택되면 제거됩니다.
 흠.
 크기에 대해 사용해보십시오.
"Crusty는 그의 커피 메이커의 투수를 씻어 내려고했는데, 방금 제 코드에서 무슨 일이 일어 났는지 알아 냈습니다.
 먼저 성능 문제가 해결되었음을 확인했습니다.
 좋은.
 그리고 나는 Crusty의 또 다른 기사에서 문서를 살펴보고 싶지 않았기 때문에 removeAll에 대한 빠른 도움말이 나타났습니다 (여기서 : 및 그 복잡성은 removeAt와 마찬가지로 컬렉션의 길이에 비례 함을 알았습니다).
 그러나 저는 그것을 반복 할 필요가 없었기 때문에 그것은 나의 모든 작업의 ​​복잡성이되었습니다.
 자, 나는 이것이 당신이 일종의 차이점에 대한 어떤 직감을주고 싶습니다.
 n은 알고리즘이 실행되는 시간이 문제 크기에 따라 선형 적으로 조정된다는 것을 의미합니다.
 그래프는 직선입니다.
 이제 주황색 선은 차수 n 제곱의 모양입니다.
 보시다시피, 선형 알고리즘은 작은 문제에서 더 나쁠 수 있지만, 결국 2 차 알고리즘보다 빠릅니다.
 그러나 멋진 알고리즘은 선형 알고리즘의 단계를 얼마나 비싸지 않더라도 큰 문제의 크기를 계속 살펴보면 선형 알고리즘이 승리하고 영원히 계속 승리하는 위치를 찾을 수 있습니다.
 따라서 우리는 절대 성능이 아닌 확장성에 대해 이야기합니다.
 내 확장 성 문제가 수정되었지만 표준 라이브러리가 어떻게 역방향 삭제 스키마에서 개선되었는지보고 싶었습니다.
 Crusty는 Swift가 오픈 소스이기 때문에 "hipster web"이라고 부르는 것에 끌어 올릴 수 있다고 생각했습니다. 그러나 우리 중 나머지는 GitHub로 알고 있습니다.

이제 내가 알아챈 첫 번째 점은 빠른 도움말의 근원 인 도트 주석으로 알고리즘의 기능과 복잡성을 모두 설명합니다.
 다음으로, removeAll (where)은 reg에있는 일부 메소드가 아니라는 것을 알 수 있습니다. 이것은 범용 알고리즘입니다. 이것은 다양한 컬렉션에서 작동한다는 것을 의미합니다.
 몇 가지 요소, 변경 가능한 콜렉션에서 오는 요소를 재배치하는 기능, 범위 대체 가능한 콜렉션에서 오는 길이와 구조를 변경하는 기능에 따라 다릅니다.
 그리고 그것은 다른 주문 n 알고리즘으로 만들어졌습니다.
 첫 번째는 절반의 안정된 파티션으로, 일부 술어를 만족하는 모든 요소를 ​​끝까지 이동시키고 그 접미어가 시작되는 위치를 알려줍니다.
 그것의 이름에서 반은 안정적이다. 그것은 움직이지 않는 요소들의 순서를 유지하지만 그것이 끝까지 움직이는 요소들을 뒤섞을 수 있다는 것을 나타낸다.
 이제 때때로, 그건 중요하지 않습니다. 두 번째 알고리즘은 부분 범위를 제거합니다.
 그것은 어쨌든 그들을 삭제할 것입니다.
 이 부분 범위 표기법을 모두 보았습니까? 이것은 컬렉션의 끝까지 확장되는 범위를 작성하는 매우 편리한 방법입니다.
 괜찮아.
 이제, 하위 범위 제거는 라이브러리 공개 API의 일부이므로 온라인 설명서를 찾을 수 있지만 halfStablePartition은 구현 세부 사항입니다.
 이제 우리는 모든 것을 거치지 않을 것입니다. 그러나 여기서 주목할 가치가있는 것들이 몇 가지 있습니다.
 우선, 또 다른 알고리즘 인 firstIndex (where)를 호출하여 접미사에 속한 첫 번째 요소의 위치를 ​​찾습니다.
 그런 다음 루프 변수 j를 설정하고 단일 루프가 있고 루프 인덱스 j가 각 반복마다 하나씩 앞으로 이동합니다.
 따라서 j가 요소 위에 단 하나의 패스를 만드는 것은 확실합니다.
 그로부터 순서와 복잡성을 거의 볼 수 있습니다.
 마지막으로,이 메소드는 요소를 재 배열해야하지만 콜렉션의 길이 나 구조를 변경하지 않아야하므로 변경 가능한 콜렉션 적합성에만 의존합니다.
 그래서, 제가 배운 첫 번째 교훈입니다.
 신속 표준 라이브러리의 내용에 익숙해집니다.
 문서화 된 의미와 성능 특성을 가진 알고리즘 모음을 포함합니다.
 그리고 우리는 구현을 들여다 보았지만 그렇게 많이 배울 수 있기 때문에 그렇게하지 않아도됩니다.
 공식 문서는 라이브러리를 효과적으로 사용하기 위해 알아야 할 모든 것을 알려줍니다.
 거기에 놀이터 지도서도 있습니다.
 이제 스위프트에 많은 것들이 있다는 것을 알았습니다. 그래서 그것은 힘들어 보이지만, 모든 것을 기억할 필요는 없습니다.
 거기에 무엇이 있는지, 어떻게 찾을 지에 대한 아이디어를 가짐으로써 먼 길을 취할 것입니다.
 계속 진행하기 전에, Crusty가이 변경을 수행 할 때 내 코드에서 발생한 다른 것을 지적하고 싶습니다.
 이들 중 어느 것이 그 의미를 가장 직접적으로 묘사합니까? 지금, 나는 실제로 그것을 읽고 처음부터 끝까지 생각해야합니다.
 흠.
 어쩌면 덧글을 추가하는 것이 좋습니다.
 괜찮아.
 어떻게 보이나요? 아, 그 주석이 있더라도, 역 반복은 다소 까다 롭습니다. 누군가이 코드를 이해하지 못하기 때문에이 코드를 깨기를 원하지 않습니다.
 그래서, 나는 그것을 더 잘 설명 할 것입니다.
 괜찮아.
 우리가 일을 명확히하는 동안, After 코드는 실제로 후행 클로저 구문으로 더 잘 읽습니다.
 이제 숨을 쉬어 다시보십시오.
 어느 것이 더 옳은가? 이러한 모든 주석이 있더라도 두 번째 것과 비효율적 인 점을 확인하기 위해 첫 번째 기사를 계속 읽어야합니다.
 이 알고리즘을 사용하면 모든면에서 코드가 개선되었습니다.
 그래서 이것은 지침서이며, Shawn Perin이 처음 제안한 코드에 대한 포부입니다.
 루프를 작성할 때마다 알고리즘 호출로 바꾸십시오.
 찾을 수없는 경우 알고리즘을 직접 작성하고 구현으로 루프를 이동하십시오.
 실제로 이것을 따르는 것이 지금 당신에게 비현실적으로 보일지 모르지만, 말의 끝까지, 나는 그렇게하지 않을 것이기를 바랍니다.
 약간의 동기 부여를 위해서 스파게티 코드를 마지막으로 생각해 보았을 때를 생각해보십시오.
 루프가 가득 차 있었나요? 나는 그것이 틀림 없음을 확신한다.
 괜찮아.
 완료 및 완료.
 나는 방금 코드를 더 짧고, 빠르며, 모든면에서 더 좋게 만들었습니다.
 나는 그것을 하루라고 부를 준비가되어 있었다.
 "당신의 도움에 감사드립니다, 피 각질의"나는 티타늄 카라비너를 별주 가죽 메신저 가방에 묶어서 말했습니다.하지만 그는 나를 의심스럽게 쳐다 보면서 "다른 곳에서는 그 실수를 저질렀을지도 모른다고 생각하니?" 나는 한숨을 쉬었다, 나의 가방을 내려 놓고, 나의 코드에서 고리를 사냥하기 시작했다.
 파일에 [들리지 않음]이 많이 있습니다.
 정면으로 가져오고, 돌려 보내고, 앞으로 가져 오십시오. 정면의 것 위에 선택한 모양을 홉으로 뽑습니다.
 두 번 더 해보 죠.
 선택한 도형 아래의 도형 아래에서 홉을 사용하여 뒤로 보내고 마지막으로 왼쪽의 도형 목록에서 드래그합니다.
 이제는 목록에서 연속적이지 않을 수도있는 여러 선택된 모양을 모두 조작해야한다는 것을 알기 전까지는이 소리가 정말 간단합니다.

따라서, 작동이 끝난 후에 선택한 요소를 모두 옆에 두는 것이 의미있는 동작임을 알 수 있습니다.
 따라서 모양을 앞으로 가져올 때 이웃 사람 앞에서 가장 많이 선택한 모양을 선택하고 그 뒤에 다른 모든 모양을 그룹화합니다.
 그리고 모양을 뒤로 보낼 때, 가장 가까운 선택된 모양을 이웃 뒤에 놓고 다른 모양을 그 앞에 놓습니다.
 그래서, 당신이 완전히 그것을 따르지 않았다면, 걱정하지 마십시오.
 우리는 그것으로 돌아올 것이다.
 그러나이 모든 세부 사항을 올바르게 얻으려면 꽤 조심스럽게 코드를 작성해야한다고 말하는 것으로 충분합니다.
 예를 들어, 이것은 bringToFront 였고, 충분히 보았을 때, 2 차 n 개 연산을 포함하는 도형에 대해 순서 n 루프가 있었고, 제거 (at :)와 삽입 (at :)은 이것을 나타냅니다. 그것, 제곱.
 사실, 같은 문제가 다른 네 가지 명령 모두에 나타났습니다.
 여기의 모든 구현은 배열을 반복하며 삽입과 제거를 수행합니다. 즉, 모두 2 차적입니다.
 지금, 나는이 시점에서 낙심 한 모양이었습니다. 그래서 Crusty에게 그가 저와 함께 그들을 보는지 물어 보았습니다.
 그는 "너무 늦게 머물 수는 없다"며 "나는 오늘 밤 내 무도 회장 댄스 파티를 열었지만 앞으로 나아갈 것"이라고 말했다.
"그래서, 나는 bringToFront를 끌어 올렸고, Crusty의 첫 번째 질문은"실제로 무엇을합니까? ""글쎄, "잠깐 루프가 있고 j가 삽입 점을 추적하고 우리가보고있는 요소를 추적합니다. .
""단어가 아니라 코드가 있습니다. "Crusty가 말했습니다.
 "묘사하십시오.
" "괜찮아.
 어디 보자.
 선택한 모양을 앞으로 이동하여 상대적 순서를 유지합니다.
""그 점을 주석에 적어서 다시 읽어주십시오.
"저는 초고속 타이피스트입니다.
 선택한 모양을 앞으로 이동하여 상대적인 순서를 유지합니다.
"Crusty는 말했다.
 그것이 완전히 안정적인 경우를 제외하고는 절반 정도의 안정된 파티션과 비슷하다는 것을 깨달았습니다.
 나는 흥분하기 시작했다.
 이게 뭐라고 생각하니? 그래서 나는 "안정적인 파티션"이라고 추측해야했습니다. "맞습니다.
 저의 가장 좋아하는 것 중 하나이며 Swift Open Source 프로젝트의이 파일에서 구현을 찾을 수 있습니다.
"그래서, 우리 프로젝트에 파일을 가져 왔고 Crusty는 우리가 추가 한 주석이 어떻게 그곳에 있었는지에 대해 뭔가를 중얼 거리고, 코딩하기 시작했습니다.
 알다시피, stable partition은 요소를 컬렉션의 접미사로 옮길 지 여부를 나타내는 술어를 취합니다.
 그래서 나는 물건을 뒤쪽으로 움직이는면에서 앞쪽으로 데려 오라고 표현해야했습니다.
 나는 Crusty를 보았다.
 그는 "시각화했다"고 말했다.
 그래서, 나는 내 눈을 감고 선택되지 않은 모양이 뒤쪽에 모여있는 것을 지켜 보았습니다. 그것은 내 대답을주었습니다.
 자, 우리는 단지 술어를 뒤집을 필요가 있기 때문에 sendToBack이 더 쉽다고 생각합니다.
 선택한 것들을 뒤쪽으로 보냈습니다.
 이제 나는 앞으로 가져 오는 명령을 공격하려고하고 있었고, 나는 저녁때에 그의 계획이 주어지면서 Crusty가 계속 전진하기를 갈망하지만, 그는 나를 멈추게했다.
 "너의 말을 잡아라, 스누피.
 나는 오프닝 탱고를 놓치고 싶지 않다. 그러나 그것이 규모가 될 것인지를 체크하지 않을 것인가? "그는 한 점이있어서 안정된 파티션을위한 빠른 도움말을 띄웠다. log n) 복잡성.
 그래서, (n log n)에 대해 생각하는 방법으로 log n을 살펴보십시오.
 그것은 정말로 빨리 벗어나기 시작합니다. 그리고 커질수록 커지고 느리게 커지며 상수가 될수록 가까워집니다.
 그래서, 여러분이 그것을 n으로 곱하면, 여러분은 n의 순서만큼 잘 확장되지 않는 무언가를 얻습니다.하지만 그것은 점점 커짐에 따라 점점 더 선형에 가깝습니다.
 따라서 n 번째 로그인은 n 번째 주문과 거의 같은 것으로 취급됩니다.
 나는 그것에 꽤 만족했다.
 그래서 우리는 앞으로 나아갔습니다.
 이제 앞에서 말했듯이 앞쪽에 가장 선택된 모양을 한 위치 앞으로 앞으로 가져오고 뒤에 선택한 다른 모양을 모으겠습니다.
 그러나 Crusty는 그 사고 방식을 전혀 좋아하지 않았습니다.
 "처음에는 그다지 할 일이 없는데, 폭스 트로트처럼 라인 댄스를 만드는 것입니다.
"그는 말했다."너는 필요 없어.
"내가 그를 멍청이로 바라 보았을 때, 그는 다시 사탕을 부수고 그의 다섯 자릿수를 가지고 bringForward 명령을 실행했습니다.
 "다시 보니?" 그는 물었다.
 나는 3 카드 몬테 (Monte) 카드에서 마크처럼 느껴졌지 만 함께 연주했다.
 "잘 알고 있니?" "아니.
"그는 처음 몇 번에 걸쳐 손수건을 던졌습니다.
 "지금은 어때?" 그 때가 안정적인 파티션이라는 것을 깨달았습니다.
 괜찮아.
 나는 이것을 얻었다 고 생각했다.
 전면에서 가장 선택된 모양을 찾은 다음 그 전임자로 이동하여 거기에서 시작하는 배열 섹션을 분리하면 그냥 분할 할 수 있습니다.
 "그러나 컬렉션의 일부분을 어떻게 수정합니까?" 나는 Crusty에게 물었다.
 "슬라이스에 대해 들어 본 적이 없니?" 그는 키보드를 인계 받았다고 말했다.
 "전신에서 시작하는 모양.
 그곳에.
 그걸 알고리즘에 집어 넣고 돌연변이 시켜라.

"나는 즉시 그랬다.
 따라서 일을 정확하고 효율적으로 계산하는 방법에 대한 인간의 지식은 적어도 이집트 고대 이집트로 돌아가는 수천 년 전에 컴퓨터를 선행했습니다. 컴퓨터 발명 이후이 분야에서 많은 연구가있었습니다.
 표준 라이브러리에 필요한 것이 없다면, 아마도 문서화 된 테스트와 정확성의 증거가 필요할 것입니다.
 문제 도메인에 적용되는 조사를 웹에서 검색하는 방법에 대해 알아보십시오.
 괜찮아.
 코드로 돌아 가기.
 나는이 조각에 흥미를 느꼈다. 그리고 내가 그 타입을 체크 아웃했을 때, 그것이 배열이 아니라는 것을 알았다.
 우리가 배열과 bringToFront와 sendToBack에서 안정적인 파티션을 사용 했었고 이제는 배열 슬라이스에서 사용하고 있었기 때문에 그것이 일반적이어야한다는 것을 큰 소리로 짐작했습니다.
 "당연하지.
 안정적인 파티션은 배열의 특성과 관련이 있습니까? ""그렇습니다.
 Blonkey, bringForward는 모양과 선택과 관련이 있습니다. ""글쎄, "모양에 맞춰 작동하고, 선택한 모양을 앞으로 가져옵니다.
""그 말이 맞다, 아무것도 아니다. "그는 듣지 않고 계속했다.
 "당신은 로젠지를 연속적으로 가져올 수 있습니까? 물론 할 수 있습니다.
 그래서, 그것은 모양과 관련이 없습니다.
"흠.
 "우리가 일반적인 것으로 제안하고 있습니까?" 나는 물었다.
 "조숙 한 일반화가 아닌가?" Crusty는 질문에 대한 대답으로 "음,이 방법을 어떻게 테스트 할 계획입니까?"라고 대답했습니다. "좋아,"캔버스를 만들거야.
 임의의 모양을 추가 할 것입니다.
 나는 그 중 일부를 선택하고 마침내 선택합니다.
.
.
"그러나 나는 그것이 나쁜 생각이라는 것을 알고 있었기 때문에 문장을 완성하지 못했습니다.
 만약 내가 그 모든 것을했다면, 필자는 실제로 함수를 테스트 할 것인가, 아니면 캔버스와 다양한 셰이프의 초기화 도구, addShape 메서드, 계산 된 경우 다양한 셰이프의 isSelected 속성을 테스트 할 것인가? 테스트 케이스를 구축해야하지만 이상적으로는 테스트해야하는 다른 코드에 의존해서는 안됩니다.
 내가 마름모꼴을 앞으로 가져올 수 있다면 놀이터에서 캐주얼 한 것을 할 수 있어야합니다. 이렇게하면 3으로 나눌 수있는 숫자가 나오게됩니다.
 이제, 스펙트럼의 다른 쪽 끝에서, 무작위로 생성 된 테스트 데이터를 방대한 양으로 던져서 알고리즘이 확장 할 수 있어야합니다.
 코드가 캔버스와 셰이프에 묶여있는 한 그 어느 것도 쉽지 않았습니다.
 그래서 저는 Crusty에게 자신이 옳았다는 사실을 인정하고이 비표준 bringForward를 일반적인 것으로 만들기 시작했습니다.
 첫 번째 단계는 Canvas에서 캔버스를 분리하여 모양 배열로 옮기는 것입니다.
 물론,이 배열은 모양이기 때문에 모양을 자체로 바꾸어야합니다. 그런 다음 주어진 모양을 앞으로 가져와야하는지 여부를 나타내는 조건자를 전달하여 선택에서 분리했습니다.
 그리고 모든 것은 계속 편집되었습니다.
 굉장해! 이 시점에서 모양에 의존성이 없다는 것을 알게되어 만족 스러웠습니다. where 절만 삭제할 수있었습니다.
 멋지다, 나는 생각했다.
 자, 나는 어떤 배열을 가져올 수 있습니다.
 모퉁이에서 차차 차를 조용히 연습하고 있었던 피 각질의 모습을 살펴 봤지만, 끝내 었다고 생각하지 않았습니다.
 "앞으로 가져올 것은 배열과 관련이 있습니까?" 그는 물었다.
 "글쎄, 아무것도,"나는이 부양을 제거하는 방법에 대해 한숨을 내 쉬고 생각하기 시작했다.
 여기에 안정적인 파티션이 있습니다.이 파티션에는 변경 가능한 컬렉션 준수가 필요합니다.
 그래서, 아마도 나는 그것을 변경 가능한 컬렉션으로 옮길 것입니다.
 흠.
 분명히 인덱스 유형이 Int와 일치하지 않는다고 생각했습니다.
 괜찮아.
 그래서, 이것에 대한 간단한 해결책이 있습니다, 그렇죠? 이거 해 봤니? 이러지 마.
 그것은 컴파일되었지만 Crusty는 갑자기 춤을 추지 못했고, 나는 뭔가 잘못되었다는 것을 알았습니다.
 "뭐?" 나는 말했다.
 "신인들은 항상 그렇게한다."Crusty는 머리를 흔들면서 말했다.
 "우선, 어레이 슬라이스에 대해 0이 될 것입니다.
 배열 조각을 알고 계셨습니까? 인덱스가 0에서 시작하지 않습니까? 모든 슬라이스의 인덱스는 슬라이스 된 기본 콜렉션의 해당 인덱스부터 시작합니다.
 슬라이스를 사용하여 일반 알고리즘을 구성 할 수 있기를 원한다면이 관계가 중요하므로 매우 중요합니다.
"음,이 문제는 해결할 줄 알았습니다.
 시작 인덱스와 비교해보십시오.
 그러나 실제 문제는 "bringForward는 정수 인덱스를 가지고 무엇을해야합니까?" 나는 방해했다.
 "그래, 알아.
""글쎄, 나는 빼기와 함께 할 수있는 인덱스를 가져야한다.
"Crusty가 한숨을 쉬고 다시 마름모꼴을 만들었습니다.
 그런 다음 책상 위에 손가락 두 개를 놓고 오른쪽 손이 첫 번째 녹색 마름모꼴을 가리킬 때까지 걸어갔습니다.
 "전체 무용의 후진적인 단계는 아닙니다.
 Crusty가 나에게 새로운 알고리즘을 보여준 것을 깨달았습니다.
 하나의 indexBeforeFirst라고 부르 자.
 "자, 여기있는 속임수는 누군가가 이미 당신을 위해 그것을 썼다고 가정하여 초점을 유지하는 것입니다.
"그는 그런 식으로 우리가 필요로하지 않는 모든 코드를 해킹하기 시작했습니다.

"전임자는 술어가 만족되는 첫 x 째 전의 색인입니다.
 자, 읽는 것이 얼마나 예쁜 지보세요.
"자, 당신이 그것을 본다면, 그가 옳았다는 것을 알 수 있습니다.
 모양, 선택, 배열 및 정수에 대한 관련성없는 세부 정보를 모두 제거하면 문제의 핵심 요소 만 트래 피킹하기 때문에 더 명확한 코드가 표시됩니다.
 "이미 indexBeforeFirst가 어떻게 작동하는지 보여주었습니다.
 당신이 그것을 쓸 수 있는지 보아라. "그는 말했다.
 그래서, 나는 처음으로 제대로했기 때문에 지금 당장 잡으려고하고 있다고 생각합니다.
 나는 너에게 말했어, 나는 초고속 타이 피스트 야.
 괜찮아.
 따라서 후미가 술어와 일치하는 첫 x 째 색인을 리턴하십시오.
 나는 이것이 얼마나 잘 가고 있는지 꽤 흥분했다.
 "좋아, 피 각질의,"나는 말했다, "다음을 해보자.
""너는 무언가를 잊지 않는거야, 본 키? "그는 물었다.
 나는 그가 무슨 말을하고 있는지 몰랐다.
 코드가 깨끗하고 작동했습니다.
 "의미론, 아들.
 이것이 의미하는 바를 모르는 경우 다른 코드에서이 코드를 어떻게 사용해야합니까? "그리고 그 때가 새로운 알고리즘을 사용할 때마다 깨달았을 때, 우리는 그의 문서에 의지하여 의미와 효율성에 대한 결론을 이끌어 냈습니다 우리 코드의
 그리고 대부분의 알고리즘은 다른 알고리즘으로 만들어지기 때문에 같은 것을 의지합니다.
 최근에 나는 인턴을 인터뷰하고 문서 작성의 역할에 대해 물었고 그는 잊지 않을 문구부터 시작했습니다.
 "오, 정말 중요합니다."그가 말했다.
 "우리는 이러한 추상화 타워를 건설하고 있습니다."그리고 저는 지금 말하고 있습니다. "우리가 계속해서 아래 층을 검사하지 않고 구축 할 수있는 이유는 우리가 구축 한 부품이 문서화되어 있다는 것입니다.
"이제 앱 개발자로서 시스템 프레임 워크, DOS 및 물리 법칙에 의존하는 하드웨어로 확장되는 탑의 맨 위에서 작업하고 있습니다.
 그러나 당신이 당신의 방법 중 하나를 부르는 순간, 그것이 당신의 기초의 일부가됩니다. 그래서 코드를 문서화하십시오.
 인턴은 고용 된 상태입니다. 그는 바로 거기에 앉아 있습니다.
 그래서 힌트를 얻었고 Crusty의 새로운 알고리즘을 문서화했습니다. 즉, 구현에 대해 잊어 버리고 사용 만하면 Quick Help에 필요한 모든 것이 있다는 것을 알았습니다.
 이제는 bringForward에 대해서도 설명했습니다.
 시원한! 이제, 모든 문제를 해결하는 것처럼 보였으므로이 시점에서 stablePartition 내부에서 어떤 일이 일어나고 있는지 궁금합니다.
 정말 아름답고 유익한 알고리즘이기 때문에 좋은 결과를 얻었습니다.
 공용 메서드는 컬렉션 수를 가져 와서이 도우미로 전달합니다.이 도우미는 나누기 및 정복 전략을 사용합니다.
 먼저 카운트가 2보다 작 으면 기본 케이스를 처리합니다.
 파티션 포인트가 콜렉션의 시작 부분에 있는지 아니면 마지막에 있는지를 알아 내면됩니다.
 다음에는 컬렉션을 두 개로 나눕니다.
 이제, 왼쪽과 오른쪽 절반을 안정적으로 분할하기 때문에 알고리즘이 작동한다는 점을 일시적으로 믿어야합니다.
 자,이 두 끝을 살펴보면, 모든 것이 정확한 위치에 있다는 것을 알 수 있습니다. 그러나이 중앙 섹션에는 교환해야 할 두 부분이 있습니다.
 이제는이 예제 에서처럼 길이가 항상 같지는 않을 것이며, 다행스럽게도이를위한 알고리즘이 있습니다.
 회전이라고 부릅니다.
 괜찮아.
 여기서는 회전하지 않을 것이지만 실제로는 아주 아름답습니다. 관심이 있다면 안정된 파티션과 동일한 파일에서 구현을 찾을 수 있습니다.
 괜찮아.
 도형으로 돌아갑니다.
 이제이 혼란은 도형 목록에서 끌기를 구현했으며 항상 가장 복잡하고 버그가 많은 작업 중 하나였습니다.
 이 전략은 임시 버퍼를 할당하는 것이 었습니다. 그런 다음 삽입 점 앞에있는 모양 위로 반복하고 선택한 점을 추출한 다음 삽입 점을 조정 한 다음 삽입 점을 조정하지 않고 나머지 점을 개별적으로 반복하여 선택한 점을 추출합니다.
 그리고 마지막으로 그들을 다시 삽입하십시오.
 솔직히, 나는 내가 마침내 그것이 옳았다 고 생각했기 때문에 코드를 만지는 것이 조금 두려웠다.
 마지막으로 새로운 버그를 발견 한 지 거의 일주일이 지났습니다.
 하지만 지금은이 과정을 매우 잘 수행 했으므로 한 번에 모든 작업을 시각화 해 보았습니다.
 이봐, 익숙해 보여.
 다시 보자.
 흠.
 먼저이 작업을 수행하고 부품을 별도로 처리한다고 가정합니다.
 맞습니다.
 이것은 거꾸로 된 술어가있는 두 개의 안정된 파티션입니다.
 그래서 일반적인 알고리듬은이 두 줄로 쓰러졌습니다. 여기 캔버스에 남아있는 것이 있습니다.
 자, 오래된 코드 옆에있는 것을 보자.
 그렇게 나쁘지는 않지만 재사용 가능한 효율적인 문서화 된 범용 알고리즘이 있습니다. 이는 탁월합니다.
 괜찮아.
 따라서 이것은 응용 프로그램 도메인에 특정한 세부 사항을 살펴보고 코드가 근본적으로 수행하는 것을 확인한 다음 재사용 가능한 일반 코드로이를 캡처하는 기술입니다.
 연습이 필요합니다.

그래서, 왜 귀찮게합니까? 실용적인 대답은 관련없는 세부 정보와 분리되어 있기 때문에 일반 알고리즘은 재사용 성이 뛰어나고 테스트 가능하며 비 제너릭 알고리즘보다 훨씬 명확합니다.
  그러나 프로그래밍을 정말 좋아하는 사람이라면 누구에게나 보람이 있다고 생각합니다.
  진실과 아름다움을 추구하는 것이지 만 실제 하드웨어의 제약으로 당신을 정직하게 유지할 수 있기 때문에 어떤 추상적 인 건드리지 않는 진리는 아닙니다.
  피 각질의 말처럼, "프로그래밍은 실제를 드러내줍니다.
"따라서 유형 및 응용 프로그램 아키텍처에 대해 진지하게 생각하는 모든 권리와 의무를 지닌 최고의 시민으로 계산을 처리하십시오.
  그것을 식별하고, 이름을 부여하고, 단위 테스트를하고, 의미 및 성능을 문서화하십시오.
  자, 저는 Shawn Perin이 보았던 충고를 전 문맥에 넣어서 닫고 싶습니다.
  "조직의 코드 품질을 향상 시키려면 모든 코딩 표준을 하나의 목표 인 No Raw Loops로 대체하십시오.
" 고맙습니다.
