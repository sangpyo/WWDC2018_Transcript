안녕하세요.
 환영.
 내 이름은 켄 페리 야.
 오늘 Kasia Wawer와 저는 Auto Layout에서 성능에 대해 이야기 할 것입니다.
 지난 번 내가 Auto Layout에 관해 이야기 할 때 우리가 처음 소개 한 2011 년이었습니다.
 오늘 여기에서 여러분과 이야기를 나눌 수있어서 정말 기쁩니다.
 OK, 자동 레이아웃.
 이것이 Mac에서 iOS에 콘텐츠를 배치하는 방법입니다.
 우리가 알고있는 주요 객체는 뷰와 제약 조건, 뷰 간의 관계를 제공하는 제약 조건입니다.
 퍼포먼스에 관해서라면, 두 가지 버튼 사이의 거리를 20으로해야한다고 말하면, 머신이 수행하는 단계별 프로세스를 이해하는 것이 어려울 수 있습니다. 즉, 성능에 대한 기대를 이해하고 무엇이 빠르고 그렇지 않은지, 일반적으로 어떻게 작동 하는지를 이해하는 것이 어려울 수 있음을 의미합니다.
 이것이 우리의 목표입니다.
 일이 어떻게 진행 될지에 대해 좋은 느낌을 가지기 위해서는 그것을 정말로 이해해야합니다.
 그래서 우리는 iOS 12를 위해이 릴리스에서 수행 한 작업 중 일부를 먼저 보여줌으로써 작업을 시작할 것입니다.
 우리는 많은 일을 해왔습니다.
 그것이 끝나면 우리는 제가 이야기하고있는 단계별 이해를 구축하려고 노력할 것입니다.
 그래서 우리는 좋은 직감과 좋은 성과를 기대합니다.
 그렇게하기 위해 우리는 내부적으로 들어가는 아주 특별한 것을 할 것입니다.
 그러니 즐겨주세요.
 마지막으로, 성능에 대한 우리의 직감에만 의존한다면, 그것은 잘 풀리지 않을 것입니다.
 그래서 우리는 다음을 보게 될 것입니다 - Kasia가 인계 받아 코드를 분석하고 직감을 병합하는 법을 보여줄 것입니다.
 그러나 그것에 도달하자.
 먼저 Apple 프레젠테이션의 전통처럼, 우리는 수많은 숫자를보고 자랑 할 것입니다.
 여기서 우리가 바라는 것은 벤치 마크입니다.
 그래서 우리가이 작업에 접근 한 방법은 우리가 나가서 우리의 앱뿐만 아니라 수많은 제 3 자 애플리케이션을 보았습니다. 그리고 우리가 보았던 것을 테스트 사례로 분리하여 벤치 마크 할 수있었습니다.
 여기서 우리가 바라 보는 부분은 자체 크기 조정 셀이있는 UICollectionView이며 iOS 11이 좋지 않은 것 같습니다. 이는 janky와 bad가 잘 보입니다.
 그리고 iOS 12에서는 완벽합니다.
 전체 프레임 속도를 맞추고 있습니다.
 이것이 우리가 살펴본 사례 중 하나입니다.
 다음은 몇 가지 샘플링 샘플입니다.
 우리에게는 많은 것이 있습니다.
 이 것들은 항상 있습니다.
 그래서 당신이 바라는 것은 회색 막대가 iOS 11이라는 것입니다.
 iOS 11에 걸린 시간과 파란색은 iOS12입니다.
 그래서 당신이 이것을 취하는 것은 우리가 일을 훨씬 더 좋게 만들 수있는 많은 장소를 발견했다는 것입니다.
 그러면 앱이 향상됩니다.
 그건 내가 바라는 당신을 위해 좀 더 나은 것들을 만들 것입니다.
 이것은 모든 방법으로 스택을 위아래로 이동합니다.
 그래서 그 중 일부는 절대적으로 모든 것에 영향을주는 진정한 배짱에 있습니다.
 일부는 UI 키트로 옮겨 가고 있습니다.
 일부는 자동 레이아웃을 사용하는 사람들을 위해 클라이언트 계층에 있습니다.
 예를 들어 UICollectionView 벤치마킹을 살펴보면 모든 것이 그 중 하나입니다.
 UICollectionView가 자동 레이아웃을 사용하고 그로 인해 더 많은 성능을 얻는 방법에 실제로 중요한 변경 사항이 많이 포함되어 있습니다.
 나머지 이야기는 어느 쪽이 당신이 그렇게 할 수있는 좋은 방법입니다.
 어떻게 적절하게 사용하는지.
 우리가 이러한 것들을 경험할 때 나는 많은 시간을 생각합니다. 우리가 이러한 모든 개선을 할 수 있었던 이유는 사물이 어떻게 결합되고 어떻게 수행되는지, 어떻게 작동하는지에 대한 좋은 정신 모델을 가지고 있다는 것입니다.
 우리는 당신이 그 모델을 개발하는 것을 도우려고합니다.
 프레임을 만들기 위해 예제 코드, 일부 클라이언트 코드를 살펴 보겠습니다. 일부 문제가 있으며 그 이유를 논의 할 것입니다.
 그래서 코드에이 특별한 문제가 있거나 없을 수도 있지만 우리는 모든 클라이언트 응용 프로그램을 살펴볼 때 가장 많이 보인 것을 선택했습니다.
 그러나이 특별한 문제가 없다고해도, 우리가해야 할 일은 모두에게 의미가 있으며 거의 ​​모든 사람에게 새로운 의미를 지니게됩니다.
 그럼 해보 죠.
 이것은 우리가 진행할 것이므로이 레이아웃을 생성 할 것입니다. 분명히 매우 간단합니다.
 종종 나는 인터페이스 빌더에서 이것을 빌드 할 것이라고 생각한다.
 좋은 생각 이군요.
 우리가 가고 싶어하는 성능 문제를 완전히 막을 수있는 좋은 생각입니다.
 우리가 그렇게하지 않았다고 가정 해 봅시다.
 우리가 이렇게 만들었다 고 가정 해 봅시다.
 먼저 살펴 보겠습니다. 분석을 시작하기 전에이 코드의 내용을 살펴 보겠습니다.
 먼저 UIView 메서드 인 updateConstraints를 오버 라이딩합니다.
 그래서 우리는 그것에 대해 이야기 할 것입니다.
 다음으로 myConstraints라는 Ivar가 있습니다.
 그리고 우리는 변수에서 모든 것을 취하고 모든 제약을 비활성화합니다.


그런 다음 방금 만든 레이아웃을 구현하는 제약 조건을 만듭니다.
 그것은 매우 간단합니다.
 시각적 형식 언어를 사용합니다.
 그런 다음 이러한 제약 조건을 활성화하고 설치하고 마지막으로 super를 호출합니다.
updateConstraints는이 메서드가 수행하는 UIView 수준 구현이 제대로 작동하기 때문에 수행해야 할 중요한 작업이었습니다.
 좋아요, 그것이하고있는 일과 작동하는 기본 구조입니다, 그것은 기능입니다.
 그러나 성능을 이해할 수 있도록 지금 구체적으로 무엇을하는지 이야기 해 봅시다.
 따라서 이해해야 할 첫 번째 점은 정확히 updateConstraints라는 것입니다.이 메서드는 재정의합니다.
 글쎄, Render Loop의 한 구성 요소입니다.
 Render Loop는 매초 120 회 실행되는 프로세스입니다.
 이렇게하면 모든 콘텐츠를 각 프레임에 사용할 준비가됩니다.
 좋습니다. 따라서 제약 조건, 레이아웃 및 표시 업데이트의 세 단계로 구성됩니다.
 먼저 뷰를 필요로하는 모든 뷰는 updateConstraints를받습니다.
 그리고 그것은 대부분의 잎에서보기 계층까지 창을 향해 달립니다.
 그런 다음 모든보기는 레이아웃 하위보기를받습니다.
 이것은 나뭇잎을 향해 내려가는 창에서 시작하여 반대 방향으로 진행됩니다.
 마지막으로, 모든 뷰가 필요한 경우 그리기를 얻습니다. 그런 종류의 것입니다.
 좋아,이게 뭐야? 왜 존재합니까? 글쎄요, 그들은 모두 똑같은 목적을 가지고 있고, 그것들은 정확한 병렬 세트를 가지고 있습니다.
 그리고 그 목적은 낭비되는 일을 피하는 것입니다. 제가 예를 들어 설명 할 수 있습니다.
 따라서 레이블, UI 레이블에는 텍스트 크기를 나타내는 제약 조건이 있어야합니다. 그러나 그 크기에 기여하는 많은 속성이 있습니다.
 텍스트 속성 자체, 글꼴 및 텍스트 크기 등이 있습니다.
 이를 수행하는 한 가지 방법은 해당 속성 중 하나가 변경 될 때마다 텍스트를 다시 측정하는 것입니다.
 그러나 대개 이러한 일련의 행을 연속적으로 변경하기 때문에 이는 종종 비효율적입니다.
 라벨을 처음 만들 때는 아마이 속성 설정자를 불러올 것이고 각각의 텍스트를 다시 측정한다면 중간의 것들은 모두 낭비됩니다. 끝.
 이것이 렌더 루프가 제공하는 것입니다.
 대신에 set font 내부에서 setNeedsUpdateConstraints를 호출하면 프레임이 화면에 표시되기 전에 끝에 제약 조건을 적용 할 수 있습니다.
 그것이 바로 그 때문입니다.
 따라서 우리가 계속하기 전에 이것으로부터 이해해야 할 몇 가지 사항은 1 초에 120 프레임을 초당으로 실행합니다.
 둘째 평행이야.
 그래서 직감에도 사용할 수 있습니다.
 레이아웃 패스를 이해하거나 느낌이 들었다면, UpdateConstraints에 대해 생각하고 있거나 디스플레이에 대해 생각하고있을 때와 같은 거래가 가능합니다.
 그리고 마지막으로 그것이 존재하는 모든 이유는 낭비되는 작업을 피하고, 작업을 연기하고, 완전히 건너 뛸 수있게하는 것입니다.
 좋습니다, 우리는 이제이 방법의 나머지 부분을 분석 할 수있는 위치에 있다는 것을 보았습니다.
 우리가 어떻게되는지 확인하십시오. 호출 될 때마다 제약 조건을 비활성화하고 다시 새로운 제약 조건을 활성화합니다.
 우리는 이것이 layoutSubviews와 유사하다고 말하고 있습니다.
 따라서 우리가 layout Subviews에서 analog와 똑같은 코드를 작성했다면, 마치 여러분이 모든 Subviews를 파괴 한 후에 layoutSubviews가 호출 될 때마다 처음부터 다시 작성한 다음 다시 추가했을 것입니다.
 그리고 저는 많은 사람들이 아주 잘 수행 할 수없는 완전히 정확한 직감을 가지고 있다고 생각합니다.
 그래서 실제로 얻는 것은 그것이 동일하다는 것입니다.
 당신이 취하는 직감이 무엇이든간에 그것은 구속 조건을 업데이트하는 데에도 적용됩니다.
 당신이 그런 제약을 허물고있을 때 당신은 많은 여분의 일을하고 있습니다.
 어떻게 해결할 수 있니? 글쎄, 당신은 - 우리가 말했던 것처럼, 당신이 한 번 이상 그것을하지 않고 있는지 확인해야합니다.
 연기하는 것입니다.
 그래서 이런 식으로해야합니다. 우리는 이미이 일을 했습니까? 우리가 그랬다면 전혀 아무것도하지 마라.
 아직 수행하지 않았다면 이러한 제약 조건을 한 번 설정하십시오.
 그리고 그게 잘 될거야, 알았지? 다시 말하지만 이것은 실제로 클라이언트 코드에서 볼 수있는 가장 일반적인 오류입니다. 이는 우리가 제약 조건을 변경한다고합니다.
 불필요하게 그들을 찢어 버리고 다시 되돌려 놓습니다.
 큰 확인.
 우리는 더 많은 일을 할 것이지만 잠시 후에 Render Loop에 대해 조금 생각해 볼 것입니다.
 렌더링 루프는 실제로 필요하다면 훌륭합니다.
 그 목적은 중복 작업을 피하는 데 정말 유용합니다.
 그러나 그것은 자주 실행되기 때문에 위험합니다.
 매우 민감한 코드입니다.
 따라서 대개 민감한 코드에 대해이 작업을 수행하려는 경우에는 그렇지 않습니다. 작성하는 경우주의해야하지만 민감한 코드를 작성하는 빈도를 최소화해야합니다. 아마 망쳐 버릴거야.
 우리 모두가 할.

그래서이 경우, 실제로 당신이 될 수도 있습니다, 당신은 정말로 한번 다시 할 수있는 것처럼 다시 생각해야합니다. 그리고 그것을 updateConstraints에 넣지 않았습니까? 인터페이스 작성기를 사용하는 것도 좋은 방법입니다.
 Interface Builder를 사용할 수 있다면 그렇게해야합니다.
 모든 종류의 이유에서 좋습니다.
 그것은 당신을 좋은 길로 인도합니다.
 좋습니다.
 우리는 이제 그것에 대해 이야기했습니다.
 왜 우리는 문제가 있는지, 적어도 유추 하위 사용에 대해서는 어느 정도 이해하고 있다고 생각합니다.
 그러나이 대화의 목적을 위해 우리는 그것보다 더 잘하고 싶습니다.
 우리는 이것이 나쁜 것이라고 말하고 싶지 않습니다.
 우리는 그것을 실제로 이해하고 그 과정을 이해하기를 원합니다.
 그렇게하기 위해 이제 덮개를 벗겨서 실제로 일어나는 것을보기 시작합니다.
 따라서 이러한 제약 조건을 활성화 할 때 제약 조건을 추가 할 때 발생하는 프로세스는 무엇입니까? 그것을 높은 수준에서 도표화합시다.
 따라서 제약 조건을 추가하는보기 인 경우이보기는 창에 있습니다.
 창을 숨기면 엔진이라고하는 내부 개체가 있습니다.
 그리고 엔진은 자동 레이아웃의 계산 핵심입니다.
 제약 조건이 추가되면 제약 조건에 해당하는 방정식을 만들고 엔진에 방정식을 추가합니다.
 다이어그램에서 마지막으로 이해할 수있는 것은 방정식이 변수가있는 변수에 관한 것입니다. 방금 방정식을 건네면 X에 대해 풀이를 말하면 X는 변수입니다.
 이 경우 해결해야 할 사항은보기의 프레임 데이터입니다.
 따라서 모든보기에 대해 최소 X, 최소 Y, 너비 및 높이의 네 가지 변수가 있습니다.
 자, 이제이 과정을 시작해 보겠습니다.
 그래서 이것이 우리가 할 레이아웃이었습니다.
 단순성을 위해 수평 제약에 초점을 맞출 것이지만 그 과정을 따라갈 것입니다.
 그래서 우리가 말한 것처럼 일어나는 첫 번째 일은이 방정식을 만드는 것입니다.
 이들은 꽤 똑바로 전달됩니다.
 가장 흥미로운 점은 두 개의 텍스트 필드 사이의 간격이 매우 제한적이라고 생각하는 것처럼 보입니다. 그러나이 변수의 관점에서 보면 다소 낮은 수준입니다.
 그렇다면 각 방정식을 엔진에 추가해야합니다.
 그리고 우리는 실제로 성능 특성에 대한 좋은 느낌을 갖는 목표로이 프로세스를 다시 수행 할 것입니다.
 우리가이 일을하면 어떻게 될까요? 따라서 엔진은 이러한 변수를 풀려고합니다. 이는 대수학에서했을 수도 있고 실제로 똑같은 것으로 보입니다.
 그럼 따라가 봅시다.
 첫 번째 방정식은 minX가 8이라고 가정합니다.
 시원한.
 폭은 100입니다.
 좋아,이 때 우리는 두 번째 필드의 minX가 첫 번째 minX에 너비 + 20을 더한 것과 같다고 말합니다.
 만약 당신이 이러한 변수들을 풀어달라고 누군가에게 물었다면 당신은 대수학에서 무엇을 할 것입니까? 당신은 당신이 이미 그곳에 있었던 것들을 대체 할 것입니다.
 그리고 그것은 정확히 일어날 것입니다.
 프로파일 링 중일 경우, 우리는 코코아 코드 프로그래머이기 때문에 대체 문자와 다른 140자를 포함하는 진정한 방법이 엔진에 있음을 알 수 있습니다.
 그러나 그것이 그것이 할 일입니다.
 그리고 나서, 여러분도 알다시피, 마지막 방정식이 들어옵니다.
 이 경우 적어도 변수를 해결해야만하는 모든 작업이 그 것처럼 보입니다. 사실입니다.
 이 시점에서 제가 이해하고자하는 것은 그것이 일어나는 일이 둘 다 매우 복잡하지 않다는 것입니다.
 당신이 손으로 그것을하는 경우에 당신이 할 것 인 것에 아주 아주, 매우 밀접하게 대응합니다.
 그리고 비싼 것도 아닙니다.
 이런 식으로 대체하는 것입니다.
 그것이하는 일입니다.
 좋습니다. 이제는 엔진에서 이러한 변수에 대해 해결 된 일종의 레이아웃이 있지만 레이아웃이 아닙니다.
 그럼 그 과정을 끝내자.
 나머지 프로세스에서는 엔진 정렬을 통해 이러한 변수 중 하나에 값을 할당 할 때마다 변수가 왔음을 알려주고이를 변경했습니다.
 이에 대한 견해는 무엇을 할 것인가? 글쎄, 잠깐 생각하면 Superview라고 부르며 움직여야하기 때문에 setNeedsLayout라고해라.
 좋습니다. 업데이트 제약 조건의 일부로 모든 일이 발생했습니다.
 이제는 setNeedsLayout 만 수신하므로 레이아웃 단계로 넘어갑니다.
 그런 다음 OK를 클릭하면 퍼즐의 마지막 부분이 표시됩니다. UIView는 레이아웃을 수신 할 것입니다. 하위보기는 엔진에서 해당 데이터를 프레임으로 복사하는 것입니다.
 그래서 그것은 엔진을 말할 것입니다, 그 변수들에 대한 가치는 무엇입니까? 엔진은 그것을 말할 것이고, Setview를 setview에서 호출 할 뷰의 set Superview를 호출 할 것입니다.
 이것이 전체 프로세스입니다.
 그러니 잠시 뒤로 물러나서 잠시 생각하십시오.
 마찬가지로 Layout의 단계별 프로세스입니다.

내재화하려고 시도 할 수 있고 그것에 대한 느낌을 얻으려면이 물건에 대한 기대치에 대해 훨씬 더 잘 느끼게 될 것입니다.
 사실 이제는 어떻게되는지 보도록하겠습니다. 이제 이것을 살펴보면서이 방법을 살펴보면 제약 조건을 비활성화하고 제약 조건을 다시 활성화한다는 것을 보았 기 때문에 방금 수행 한 작업에 대해 생각하고 엔진이 무엇을 하려는지 생각해보십시오.
 그것은 이렇게 보일 것입니다.
 우리는 휘젓는 다. [웃음].
 따라서 각각의 작업은 비용이 많이 들지는 않지만 많은 작업을 수행하며 완전히 불필요합니다.
 이 일은 낭비입니다.
 그래서 당신이 이것을 마음 속으로 느낄 수 있다면, 당신이 이것을 할 때 일어나는 일이라고 당신이 정말로 느낄 수 있다면, 당신은 좋은 모양이 될 것입니다.
 그렇다면 그것은 당신이 우리가 통과해야 할 동일한 입장에있게 될 것이고 실제로 이것에 대해 좋은 느낌을 갖게 될 것입니다.
 좋아요, 그게 좋겠다.
 우리가 다루고 싶은 또 하나의 큰 주제가 있습니다.
 우리가 실제로 좋은 성능 모델을 원한다면 자동 레이아웃과 함께 사용하는 것에 대해서만 비용을 지불하는 아이디어입니다.
 그리고 이것을 보았을 때, 우리는 그것이 의미하는 것을 이해할 수있는 좋은 위치에 있다고 생각합니다. 이렇게하기 위해, 우리가 이전에 가진 상황을 두 배로했다고 가정 해 봅시다.
 그래서 두 개의 독립적 인 계층 구조에 네 개의 텍스트 필드가 있습니다.
 이제 당신이 할 수있는 일은 이렇게 계층 구조를 가로 지르는 제약을 만들 수 있다는 것입니다.
 즉, 동일한 Superview가 없더라도 텍스트 필드 3은 텍스트 필드 3과 정렬되어야한다고 말할 수 있습니다.
 나는 때때로 사람들은 언제나 어떤 것에도 영향을 미칠 수 있기 때문에 상황이 일반적으로 매우 느릴 것이라는 의미에서 가능한 한 진흙과 성능의 거대한 구슬 일 가능성이 높다는 인상을 가지고 있다고 생각합니다.
 좋습니다. 그러나 우리가 보았던 것을 보았을 때, 당신이하지 않는 대부분의 시간 때문에 당신이 이것을 가지고 있지 않은 일반적인 경우에 어떤 일이 일어나는지 봅시다.
 대부분의 시각은 부모와 형제 자매에게만 제한됩니다.
 여러분이 볼 수있는 것은 두 개의 독립적 인 블록이 있기 때문에 엔진 내부를 보면 서로 상호 작용하지 않는 두 개의 독립적 인 방정식 블록이 될 것입니다. 중복 변수.
 그들이 할 일은 완전히 겹치지 않기 때문에 상호 작용하지 않는다는 것입니다.
 그리고 우리가 이것들 중 하나를 가지고 있다면 그것은 처리하는데 어느 정도 시간이 걸릴 것입니다.
 우리가 그들 중 두 개를 가지고 있다면 그들은 서로 아무 상관이 없기 때문에 단지 두 배의 시간이 걸릴 것입니다.
 그 중 3 명, 3 번 등, 요점은 당신이 선을 보게 될 것입니다.
 선형 성능을 보게 될 것입니다. 이것은 최상의 성능입니다.
 이런 종류의 일에 완벽한 표시입니다.
 그래서 저는 이것을 다시 강조하고 싶습니다. 선형적인 이유는이 조각들 사이에 어떤 의존성도 없기 때문입니다.
 의존성이 있다면, 방정식 블록들을 묶어 놓을 것이고, 더 많은 계산이 필요할 것입니다.
 그리고 물론 당신이 그런 식으로 일을한다면, 물론 당신이 그것을 손으로하고 있다면, 그것은 당신이 기대하는 것보다 조금 더 비쌀 것입니다.
 더 복잡한 일을하고 계십니다.
 그래서 우리가 코코아에서 종종 목표로 삼는 일은 일상적입니다. 단순한 것이고 복잡한 일들이 가능하다는 것입니다.
 이 경우 비용이 조금 더 들것 같습니다.
 그러나, 만약 당신이 그것을 사용하지 않는다면 돈을 지불하지 않을 것입니다. 이것은 실제로 직감과 관련하여 전체 엔진을 다시 생각할 수있는 올바른 방법입니다. 레이아웃 캐시와 의존성 추적기로 생각할 수 있습니다.
 그것은 매우 목표가 정해졌습니다.
 그것은 어떤 제약이 어떤 뷰에 영향을 미치는지 이해하고, 당신이 사물을 변경할 때 단지 필요한 것을 정확히 업데이트합니다.
 그리고 이것은 코드를 작성하는 방법에도 영향을줍니다.
 때로는 우리가 볼 수있는 한 가지 문제는 비용이 많이 드는 것처럼 보이기 때문에 제약을 피하기 위해 엄청난 고통을 겪고있는 사람들입니다.
 그러나 실제로, 그것은 매우 목표가 정해졌습니다.
 당신이 만들고있는 제약이 문제의 문제와 긴밀히 일치하는 한, 당신이하는 일이 무엇이든지간에, 당신이 그것을 피하기 위해 노력한다면 그것은 더 많은 성과가 될 것입니다.
 때때로 우리는 매우 복잡한 측정을하고 사람들을 추가하고 정보를 추출한 다음 다시 밀어 넣는 것을 보게 될 것입니다. 그리고 그것은 당신이 겪고있는 제약을 직접적으로 표현하는 것보다 거의 항상 비쌉니다.

지금과는 반대로, 때로는 많은 제약과 많은 우선 순위를 보게되는 상황과 같은 계층 구조를 볼 수 있으며 실제로 어떤 일이 벌어지고 있는지 명확하지 않으며 이것이 보통 알려지지 않은 계층 구조를 볼 수 있습니다. 이것은 실제로 누군가가 염두에두고있는 두 개의 완전히 별개의 레이아웃이고, 우리는 한 묶음의 제약으로 그것들을 묶어서 하나로 묶으려고하는 상황입니다.
 그리고 그것은 또한 좋은 생각이 아닙니다.
 따라서 그렇게되면 많은 거짓 의존성이 생기고 실제로 상호 작용하지 않는 것처럼 보이게됩니다.
 당신이 눈치 채지 못했다면 Debug도 거의 불가능합니다.
 따라서 전반적인 조언은 문제를 가능한 한 직접 모델링하는 것입니다.
 Kasia는 다른 레이아웃 사이를 전환하고 좀 더 명시 적으로 표시하는 이런 종류의 사례를 살펴볼 것입니다.
 하지만 그것은 일반적인 조언입니다.
 그냥 자연스러운 방법으로 사용하십시오.
 성능과 이해 가능성이 더 좋습니다.
 좋아, 그래서 우리가해야 할 말의 대부분.
 그러나 우리는 레이아웃의 성능 특성에 대한 전반적인 정신적 모델을 구축하려고하기 때문에 적어도 모든 주요 기능을 다룰 수 있어야합니다.
 그래서 당신이 할 수있는 다른 것들이 있습니다.
 토론 해 봅시다.
 그래서 어떤 특정한 견해는 적어도 100 포인트 넓이가되어야한다고 말할 수 있습니다.
 불평등을 사용할 수 있습니다.
 그 비용은 무엇입니까? 아주, 아주, 아주 조금.
 단지 100 포인트 너비와 같다고 말하는 것과 비교하면 넓습니다.
 우리는 내부 구조가 조금씩 바뀌었기 때문에 정확히 하나 더 많은 변수를 포함하게 될 것입니다.
 그게 전부 야.
 상수를 호출 할 수도 있습니다.
 이 예제 사용 사례는 제스처 인식기가있는 것과 같습니다.보기를 끌기 위해 노력하고 있습니다. 제스처 인식기에서 전화를받을 때마다 내가 할 일은 내가 할 일입니다. 그 변환을 가져와 그 변환 값으로 해당 제약 조건에 대해 set constant를 호출하여 제약 조건으로 펌핑 할 것입니다.
 좋습니다. 그러면 엔진의 종속성 추적기에 대해 이야기 할 것입니다.
 이것은 극대화 할 수 있습니다.
 따라서이 제약 조건이 바뀌기 때문에 바뀌어야 할 부분에 대한 매우 빠르고 매우 빠른 단계 업데이트입니다.
 이것이 바로 성능 최적화입니다.
 이것이 우리가이 방법을 일정하게 설정 한 이유입니다.
 마지막으로 우선 순위에 대해 이야기합니다.
 그래서 여기서 여러분은이 관점이 100 포인트 이상이어야한다고 말할 수 있습니다. 그러나 다른 것이 그것을 막을 수 있다면 최대한 가깝게 지내십시오.
 이것은 약간의 작업과 약간의 작업을 필요로합니다.
 그럼 조금 더 이야기 해 봅시다.
 생각해 볼 수있는 또 다른 방법은 해당 필드의 너비가 100에 몇 가지 오류를 더한 값과 같을 것이고 오류를 최소화하십시오.
 그것이 당신이 요구하는 것입니다.
 그래서 내가 전에 논의하지 않은 오류 최소화 단계가 있습니다.
 따라서 뷰가 레이아웃 하위 뷰의 일부로 엔진에 요청하고이 변수에 대한 가치는 무엇인지 알려줍니다. 엔진은 모든 오류 용어가 먼저 최소화되었는지 확인해야합니다.
 그리고 이것은 실제로, 이것은 - 나는 이것이 어떻게 작동 하는지를 설명하지 않을 것입니다.하지만 성능 특성에 관해서 조금 이야기 할 것입니다. 그리고 나는 또한 그것이 아주 멋지다고 말할 것입니다.
 그래서 이것을 보길 원할 것입니다.
 이것은 간단한 X 알고리즘입니다.
 이것이 우리가 실제로하는 일입니다.
 그것은 아주 오래되었습니다.
 그것은 제 2 차 세계 대전 중에 개발되었습니다.
 컴퓨터 앞에는 무엇이있을 수 있습니다.
 실제로 컴퓨터라고 불리는 사람들은 컴퓨터라고 불리는 컴퓨터가 있기 전에 그들이하는 일종입니다.
 그들은 손으로 그것을하고 있습니다, 그것은 당신에게 성능 특성에 대한 어떤 느낌을줍니다.
 당신이 그것을 손으로하면 꽤 빠를 것입니다.
 그리고 그건.
 우리가 해왔 던 것과 거의 같은 것들입니다.
 더 많은 대체품입니다.
 그것이 당신이 그것을 생각하는 방법입니다.
 어쨌든, 그렇습니다. 우선 순위를 사용할 때이 수준에서 비용이 발생하므로주의해야 할 부분입니다.
 좋아요, 그 전에는 이전과 똑같습니다.
 그래서 제가 그 얘기를하고 싶었습니다.
 이것이 자동 레이아웃에 대한 성능 특성을 직관적으로 이해하려는 우리의 시도입니다.
 우리가 이야기 한 내용을 빨리 검토합니다.
 제약 조건을 수정하지 마십시오.
 그게 당신이 모든 일을하고있을 때 뿐이에요.
 그러지 마라.
 제약 조건을 사용하여 작업 할 때 기본 대수학이고 제약 조건을 추가 할 때 대수가 발생합니다. 제약 조건을 제거하면 집합 상수를 호출 할 때 기본 시간입니다.
 또한 오류 최소화 단계가있을 때도 알 수 있습니다.
 자동 레이아웃이하는 일은 레이아웃을위한 현금이라고 생각하는 방식으로, 엔진 정렬에는 모든 해결 된 값이 포함되어 있고 종속성 추적기가 있으므로 사물이 변경되면 수퍼 타겟에서 값을 업데이트 할 수 있습니다 방법.

이는 우리가 사용하고있는 기능에 대해서만 비용을 지불한다는 마지막 시점으로 이어진다.
 그것이 우리가 이야기 한 것입니다.
 너의 직감이야.
 그리고 나머지 대화들에 대해서는 Kasia로 넘어갈 것입니다. 왜냐하면 만약 당신이 다시 직감에 의지한다면 상황이 잘 풀리지 않을 것이기 때문입니다.
 이제 그녀는 몇 가지 분석을하고, 우리가 이야기하지 않도록하고, 직감을 실천에 옮길 것입니다.
 그러니 즐겨주세요.
  좋아, 여기 내 슬라이드에 가자.
 고마워, 켄.
 안녕 모두들.
 내 이름은 Kasia Wawer입니다.
 저는 iOS 키보드 팀의 일원이며 자동 레이아웃을 사용하며 우리는 그것을 좋아합니다.
 그래서 효율적인 레이아웃을 만드는 것에 관해 여러분 모두와 이야기하게됩니다.
 좋아요, Constraint Churn으로 돌아가 봅시다.
 제약 조건을 변경할 때 우리가 들었던 구속력 변동은 실제보기가 움직일 필요가 없으므로 엔진에 추가 작업을 보내고 성능에 영향을 줄 수있는 정도의 충분한 양을 보냅니다.
 그래서 당신은 그것을 피하고 싶어하는 경향이 있습니다.
 그럼이 문제에 어떻게 대처할 수 있는지, 어떻게 벗어날 지 이야기 해 봅시다.
 그래서 우리는 여기서 스펙을 가지고 작업 할 것입니다.
 소셜 미디어 유형 앱용입니다.
 공유하고있는 사람을 보여주는 아바타보기가 있습니다.
 제목, 날짜 및 로그 항목보기가 있습니다. 간격이 필요하면 크기 조정이 필요할 것이므로 정렬이 필요할 것입니다.
 그러나 이것은 실제로 순수한 소셜 미디어 앱이 아닙니다.
 그것은 세미 소셜 미디어 앱입니다. 공유 할 것인지 여부를 선택할 수 있습니다.
 공유 한 적이 있고 나와 공유 한 사람을 표시하는보기도 옵션으로 제공됩니다.
 고양이 사진을 공유하지 않으면 소셜 미디어 앱이 완성되지 않습니다.
 그래서 그것은 당신이 넣어야 할 또 다른 레이아웃입니다.
 그리고 어쩌면 그 고양이 그림을 공유하고 싶지도 않을 것입니다. 왜냐하면 그 고양이 그림은 너무 좋기 때문에 자신의 것으로 유지하기를 원합니다.
 그래서 우리는 4 개의 비슷한 레이아웃을 가지고 있습니다.
 그것들은 같지 않고이 테이블 뷰 셀이 화면에 나타날 때 약간의 조정이 필요할 것입니다.
 언급하지 않았다면 테이블 뷰 셀에 있습니다.
 그리고 당신이이 응용 프로그램에서 성능에 노력하고 있다고 가정 해 봅시다 당신이 처음으로 그것을 실행하고 이것이 당신이 가진 스크롤 성능입니다.
 그리고 거기에 많은 딸꾹질이 있습니다. 특히 맨 위의 스크롤에.
 그래서 당신은 좋아, 어떻게이 응용 프로그램을 향상시킬 수 있습니까? 무슨 일이야? 그래서 저는 오늘 새로운 것을 소개하고, 우리가 작업하고있는 것을 들여다 봅니다.
 베타에서는 실제로 사용할 수 없지만 레이아웃 도구를 도입 할 예정이므로 계속해서 조정하십시오.
 그리고 OK.
 나는 네가 흥분해서 다행이다.
 그것은 좋은 동기 부여입니다.
 어쨌든, 여기에 무엇이 있는지 살펴 보겠습니다.
 최고 트랙은 표준 CPU 사용량입니다.
 그리고 이것은 탄광 전망에서 당신의 카나리아와 같습니다.
 여기에 피크가 많으면 레이아웃에서 볼 필요가있는 사항이 있음을 나타냅니다.
 그리고 꽤 평평하다면, 아마 당신의 퍼포먼스 문제가 다른 곳에서 발생하고있을 것입니다.
 그 아래에서 우리는 구체적으로 제약 차질을 추적 할 것입니다.
 이 경우 막대의 높이는 제약 조건 변동이 발생하는보기 수에 해당합니다.
 그래서 큰 그림을 볼 때 많은 견해가 영향을 받는다는 것을 알고 있습니다.
 또한 제한 인스턴스를 제거하고 변경하고 마지막으로 UILabel 및 기타 텍스트 뷰의 크기를 조정하는 방법을 보여줍니다.
 이것은 하나의 UILabel을 말합니다. 왜냐하면 그것이이 앱에있는 것이기 때문입니다.
 또한 다른 유형의 텍스트보기도 추적 할 것입니다.
 그래서 이것은 애플 리케이션 스크롤과 함께 찍은, 그래서 우리는 여기서 무엇을 보입니까? CPU보기에는 몇 가지 최고점이 있지만이 바로 아래에서 확대됩니다. 바로 아래에서 제약점 변동에서 큰 도약을 보았 기 때문입니다.
 따라서이보기를 강조 표시하고 계측기의 상세보기로 이동하면보기 설명에 따라 변동에 영향을받는보기 목록이 표시됩니다.
 그리고 우리는 Superview로 그룹화하여 Table View Cells의 인스턴스에서 특정 상황에서 반복적으로 발생하는 것을 쉽게 볼 수 있습니다.
 따라서이 예에서 아바타보기와 세 개의 레이블이 휘젓기를 경험하고 있음을 알 수 있습니다.
 그리고이 악기를 통과 한 사람이기 때문에이 레이블이 제목 레이블, 날짜 레이블 및 로그 항목 레이블과 일치한다는 것을 알고 있습니다.
 이것이이 셀에서 우리가 바라는 거의 모든 것입니다.
 그것은 약간에 관한 것입니다.
 무슨 일이 있었는지 보자.
 좋아, 여기서 우리 사양으로 돌아가.
 코드를 살펴보면 UpdateConstraints가 재정의되고 있음을 알 수 있습니다.
 그리고 그 방법이 변경되거나 UpdateConstraints가 전혀 실행되지 않을 때 우리는 모든 제약 조건을 제거한 다음 우리가 여전히 필요하다고 생각하는 제약 조건을 다시 추가합니다.
 모든 것이 시작된 곳으로 되돌아 왔습니다.
 따라서 제거 만 성능 문제에 기여합니다.

따라서 여기에서 사회적 이름표의 경우, 사회적인 아바타는 추가되고 제거되며, 실제로 그것을 완전히 제거 할 필요는 없습니다.
 이 뷰 주위의 제약 조건을 살펴보면 특정 뷰와 실제로 상호 작용하지 않는다는 것을 알 수 있습니다.
 그래서 여기서 당신은 setHidden이라고 불리는이 깔끔한 작은 기능을 사용할 수 있습니다.
 그리고 주변의 어떤보기에도 영향을 미치지 않으므로 사라질 것입니다. 제약 조건이 그대로 있으며보기를 숨기고 표시하는 아주 매우 저렴한 방법입니다. 계층 구조에서보기를 제거하는 것이 아닙니다.
 그래서 괜찮습니다.
 그러나 이것은 아주 간단한 예입니다.
 이미지보기는 어떻습니까? 좋습니다. 이미지보기에서 다시 모든 제약 조건을 제거한 다음 이미 가지고있는 제약 조건과 이미지보기를 다시 추가하려고 할 수 있습니다.
 그리고 다시, 모든 것이 같은 장소에 착륙하기 때문에 우리는 괴롭힘을 경험합니다.
 글쎄, 이런 상황에서 당신이 생각하기를 바라는 방식은 제약 그룹을 보는 것입니다.
 여기에서 제가 강조하고있는이 그룹에서부터 시작하겠습니다.
 이러한 제약 조건은 모든 레이아웃에서 동일하게 유지됩니다.
 변경하지 않아도되는 공유보기에서 숨기기 및 표시를 수행하면 아바타보기가 움직이지 않으며 레이블은 로그 항목 레이블 이외의 다른 항목으로 이동하지 않습니다.
 따라서 뷰를 생성 한 다음 왼쪽으로두면 이러한 녹색 제약 조건이 추가되어야합니다.
 만지지 마십시오.
 그들은 그들이있는 곳에서 머물기를 원합니다.
 하지만 이제는 이미지보기를 제어하는 ​​네 가지 제약 조건이 있습니다.
 그럼 우리는 그걸 어떻게 처리할까요? 자, 배열에 고정시키고 이미지가 없을 때 거기에있을 제약을 취합시다.
 그리고 저는이 imageConstraints와 noImageConstraints를 매우 창의적으로 명명하여 따로 보관할 수 있도록했습니다.
 그리고 우리가이 이미지 뷰를 넣거나 가져 가려고 할 때, 현재 레이아웃이 무엇인지 봅시다.
 noImageConstraints를 비활성화하고 이미지의 인스턴스를 활성화해야하는 경우 비활성화하십시오.
 이미지가 들어오지 않으면 다른 모든 제약 조건들이 이미 활성화되어 있다는 것을 알 수 있습니다.
 이제는 코드에서 물건을 단순화하기 때문에 이것이 단일 제약이라는 사실에도 불구하고 배열에이 두 코드를 넣었습니다.
 배열이나 단일 제약 조건을 처리하는지 여부를 확인하고 확인할 필요가 없으며 항상 제약 조건 배열을 처리합니다.
 귀하의 마일리지는 다를 수 있습니다.
 따라서 이것에 대한 좋은 점은 이러한 제약 조건을 제대로 추적하고 사용자 앞에이 이미지보기를 추가하려는 경우 이러한 noImageConstraints를 비활성화하고 ImageConstraints를 활성화하고 필요한 내부에서 레이아웃을 호출 할 수 있다는 것입니다 애니메이션보기 (View Animation) 블록을 사용하면보기에 멋지게 애니메이션을 적용 할 수 있습니다.
 모든 제약 조건을 비활성화하고 다시 넣으려고하면 매우 재미있을 것입니다.
 그렇게 말해 보겠습니다.
 좋습니다, 이제 우리는 이것을 디버깅하고 모든 것을 던지기보다는 제약 그룹과 함께 작업 할 것입니다. 어떻게 보일지 봅시다.
 이것은 당신을 생각 나게하기 위해 본래의 모습입니다.
 상단으로 스크롤하십시오.
 아주 안좋아.
 이것이 디버깅을 한 후에 보이는 모습입니다.
 그리고 그것은 훨씬 더 부드럽습니다.
 고맙습니다.
 그러나 더 기다려라! 사실 iOS 11에서이 동영상을 가져 왔습니다.
 이것은 iOS 12의 성능 향상을 이용하지 않습니다.
 이것은 일을보다 효율적으로 수행하는 클라이언트 코드 일뿐입니다.
 iOS12에서도 멋지게 보입니다.
 그리고 물론 멋진 [웃음].
 네, 훌륭합니다.
 그러면 제약 조건 변동을 어떻게 피할 수 있습니까? 모든 제약 조건을 제거하지 마십시오.
 대개의 경우 다시 한 번 넣어 두어야하는 상황에 처하게 될 것입니다. 필요없는 프레임을 중계하는 위치에 착륙 시키거나, t는 다시 놓일 필요가있다.
 앱의 모든 잠재적 레이아웃에 공통적으로 적용되는 제약 조건 세트가있는 경우이를 추가 한 다음 그대로 두십시오.
 이것은 Interface Builder와 앱의 초기 레이아웃에 유용합니다.
 변경이 필요한 제약 조건을 변경하지만 변경이 필요없는 제약 조건은 변경하지 않습니다.
 동어의 종류는 좋지만 좋아 보인다.
 그런 다음보기를 숨기는 대신에보기를 숨기는 대신에보기를 숨길 수 있습니다.
 좋아요, 그래서 그것은 계측기에서 제약 차질입니다.
 우리는 또한 바닥에 UILabel 사이징이라고 말한 견해를 가지고 있습니다.
 UILabel 사이징은 레이블이 크기를 계산하는 데 걸리는 시간을 추적합니다.
 따라서 내장 된 콘텐츠 크기에 대해 이야기 해 봅시다.
 나는 여기서 산책을 할거야.
 모든 뷰가 본질적인 콘텐츠 크기가 실제로 필요한 것은 아닙니다.
 일부 의견은 않습니다.
 뷰가 아닌 컨텐트가있는 뷰는 비 뷰 컨텐트를 기반으로 고유 컨텐트 크기의 크기를 반환합니다.

두 가지 예는 이미지의 크기를 사용하여 고유 한 내용 크기를 계산하는 UIImageView와 텍스트를 측정하고 그 내용을 사용하여 고유 한 내용 크기를 반환하는 UILabel입니다.
 본질적인 콘텐츠 크기에 대해 정말 이상한 것은 없습니다. UIView로 제약 조건을 만드는 데 사용됩니다.
 그것은 당신을위한 사이징 제약 조건을 만들고 그게 전부입니다.
 제약 조건에서 모든 크기 조정을 직접 정의하고이 모든 것을 건너 뛸 수 있습니다.
 재정의 할 필요가있는 몇 가지 상황이 있습니다. UIView 하위 클래스에 이러한 몇 가지 예 외에도 여러 가지가 있다는 것을 알았으므로, UIView 하위 클래스에 오버라이드해야합니다.
 그러나 그것이 더 빠르거나 더 정확하고 그것들 중 어느 것도 아니기 때문에 그것이 오버라이드되는 많은 시간들.
 그러나이를 무시하면 성능에 도움이 될 수 있습니다.
 텍스트 측정은 비용이 많이들 수 있습니다.
 여기 애플 리케이션에서 UILabel 사이징은 그리 오래 걸리지 않았습니다.
 그것은 매우 짧은 기간이었다.
 그래서 그걸로 어지럽 혀서 그만큼 성능을 ​​향상시키지 않을 것입니다.
 그러나 텍스트 집약적 인 응용 프로그램이 있고 UILabel 텍스트 측정에 많은 시간이 걸리거나 텍스트보기 텍스트 측정 또는 다른 용도로 사용하는 경우 시간이 많이 걸리는 경우에 도움이 될 수도 있습니다 추가 정보.
 모든 텍스트 측정을 수행하지 않고 텍스트가 필요로하는 크기를 알고 있다면 그 크기와 본질적인 컨텐츠 크기를 반환 할 수 있습니다. 또는이 뷰를 화면에 표시 할 때 제약 조건이 완전히 충족 될 경우 그 안에있는 텍스트의 크기에 관계없이 크기를 정의합니다.
 예를 들어 제약 조건은 항상 텍스트 크기보다 커지게 만듭니다.
 그런 다음 본질적인 콘텐츠 크기에서 너비와 높이에 대한 고유 한 측정 항목을 반환 할 수 있습니다.
 그리고이게 무엇을 할 것인가 부모님, 내가 이미 내 크기가있어, 텍스트 측정을 귀찮게하지 말라고.
 그래서 이것은 분명히 스스로 측정을 시도하지 않고있는 경우에만 작동하지만 일부 앱이 성능을 향상시키는 데 도움이 될 수 있습니다.
 그래서이 작은 속임수가 있다는 것을 당신이 알고 싶었습니다.
 그리고 시스템 레이아웃 크기에 맞는 크기를 이야기하지 않고도 본질적인 콘텐츠 크기에 대해 이야기 할 수는 없습니다. 왜냐하면 사람들이 서로의 의견이 비슷하기는하지만 종종 불투명합니다.
 본질적인 콘텐츠 크기는 엔진에 넣을 크기 정보를 전달하는 방법입니다.
 시스템 레이아웃 크기 피팅 크기는 크기 조정 정보를 엔진에서 다시 가져 오는 방법입니다.
 그들은 실제로 일종의 반대입니다.
 따라서 자동 레이아웃을 사용하여 하위 뷰를 관리하는보기에서 프레임 정보가 필요한 이유가있는 혼합 된 레이아웃의 일종으로 사용됩니다.
 사용 빈도는 적지 만 사용할 수 있습니다.
 나는이 방법이 당신이 생각하는 것보다 조금 더 비싸기 때문에 어떻게 작동하는지 말해주고 싶습니다.
 System Layout Size Fitting Size를 호출하면 엔진이 생성됩니다.
 제약 조건이이 엔진에 추가되고 레이아웃이 해결 된 다음 상위 뷰 프레임의 크기가 반환되고 엔진이 삭제됩니다.
 따라서이 메서드를 호출 할 때마다 엔진이 만들어지고 폐기됩니다.
 작은 용도로는 좋지만, 많은 일을한다면 시간이 지남에 어떻게 축적 될지 알 수 있습니다.
 따라서 System Layout Size Fitting Size를 호출 할 때는주의하십시오.
 우리가 때로는 사람들이 보는 용도 중 하나는 셀프 사이징 콜렉션 또는 테이블 뷰 셀에서 컨텐트보기로 해당 호출을 전달하는 것입니다.
 그리고 그렇게하면 스크롤링을 만들기 위해 실제로 만든 최적화를 무시하고,보기를 빠르게 스크롤하고 추가 엔진을 추가합니다.
 그래서 당신이 현재 그 일을하고 있고 당신의 스크롤이 좋지 않다면, 아마도 그것을 들여다보십시오.
 좋아요, 이제 우리는 세상에서 가장 좋아하는 주제로 왔습니다.
 충족 할 수없는 제약.
 그렇다면 충족 할 수없는 제약은 무엇입니까? 전에도이 문제에 빠져들지 않았다면, 이것은 여러분이 무언가를 할 때 일어나는 일입니다.이보기는 너비가 50 포인트이어야하며, 너비는 200 포인트 여야합니다.
 글쎄, 그건별로 효과가 없을거야.
 이들은 실제로 양자 폰이 아닙니다.
 아시다시피, 나는 미래에 대해서 말할 수는 없지만, 엔진은 레이아웃이 없다는 사실을 계산하고 당신을 위해 일종의 레이아웃을 생성하기 위해 제약 조건을 깨야합니다.
 이 제약 조건을 깨면 디버거에게 매우 자세한 로그를 보냅니다. 아마도 당신은 그것을 보았을 것입니다.
 제가 파산 한 제약이 있습니다. 영향을받은 다른 모든 것들이 있습니다. 그로 인해 파산해야했습니다.
 따라서 이것은 때때로 성능에 직접적인 영향을 줄 수 있으며 다른 문제를 가릴 수도 있습니다.
 따라서 디버깅을하는 것이 좋습니다.
 그리고 Mysteries of Auto Layout, Part 2에는 좋은 디버깅 정보가 있었기 때문에 만족스럽지 않은 제약 사항에 문제가 있는지 확인하는 것이 좋습니다.

네, 졸업하셨습니까?
  축하해.
  당신은 모두 자동 레이아웃 전문가이며, 어떻게 작동하는지 내부에 대해 배우는 것을 즐겼기를 바랍니다.
  이제는 제약 조건을 업데이트하고 진행 과정을 이해하기 전에 생각하는 법을 더 잘 알고 있습니다. 크기와 우선 순위 및 불평등에 대한 튜닝 정보를 얻었으므로 iOS 12의 레이아웃이 빨라졌습니다.
  누군가 질문이 있으면 내일 실험실에있게 될 것입니다.
  우리는 관련 세션에서 정보를 얻을 수있는 링크를 제공합니다.
  남은 시간을 즐기십시오.
