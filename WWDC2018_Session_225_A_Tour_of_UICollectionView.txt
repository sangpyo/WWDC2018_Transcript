음, 안녕하세요. UICollectionView 둘러보기에 오신 것을 환영합니다.
 내 이름은 Steve Breen입니다. 여기에서 설명 드리겠습니다. 저는 UIKit 팀의 프레임 워크 엔지니어입니다.
 그리고 저는 동료 인 Mohammed Jisrawi와 UIKit 팀과 함께 무대에 합류했습니다.
 그래서 오늘 우리는 조금 다른 것을 할 것입니다.
 디자이너 인 Breanka (음성학)가 제공 한 몇 가지 사양으로 앱을 제작할 예정이며 UICollectionView의 많은 기능을 활용하게 될 것입니다.
 이제 앱을 빌드하는 데 필요한 모든 작업을 수행하는 동안 레이아웃, 업데이트 및 애니메이션을 포함하여 UICollectionView와 관련된 다양한 주제를 다룰 예정입니다.
 그래서 우리는 다룰 수있는 토대가 있습니다. 그래서 바로 들어가 봅시다.
 좋아요, 그래서 우리 디자이너에게서 얻은 첫 번째 사양이 있습니다.
 친구 피드처럼 보입니다. 상상해보십시오.
 큰 작은 원주 형 레이아웃.
 아주 간단 해 보인다.
 좋아,이게 굉장해.
 그래서 여기에 우리는 정말 환상적인 모자이크 레이아웃을 보았습니다. 이것은 우리 친구 피드의 내용입니다.
 좋아요, 모하메드, 당신이 우리를위한 모든 코드를 작성하고 이러한 기능을 사용하는 방법을 설명하면서이 디자인에 대한 당신의 생각은 무엇입니까? 글쎄요, 처음 엔 이걸 보았습니다. 그러나 그들은 콜렉션 뷰를위한 훌륭한 후보자처럼 보입니다.
 나는 우리가 특히 이것으로 많은 재미를 가질 수 있다고 생각합니다.
 그래, 이거 멋지다.
 괜찮아.
 따라서 코드에 들어가기 전에 모하메드는 이것을 통해 우리를 걷기 시작했습니다. 콜렉션 뷰에 대해 이해하기 위해서는 먼저 코드에 들어가기 전에 세 가지 핵심 개념을 다루어야합니다.
 지금부터는이 작업을 해봅시다. 레이아웃, 데이터 소스 및 델리게이트에 대해 설명하겠습니다.
 괜찮아.
 먼저, 레이아웃에 대해 조금 이야기합시다.
 따라서 처음 UICollectionView에 대한 정의를 열고 UITableView에 익숙하다면 API에 익숙 함을 알게 될 것입니다.
 델리게이트와 데이터 소스가 있습니다.
 이 모든 것들은 꽤 친숙하지만 레이아웃 컨셉은 UICollectionView와 매우 독특하고 구별됩니다.
 당신은 UICollectionView의 슈퍼 파워라고 생각할 수 있습니다.
 그것은 CollectionView가 콘텐츠 자체와 시각적 인 배열을 분리하여 추상화 할 수있게합니다.
 레이아웃은 컨텐츠가 표시되는 위치에 관한 것입니다.
 이제 각각의 개별 항목은 UICollectionView 레이아웃 속성에 의해 지정됩니다. 예를 들어 bound, center 및 frame과 같은 속성의 경우 그와 같은 속성이 있습니다.
 표시되는 항목을 정의하는 데 사용할 수있는 속성 집합이라고 생각할 수 있습니다.
 UICollectionView 레이아웃 속성의 하위 클래스를 직접 인쇄하여 디자인에 포함 할 수도 있습니다.
 괜찮아.
 따라서 사용자가 화면의 내용을 스크롤 할 때 레이아웃은 변경 불가능한 것으로 간주됩니다.
 이제 이것을 변경해야 할 경우 (예 : 레이아웃의 모양을 변경하려는 경우) Mohammed가 무효화 메커니즘을 사용하여 조금만지나갑니다.
 괜찮아.
 이제 레이아웃이 별개의 추상이되는 것 중 하나는 레이아웃간에 전환 할 때 한 레이아웃에서 다른 레이아웃으로 전환하고 멋진 애니메이션 효과를 얻을 수 있다는 것입니다. 레이아웃 A는 레이아웃 B에 대해 알 필요가 없습니다.
 그들은 단지 레이아웃이 무엇인지 선언하고 전환이 발생합니다.
 괜찮아.
 그래서 CollectionViewLayout은 추상 클래스이므로 직접 사용하는 것이 아니라 CollectionViewLayout의 하위 클래스를 사용해야합니다.
 다행히도, 우리는 하나를 제공합니다.
 UICollectionViewFlowLayout, 그리고 전에 CollectionView를 사용했다면 아마이 클래스에 익숙 할 것입니다.
 이제 CollectionViewLayout에 커스터마이징 포인트가 있습니다. 여기서는 약간의 속성에 대해 설명 하겠지만 대리자를 사용하여 사용자 정의 할 수도 있습니다. 그리고 CollectionViewDelegate에 대해 잠깐 얘기 하겠지만 CollectionViewFlowLayout은 추가로 지정합니다 그 CollectionViewDelegate를 확장하는 것들.
 좋아, 그럼 Flow 란 무엇인가? 라인 기반 레이아웃 시스템이기 때문에 다양한 디자인을 포함 할 수 있습니다.
 알았어, 근원 기초는 무엇을 의미 하는가? 그럼 이걸 살펴 봅시다.
 그러므로 라인 기반 시스템이 무엇인지 설명하는 가장 좋은 방법은 예제를 제시하는 것입니다.
 괜찮아.
 그래서 우리는 수직 스크롤링 콜렉션 뷰를 얻었습니다. 우리는이 컨텐츠를 레이아웃 할 때 플로우 레이아웃이하는 것을 모방 할 것입니다.
 괜찮아.
 그래서 여기에 우리의 첫 번째 항목이 있습니다. 우리는 가장 앞선 부분부터 시작하여 줄을 따라 항목을 배치하기 시작합니다.
 이제이 줄을보십시오.
 이 선은 스크롤 축과 직각을 이룹니다.
 수직으로 스크롤하므로 선이 수평입니다.
 이제 알았으니 그 줄에있는 항목에 사용할 수있는 공간을 채 웠습니다. 이제 다음 줄로 넘어 가서 내용을 계속 레이아웃합니다.

그리고 마지막으로, 우리는 그 마지막 줄로 떨어지고, 빙고, 우리는 우리의 모든 내용을 가지고 있습니다.
 이제 여기에 몇 줄의 가이드를 놓아서 그 줄이 수평 인 곳을 강조 표시하면 흐름을 사용자 정의하는 방법에 대한 몇 가지 정의에 대해 이야기 해 보겠습니다.
 먼저 줄 간격의 개념입니다.
 그리고 여기에 화살표가 보일 때, 줄 간격은이 수평 줄 사이의 간격이 될 것입니다.
 마찬가지로 항목 간 간격은 레이아웃 선을 따라 항목 사이의 간격입니다.
 그리고 두 가지 모두에 대해 최소값을 지정할 수있는 두 가지 플로우 레이아웃 속성이 있습니다.
 괜찮아.
 그러니 우리의 직감을 조금이라도 고착시키고 모든 것을 회전 시키십시오, pi를 2 이상으로하고 맨 앞 가장자리에서 다시 시작합시다.
 이제, 이것은 가로로 스크롤하는 것입니다, 그래서, 우리는 수직 레이아웃 라인을 가지게 될 것입니다. 그리고 우리가이 영역의 바닥에 도달했을 때, 우리는 그 라인을 채우고, 위로 올라갔습니다.
 괜찮아.
 이 패턴은 지금 꽤 친숙합니다.
 우리는 거기에 갈.
 우리의 모든 콘텐츠가 있습니다.
 이제 수직 레이아웃 라인이 생겼습니다.
 이제이 방향에서 우리의 줄 간격은 이것입니다.
 그리고 우리의 아이템 간 간격은 이것입니다.
 흐름 레이아웃으로 작업 할 때를 기억하는 것이 중요합니다.
 좋아요, 레이아웃 이니까요.
 데이터 소스에 대해 조금 이야기 해 보겠습니다. TableView로 작업하는 경우 매우 익숙합니다.
 그것은 매우 유사한 패턴입니다.
 그들은 매우 유사한 API를 공유합니다.
 좋아, 레이아웃이 어디서 컨텐츠가 어디서 움직이는 지에 대한 것이라면, 데이터 소스가 무엇인지 알 수 있습니다.
 콘텐츠 자체.
 여기에 대해 생각할 3 가지 핵심 방법.
 첫 번째 옵션은 선택적이며, CollectionView의 섹션 수입니다. 제공하지 않으면이 섹션을 의미 할 것입니다.
 마찬가지로, 우리는 섹션에 항목의 번호를 가지고 있으며, 이것은 각각 항목의 숫자가 다를 수 있기 때문에 각 섹션의 항목 수를 알려줍니다.
 마지막으로 품목 색인 경로를 판매하면 사용자에게 표시 할 실제 콘텐츠를 제공합니다.
 괜찮아.
 이것이 바로 데이터 소스입니다.
 자, Mohammed와 함께 코드를 작성하기 전에 우리가 논의 할 3 가지 주제 중 마지막 주제는 대의원입니다.
 괜찮아.
 따라서 대의원의 사용은 선택 사항입니다.
 이제 CollectionView는 UIScrollView의 하위 클래스입니다.
 따라서 우리는 ScrollView 수퍼 클래스가 제공하는 것과 동일한 Delegate를 사용합니다. 그러나 우리는 그것을 확장합니다.
 따라서 스크롤 동작을 수정해야하는 경우이 동일한 Delegate에 대해 수행 할 수도 있고 사용자가 콘텐츠와 상호 작용할 때 강조 표시 및 선택에 대한 세부적인 제어와 같은 기능을 제공하는 UICollectionViewDelegate 메서드로 작업 할 수도 있습니다.
 그리고 우리는 API를 가지고 있습니다. 당신이 알기를, 어, 뭔가가 화면에 나타났습니다.
 WillDisplayItem 및 DidEndDisplayingItem.
 괜찮아.
 UICollectionView를 시작하기 전에 코드로 들어가기 전에 꼭 알아야 할 3 가지 핵심 개념입니다.
 따라서 모하메드와 함께 개발 상자로 전환하여 어떻게 작동하는지 알려주도록하십시오.
 모하메드.
 좋습니다. 그래서 우리의 두 화면 중 첫 번째로 열 레이아웃이 CollectionViewFlowLayout을 사용하는 좋은 사례입니다.
 UICollectionView를 사용하여 우리가 시작할 수있는 좋은 방법이 될 것입니다.
 이제 우리는 플로우 레이아웃을 사용하여 디자인의 전체 목표를 달성 할 수 있었지만 실제로 약간의 추가 커스터마이징을 할 것이므로 실제로 CollectionViewFlowLayout을 서브 클래스로 만들 예정입니다.
 그래서 이미 준비한 ColumnFlowLayout 클래스의 인스턴스를 만들어서 시작하겠습니다.
 나는 그 인스턴스를 사용하여 CollectionView를 생성 할 것이다.
 저는 CollectionView를 사용할 것입니다. 자동 크기 조절 마스크, 배경색과 같은 뷰 속성을 설정하려고합니다. ScrollView이기 때문에 ScrollView 속성도 설정할 수 있습니다.
 이것으로 앱을 보길 원하는 방식으로 보이게 할 수 있습니다.
 내 View 계층에 CollectionView를 추가 한 후 고유 한 식별자를 사용하여 CollectionView에 PersonCell 클래스를 등록하여 셀 디자인을 app으로 가져올 수 있습니다.
 그런 다음 뷰 컨트롤러를 CollectionView의 데이터 소스로 설정하여 표시 할 셀의 수와 셀에 표시 할 데이터의 종류에 대한 정보를 제공 할 것입니다.
 그리고 델리게이트로 설정할 것이므로 셀 선택을 처리 할 수 ​​있습니다.
 이제 우리가 설정 했으므로 실제로이 두 프로토콜을 준수해야합니다.
 데이터 소스를 준수하여 시작해 보겠습니다. 여기에 구현해야하는 두 가지 필수 메소드가 있습니다.
 첫 번째는 섹션에있는 항목의 수이며 우리의 데이터 배열 객체를 표시하기 위해 people 배열의 항목 수 또는 사람 수를 반환 할 수 있습니다.

우리가 구현해야 할 두 번째 방법은 CellForItemAtIndexPath입니다. 여기서는 고유 한 식별자를 사용하여 CollectionView에서 셀을 dequeue하고 people 배열에서 벗어난 사람과 객체를 셀에 전달하여 실제로 데이터를 표시합니다. 그런 다음 셀을 반환하십시오.
 그리고 여기를 마무리하기 위해 Delegate 프로토콜에서 하나의 선택적 메소드를 구현하면됩니다. 그래서 우리는 선택을 처리 할 수 ​​있습니다.
 그래서 DidSelectItemAtIndexPath를 추가 할 것입니다. 여기서는 FeedView 컨트롤러를 인스턴스화합니다.이 컨트롤러는 이미 인스턴스가없는 경우 두 번째 화면이 될 것이고 우리는 person 객체를 전달할 것입니다. 우리는 누구의 이미지를 표시해야하는지 알게되고, 그 다음 그것을 우리의 네비게이션 컨트롤러로 밀어 넣을 것입니다.
 괜찮아.
 이제 이것을 빌드하고 시뮬레이터로 전환 해 봅시다.
 괜찮아.
 [박수 갈채 및 환호성] 좋아.
 그래서 우리는 여기에 우리의 CollectionView를 가지고 있고 우리는 몇 개의 셀을 가지고 있습니다.
 그들은 일종의 부끄러운 일이긴하지만 그들을 볼 수 있습니다.
 그것들은 적당한 크기가 아니기 때문에 우리가 할 필요가 있다고 생각한 커스터마이징을해야 할 것입니다.
 이제 Xcode로 돌아가서 여기서 우리가 만든 ColumnFlowLayout 클래스를 열어 보겠습니다. 여기서 우리가해야 할 일을 살펴 보겠습니다.
 그래서 이미 레이아웃 준비 메소드의 스텁 재정의가 있습니다.
 이제 UICollectionViewLayoutsPrepare 메서드는 레이아웃이 무효화 될 때마다 호출되며 UICollectionFlowLayout의 경우 크기가 변경되는 CollectionView의 경계가 무효화 될 때마다 레이아웃이 무효화됩니다.
 그래서 우리의 애플 리케이션이 전화로 회전하거나 우리의 애플 리케이션은 iPad에서 크기가 조정됩니다.
 따라서 이것은 CollectionView의 크기를 고려한 모든 사용자 정의 작업을 수행 할 수있는 좋은 장소입니다.
 우리의 경우 우리는 셀이 CollectionView의 너비의 일부 함수가되기를 원합니다.
 그리고 우리는 아이템 크기의 속성이라고 말하는 것으로 아이템이 얼마나 큰지를 CollectionView에 알릴 수 있습니다.
 그래서 저는 여기서 계속 할 것입니다.
 그래서 CollectionView의 아이템 크기를 CG 크기로 설정하려고합니다. 너비는 CollectionView 경계의 너비이고, 여백은 그 여백으로 설정됩니다. 그리고 나서 우리는 70 포인트의 높이를 제공 할 것입니다. 우리의 디자인과 일치합니다.
 그리고 우리가 이미 여기에 있기 때문에, 나는 사물을 멋지게 보이기 위해 여기 몇 가지 다른 작은 것들을 할 것입니다.
 맨 위에는 항목 간 간격과 일치하는 일부 패딩이있는 인세 트 섹션을 적용하고, 레이아웃 영역 인세 트 참조 속성을 안전한 영역에서부터 설정하여 모든 것이 CollectionView 안전 영역 내에 깔끔하게 자리 잡게 할 것입니다 인세 트.
 괜찮아.
 다시 한 번 시뮬레이터로 돌아가서 제대로 구성된 레이아웃이 어떻게 보이는지 살펴 보겠습니다.
 괜찮아.
 잘됐다.
 그건 우리 사양과 똑같아.
 나는 디자이너가 정말로 행복 할 것이라고 생각한다.
 그리고 가로 방향으로 회전하면 셀 크기가 크기 때문에 무효화 코드가 준비 과정에서 다시 호출되는 것을 알 수 있습니다.
 이제 괜찮 으면서 생각할 수도 있지만, 우리가 여기서 할 수있는 최선의 방법은 아닙니다.
 가능한 한 크게 보이지 않습니다.
 여기에 우리가 사용할 수있는 공간이 있으므로 여러 열을 표시하는 것과 같이 여기에서보다 흥미로운 것을하고 싶을 수도 있습니다.
 이제 플로우 레이아웃을 사용하면이 작업을 쉽게 수행 할 수 있습니다.
 흐름 레이아웃이 레이아웃을 먼저 수행하는 방법에 대한 Steve의 설명을 기억한다면 플로우 레이아웃은 자동으로 다음 항목으로 넘어 가기 전에 한 줄 내에서 가능한 한 많은 항목에 맞도록 시도합니다.
 그래서 이것을 사용하면 레이아웃을 파악할 수 있습니다. 항목 크기를 변경하면 여러 개의 열을 얻을 수 있습니다.
 따라서 Xcode로 다시 돌아 가면 여기서 레이아웃을 변경하고 항목 크기를 계산하는 방법을 변경하면됩니다.
 그래서 저는이 적합성을 여기서 제거 할 것이며, 약간의 여분의 수학을하는 것으로 대체 할 것입니다.
 그래서 나는 이전에 가지고 있던 폭과 같은 너비로 시작하고 있습니다.
 이것은 마진에 의해 인서트 된 경계이며 최소 컬럼 너비가 300 포인트 인 임의의 정의입니다.
 그리고 그 두 값을 가져 와서 사용 가능한 공간에 들어갈 수 있다고 생각하는 최대 열 수를 계산하고이를 사용하여 사용 가능한 너비를 나누어 최적의 셀 너비를 계산합니다. 우리의 300 점 이상이어야합니다.
 그런 다음 해당 항목 크기로 사용중인 CT 크기로 전달합니다.
 괜찮아.
 다시 시뮬레이터로 돌아가서 업데이트 된 레이아웃이 어떻게 보이는지 살펴 보겠습니다.
 괜찮아.
 그래서 모든 것이 여기에 동일합니다.
 우리는 그것을 깨뜨리지 않았다.
 좋은 시작입니다. 만약 우리가 초상화로 가면, 우리가 원하는 것만으로 여러 개의 기둥이 나란히 있습니다.
 너는 어떻게 생각하니, 스티브? 잘됐다.
 우리는 훌륭한 적응 형 컬럼 기반 레이아웃을 가지고 있습니다.
 별로 일하지 않습니다.
 아니.
 우리 디자인의 다음 단계는 무엇입니까? 글쎄, 우리가 친구들 목록에서 우리를 편하게 만들었으니 이제는 [들리지 않는] 멋진 모자이크 레이아웃에 대해 생각해 볼 차례입니다.
 오 예.
 그것은 위대 할 것입니다.
 네.

슬라이드를 뒤집어서 조금 이야기 해 봅시다.
 괜찮아.
 여기에서이 레이아웃이나 디자인을 살펴보고 우리가 할 수있는 것을 살펴 봅시다.
 그래서 우리의 첫 번째 성향, 나는 당신에 대해 모르지만, 내 것이 흐름을 사용할 수있을 것입니다.
 나는 그것을있어.
 갈 준비가되었습니다.
 그것을 사용하려고합시다.
 이 디자인을 조금이라도 살펴보고 Flow가 우리에게 의미가 있는지 확인해 봅시다.
 그리고이 세 곳의 사진이있는이 특별한 지역, 나는 그 사실을 빠르게 확대 할 것입니다.
 괜찮아.
 이제이 경우 왼쪽에 매우 큰 사진이 있고 오른쪽에 세로로 된 사진이 있습니다.
 그래서 우리는 행 기반이므로, 큰 왼쪽 항목을 배치하고, 다음 항목으로 넘어 가서 다른 항목을 배치하려고 시도한 다음 다음 줄로 이동합니다.
 그러나 우리는 끝나지 않았습니다.
 우리는 그 수직 스택을 가지고 있습니다.
 따라서 실제로 Flow에 대해서는 작동하지 않을 것입니다. 왜냐하면 실제로는 라인 기반 레이아웃이 아니기 때문에 우리의 멋진 레이아웃입니다.
 그러나이 연습을 진행하는 것이 유용하므로 먼저 흐름부터 시작합시다.
 괜찮아.
 따라서이 경우에 우리는 우리 자신의 커스텀 레이아웃을 만들 것입니다.
 오, 아니, 우린 겁 먹었어, 그렇지.
 아니, 복잡하지 않아.
 우리는 여기서 다루는 네 가지 기본적인 방법을 가지고 있습니다. 그리고 나는 존경 할만한 언급을 얻는 또 하나의 방법을 제시 할 것입니다.
 괜찮아.
 그래서 네 가지 방법.
 여기에 우리가 간다.
 제가 이야기하고자하는 첫 번째 방법은 CollectionView Content Size입니다.
 CollectionView는 UIScrollView의 하위 클래스이며 UIScrollView의 기능 중 하나는 큰 콘텐츠 영역이있는 보이는 영역이 있다는 것입니다. 콘텐츠를 내부로 이동시키는 훌륭한 iOS 경험을 얻을 수 있습니다. CollectionView는 ScrollView를 알려주는 방법을 알아야합니다. 여기 내 콘텐츠의 크기가 얼마나 큽니까?
 괜찮아.
 그러면 우리는 어떻게이 크기를 얻을 수 있습니까? 레이아웃이 CollectionView에 대해 정의 할 모든 내용을 포함하는 직사각형을 상상한다면, 우리는 그 크기를 원합니다.
 좋습니다, CollectionView Content Size입니다.
 다음에는 레이아웃 속성을 제공하는 두 가지 방법이 있습니다.
 첫 번째는 LayoutAttributesForElements (Rect에서)입니다.
 이제는 사용자가 처음으로 내용이나 표시를 스크롤 할 때 화면에 표시 할 내용을 알아야 할 때 CollectionView에서 주기적으로 호출합니다.
 따라서이 쿼리는 기하학적 영역을 기준으로합니다.
 괜찮아.
 그것은 당신이 상상할 수 있듯이, 동반자 API, LayoutAttributesForItem AtIndexPath입니다, 그것은 단지 하나의 아이템을 찾고 있습니다.
 그 특성을 말해줘.
 좋아요, 모하메드가이 과정을 통해 우리를 안내 할 때 더 많은 것을 보게 될 것입니다.하지만이 두 API의 경우 성능 문제가 중요합니다.
 네 가지 핵심 사용자 정의 레이아웃 하위 클래스 항목 중 네 번째 항목이 Prepare 메소드가 될 것입니다.
 이제 모하메드는 이미 이것에 대해 약간의 대화를 나누었습니다.
 이것은 레이아웃이 무효화 될 때마다 호출됩니다.
 따라서 캐싱 할 레이아웃 속성과 나중에 얼마 후에 요청 될 내용 크기와 같은 것을 계산할 수있는 좋은 시간입니다.
 괜찮아.
 그래서 우리의 영예로운 API에 대해 이야기 해 보겠습니다.
 경계 변경을 위해 레이아웃을 무효화해야합니다.
 CollectionView의 경계가 바뀔 때마다 호출됩니다.
 다시 한번 CollectionView는 UIScrollView 서브 클래스입니다.
 경계 변화가 무엇을 의미합니까? 음, ScrollView 범위가 변경되면 스크롤하는 동안 원점이 변경 될 수 있으며 응용 프로그램 크기가 변경되거나 CollectionView 크기가 변경되면 크기가 변경 될 수 있습니다.
 그래서 이것은 스크롤하는 동안 호출 될 것입니다.
 그러므로 오 예 예문.
 이것은 매우 자주 호출됩니다.
 여기에서 올바른 결정을 내리는 것이 중요합니다.
 UICollectionViewLayout의 기본 구현은 false를 반환합니다.
 그래서 당신이 다른 것을하기 위해 이것을 필요로한다면, 여기 당신의 기회입니다.
 그리고 예제로 UICollectionViewLayout은 원점이 변경되면 false를 반환합니다.
 사용자가 콘텐츠를 스크롤하는 경우 무효화되지 않습니다.
 기본적으로 보자.
 그러나 iPad가 회전하고 전화기가 회전하고 앱이 다른 크기로 변경되면 true를 반환합니다.
 이제 약간의 예외는 떠 다니는 머리말과 꼬리말 같은 것입니다.
 우리는 당신이 당신의 내용을 스크롤하는 동안 그것들을 재 계산해야합니다.
 그 일을 처리하기 위해 사용자 지정 무효화를 수행합니다.
 괜찮아.
 그래서 충분한 이론.
 우리의 개발 기계로 돌아가서 모하메드가 멋진 사용자 정의 UICollectionViewLayout을 만드는 코드에서 어떻게 보이는지 살펴 보도록하겠습니다.
 좋아, 바로 들어가자.


그래서 우리는이 레이아웃을 위해 사용할 다른 레이아웃 서브 클래스를 이미 만들었습니다.이 레이아웃은 CollectionViewLayout의 서브 클래스가 아니라 UICollectionViewLayout의 서브 클래스라는 것을 알 수 있습니다. 이는 Steve가 우리에게 설명한 이유 때문입니다 이전에는 UICollectionViewLayout이 사용자 정의 모자이크 디자인의 요구를 실제로 충족시키지 못합니다.
 그래서 제가 여기서하고있는 첫 번째 일은 나중에 참조 할 수있는 몇 가지 주요 정보를 잡기 위해 사용할 인스턴스 변수 몇 개를 설정하는 것입니다.
 첫 번째는 컨텐츠 바인딩 된 CG rect이며, 이는 CollectionView 내의 모든 항목에 대한 대표적인 경계를 유지하는 데 사용할 예정입니다.
 그리고 두 번째는 캐시 된 속성 배열입니다. 성능 특성이 중요 할 때이를 빠르게 참조 할 수 있도록 레이아웃 속성을 고정하는 데 사용할 것입니다.
 따라서 우리는이 레이아웃을 위해 다시 prepare 메소드를 구현함으로써 시작할 것입니다.
 Prepare는 무효화 당 한 번 호출되기 때문에 대부분의 레이아웃 작업을 수행하기에 이상적인 곳입니다.
 여기서 레이아웃을 설정 한 다음 훨씬 더 자주 호출되는 메소드에서 무거운 레이아웃 작업이나 무거운 레이아웃 계산을하지 않아도됩니다.
 그래서 우리는 여기서 두 가지 일을하고 있습니다.
 첫째, 이전 무효화에서 부실한 정보를 제거하기 위해 캐싱 된 속성과 콘텐츠 경계를 다시 설정합니다.
 다음으로 우리는 CollectionView의 모든 항목에 대해 몇 가지 작업을 수행하고 있습니다.
 이것들 중 첫 번째는 사실 속성을 준비하는 것이고, 이제는 우리가 특정한 레이아웃을 위해 필요로하는 것에 너무 깊이 들어가기를 원하지 않습니다. 왜냐하면 이것은 당신을 위해 달라지기 때문입니다.
 여기서 크기와 위치 및 변형 등을 계산할 곳입니다.
디자인 요구 사항에 맞게 셀을 선택하십시오.
 그러나 우리가 속성으로 끝내면 우리가 여기에서 할 몇 가지 중요한 것들이 있습니다.
 첫 번째는 캐시 할 것입니다.
 우리는 캐쉬 된 애트리뷰트 배열에 그것들을 넣을 것이고 그래서 우리는 나중에 그들을 빨리 붙잡을 수 있습니다.
 두 번째는 콘텐츠 경계가 rect로 유지되도록 프레임을 결합하는 것입니다.
 이제 준비 작업이 끝나면 나머지 레이아웃을 구현하여 모든 작업을 수행해야합니다.
 따라서 첫 번째는 CollectionView Content Size입니다. Prepare에서 작업을 완료했다면 Content Bounds를 크기로 반환 할 수 있습니다.
 다음은 경계 변경을위한 레이아웃을 무효화해야합니다.
 이제 우리의 레이아웃에는 스크롤하는 동안 무효화할 필요가있는 요소가 없으므로 플로팅 헤더, 플로팅 푸터 또는 이와 유사한 것은 없습니다.
 CollectionView의 크기가 바뀔 때 무효화하고 싶을뿐입니다.
 크기의 새로운 경계가 우리의 CollectionView의 크기 인 현재의 크기 경계와 같지 않으면 true를 반환합니다.
 그런 다음 LayoutAttributesForItem AtIndexPath를 구현합니다. Prepare 메소드의 모든 속성을 준비 했으므로 우리 배열에서 RequestAtIndexPath에 해당하는 특정 속성을 가져올 수 있습니다.
 마지막으로 LayoutAttributesForElements InRect를 구현할 것입니다.
 이제이 메소드는 CollectionView에 의해 주기적으로 호출되며 CollectionView보다 큰 다른 쿼리 렉을 사용합니다.
 CollectionView는 특정 영역과 일치하는 속성 세트를 요구합니다.
 CollectionView에서 해당 rect 내에 나타나는 모든 항목에 해당하는 모든 특성을 포함하는 배열을 반환하는 것은 우리의 임무입니다.
 그래서 우리는 캐쉬 된 애트리뷰트 배열을 애트리뷰트의 프레임에 필터링함으로써 간단히이 질문에 대답 할 수 있습니다.
 따라서 우리 애트리뷰트가 질의 rect를 가로 지르는 프레임을 가지고 있다면 우리는 그것을 반환 할 수 있습니다.
 괜찮아.
 이제 시뮬레이션으로 돌아가 레이아웃이 어떻게 보이는지 살펴 보겠습니다.
 그래서 나는이 피드 중 하나를 선택하려고합니다.
 우리는 우리의 레이아웃을 가지고 있습니다.
 우리의 이미지는이 화려한 모자이크 구성에 잘로드되어 있습니다. 가로로 회전하면 셀의 크기가 조정되어 모든 것을 올바르게 업데이트했음을 알 수 있습니다. 무효화되었습니다.
 그래서 이것은 우리 사양과 비슷하지만, 스크롤 성능은 좋지 않습니까? 아니.
 아니, 꽤 나쁘다.
 그래서 당신은 이미 무슨 일이 벌어지고 있는지에 대한 아이디어를 가지고있을 것입니다.
 코드로 다시 전환하여 어떤 일이 벌어지는 지 살펴 봅시다.
 따라서 레이아웃 속성이나 요소를 여기서 살펴보면 스크롤하는 동안이 메서드가 자주 호출된다는 것을 기억하십시오.
 따라서 우리의 전체 배열을 필터링하는이 함수는 CollectionView의 항목 수가 증가함에 따라 실제로 비쌀 수 있다고 생각할 수 있습니다.
 따라서 앱에서 더 많은 사진을 찍을수록 스크롤링 속도가 느려집니다.
 따라서 이와 같은 상황에서 자신을 발견하면 뒤로 물러나서 레이아웃의 성격을 생각하고 최적화 기회를 찾을 수 있는지 생각해보십시오.

그래서 우리의 레이아웃 종류는 모든 셀 어플리케이션이 셀의 바로 앞이나 뒤에 있다는 것을 요구합니다.
 즉, 우리의 속성은 프레임의 최소 y 값에 따라 캐시 된 속성 배열 내에서 이미 정렬되어 있음을 의미합니다.
 그래서 우리는 정렬 된 배열을 가지므로, 우리가 지금하고있는 선형 필터와는 달리 바이너리 검색과 같은 것을함으로써 검색 속도를 높일 수 있습니다.
 여기서 느린 구현을 제거하고 훨씬 더 빨라야 할 부분으로 바꾸자.
 그래서 저는 조금씩이 단계를 밟을 것입니다. 걱정하지 마십시오.
 그래서 우리가 여기서하고있는 첫 번째 일은 우리가 이미 준비한 바이너리 검색 함수를 호출하는 것입니다.이 함수는 우리 배열과 쿼리 rect 내에서 다양한 인덱스를 취합니다.
 rect 내에서 프레임이있는 속성 집합을 찾으면 속성을 우리 배열의 인덱스로 반환합니다.
 그런 다음 해당 색인을 시작으로 우리는 쿼리 rect의 나머지 속성 집합을 우리 배열에서 위아래로 반복하고 쿼리 rect를 종료 할 때까지 특성을 선택하여 rect 외부에있는 특성을 찾을 때까지 구성 할 수 있습니다 .
 그리고 이것은 훨씬 빨라야합니다.
 배열에 수천 개의 항목이 있습니다.
 수천 번 항목의 배열을 반복하지 않을 것입니다.
 자, 다시 시뮬레이션으로 돌아가서 우리의 더 빠른 스크롤 알고리즘이 어떻게 생겼는지 보도록하겠습니다.
 이것을 열어서 가볍게 치자.
 그것은 더 빠른 방법입니다.
 너는 어떻게 생각하니, 스티브? 훨씬 낫다.
 좋아, 좋아.
 그래서 우리는이 두 가지 훌륭한 레이아웃을 가지고 있습니다.
 무엇 향후 계획? 그래서 우리는 두 개의 스크린을 가지고 있습니다.
 친구 목록에 대한 업데이트 애니메이션이 여기에 있습니다.
 오 좋은.
 괜찮아.
 글쎄, 슬라이드로 돌아와서 우리 디자이너가 생각한 완전히 멋진 업데이트 애니메이션을 보자.
 좋습니다, 비디오가 있습니다.
 이것을 실행하고 완전히 멋진 업데이트 애니메이션이 어떤 모습인지 살펴 보겠습니다.
 괜찮아.
 여기에 몇 가지 요소가 있습니다.
 마지막 항목이 새로 고침되는 것을 볼 수 있습니다.
 누군가 사진을 올린 다음 거기에 또 다른 아이템이 생겼다면, 세 번째 아이템이 번지지 않을 것 같습니다.
 괜찮아.
 그래서 우리는 세 가지 기본적인 작업을했습니다.
 재로드, 이동 및 삭제가 있습니다.
 우리가 dev 컴퓨터로 다시 전환하지 마십시오. 모하메드, 어떻게 작동하는지 보여 주시겠습니까? 확실한 것.
 여러 애니메이션 업데이트를 동시에 진행하고 있습니다.
 따라서 UICollectionView 및 UITableView에서 제공하는 훌륭한 도구를 알고있을 수 있으며 기본적으로 Perform Batch Updates API를 사용하면 기본적으로 컬렉션보기를 애니메이션과 동시에 수행 할 수있는 업데이트 집합에 전달할 수 있습니다.
 따라서 CollectionView PerformBatchUpdates에 대한 호출을 추가하고 여기에서 데이터 소스 업데이트와 CollectionView 업데이트를 수행하고 있습니다.
 이것은 내 업데이트를 조정하고 일들을 깔끔하게 유지하고 불일치를 피하는 가장 좋은 방법입니다.
 따라서, 먼저 데이터 소스의 마지막 항목을 업데이트하고 있습니다.
 마지막 항목을 두 번째로 제거하고 마지막 항목을 선택하여 맨 위로 이동 한 다음 CollectionView에서 원하는 애니메이션을 수행하도록 요청합니다.
 괜찮아.
 다시 시뮬레이션으로 돌아가서 업데이트 내용을 확인해 보겠습니다.
 오른쪽 상단에있는이 업데이트 버튼을 통해 업데이트 코드를 연결했습니다.
 무슨 일이야? 오, 당황 스럽네.
 여기서 뭐하는거야.
 나는 오랫동안 아이폰 OS를 썼다.
 전에이 영화를 봤어.
 그래, 무대에서 일어날 때 끔찍해.
 여기서 시간이 없습니다. 다시로드 데이터 만 호출하면됩니다. V2에 대한 애니메이션을 다시 방문하여 실행할 수 있습니다.
 정말? 알다시피, 우리는 할 수 있지만 완전히 멋진 업데이트 애니메이션을 잃어 버릴 것이고 사용자들은 이러한 활기찬 인터페이스를 기대할 것입니다. 맞습니까? 네, 네 말이 맞아.
 그거 알아? 그들은 더 나은 자격이 있습니다.
 아, 나는 네가 생각하는 방식을 좋아해.
 좋아요. 슬라이드로 빠르게 전환하고 완전히 멋진 업데이트 애니메이션을 저장할 수 있는지 봅시다.
 당신은 전에 이것을 보았습니다.
 괜찮아.
 그래서 우선,이 디버그 예외를 파헤쳐 우리에게 무엇을 말하려고하는지 봅시다.
 괜찮아.
 그래서 여기서 우리는 같은 인덱스 경로 인 0-3에서 삭제와 이동을 시도하고 있다고 말합니다.
 그래서 제가 기억한다면, 그것은 네 번째 항목입니다.
 우리는 다시로드하고 그에 대한 조치를 취했습니다.
 삭제하지 않았고 세 번째 항목 인 0-2을 삭제했습니다.
 내가 그들을 삭제 기억이 안나요.
 그래, 그게 뭐니? 좋습니다.하지만이 작업을하기 전에 PerformBatchUpdates API를 살펴보고 몇 가지 고급 원칙에 대해 이야기 해 봅시다.
 괜찮아.
 모하메드가이 API를 처음 소개했을 때 언급했듯이이 API의 목적은 동시에 여러 업데이트를 커밋하고 함께 애니메이션을 적용하고 멋진 경험을 얻을 수 있다는 것입니다.

또한 언급했듯이 CollectionView 업데이트 클로저 내부의 CollectionView 업데이트와 함께 데이터 소스 업데이트를 수행하는 것이 중요합니다.
 자, 내가 CollectionView에 대해서도 말하고있는 것은 TableView에도 적용됩니다.
 따라서 앱에서 TableView를 가지고 있다면이 모든 정보는 같은 방향으로 가고 있습니다.
 괜찮아.
 여기서 몇 가지 관찰을 해봅시다.
 CollectionView 업데이트는 삽입, 이동 및 삭제를 수행 할 때 해당 순서가 업데이트 닫힘에 상관 없습니다.
 원하는 곳 어디든지 놓으십시오.
 그러나 이제는 데이터 소스가 업데이트되어 구조 변경시 해당 데이터 소스를 지원하는 데이터 소스가 제공되거나 중요합니다.
 좋아요, 이것은 예제를 보여줌으로써 가장 잘 표현할 수 있습니다. 그래서 세 개의 요소가있는 두 개의 배열을 예로 들어서 살펴 보겠습니다. 우리는 직감을 강화하고 삭제와 삽입을 보여줄 것입니다. 하지만 우리는 첫 번째 삭제를 먼저하고 두 번째 삭제를 두 번째로 수행 할 것입니다.
 우리는 순서를 뒤집을 것이고, 우리의 직감을 강화시킬 것입니다.
 나는 항상이 일을하고 사진을 그려.
 괜찮아.
 그래서 우리는 첫 번째 항목을 지웠고 이제 인덱스 1에 삽입 할 것입니다.
 두 번째 예에서는 순서를 바꾸고 삽입을 먼저 수행 한 다음 삭제합니다.
 우리의 직감이 유지하기 때문에 실제로 우리는 다른 결과를 얻습니다.
 이것은 아마도 좋은 일이 아닙니다.
 CollectionView 업데이트와 대조해 봅시다.
 이제는 일괄 처리 업데이트를 통해 제출할 때 CollectionView 업데이트 2 세트가 있으며 슬라이드를 깔끔하게 유지하기 위해 데이터 소스 업데이트를 생략했습니다.
 하지만 첫 번째에는 삽입과 삭제가 있고 두 번째에는 삭제와 삽입이 있으며 순서가 다릅니다.
 이것은 똑같은 결과를 줄 것입니다.
 우리는 모두 엔지니어입니다.
 우리는 왜, 왜 그런지 알고 싶습니까? 글쎄, 그 얘기하자.
 어떻게 될까요? CollectionView로 보내지는 업데이트의 순서가 중요하지 않은 이유는 무엇입니까? 물론 데이터 소스를위한 것입니다.
 괜찮아.
 그럼이 작업을 작업별로 살펴 보겠습니다.
 따라서 삭제할 첫 번째 것은 인덱스 경로 순서를 내림차순으로 처리하는 것입니다.
 이제 인덱스 경로에 대해 살펴 보겠습니다.
 따라서 우선 배치 업데이트가 시작되기 전에 PerformBatchUpdate에서 어떤 일이 일어나고 있는지 생각할 수있는 경우 데이터 소스는 이전 상태입니다.
 이제 일괄 업데이트에서 모든 것이 완료되면 이후 상태가됩니다.
 괜찮아.
 따라서 삭제를 위해 색인 경로는 항상 이전 단계를 참조했습니다.
 그래서 그것은 삭제입니다.
 따라서 삽입은 오름차순 인덱스 경로 순서 경로로 처리됩니다.
 따라서 인서트에서 참조하는 인덱스 경로는 항상 최종 상태 또는 업데이트 이후 단계를 나타냅니다.
 좋아요, 움직임은이 둘의 혼합입니다, 맞습니다.
 from 및 a 인덱스 경로가 있고 from은 before 상태, right는 to가 after 상태입니다.
 다시로드하십시오.
 당신이 원한다면 이제 재 장전은 약간의 슈퍼 커맨드입니다.
 실제로는 삭제와 삽입으로 분해됩니다.
 그리고 재로드에서 지정된 색인 경로가 이전 상태에 대해 말하고 있습니다.
 괜찮아.
 이제 우리는 재로드가 실제로 어떤 일을하는지 이해할 수있게되었습니다. 왜냐하면 마지막 애플리케이션의 재로드에 대한 삭제로 인해 애플리케이션의 오류로 인해 발생한 일들을 조금씩 알 수 있습니다. 내부적으로는 항목, 알았어.
 코드로 돌아 가면 잠시 후에이 문제를 해결할 수 있습니다.
 좋습니다, 그래서 나는 이것들을 통과하지 않을 것입니다, 그러나 당신은 이것들에 대해서 나중에 추론 할 수 있습니다.
 콜렉트 뷰 (CollectionView)를 괴롭히는 원인이된다고 여기에 올려 놓으십시오.
 하지 마.
 그리고이 모든 지식을 어떻게 활용하고 어떻게 단순화 할 수 있을까요? 주어진 CollectionView 또는 TableView 업데이트 세트의 데이터 소스 업데이트를 항상 적용하고 모든 것이 동기화되어 있는지 확인하는 방법으로이를 추출 할 수 있습니다.
 괜찮아.
 그래서이 네 가지 기본 규칙.
 먼저 이동을 분해하고 삭제 및 삽입하기를 원합니다.
 쉬운.
 그런 다음 모든 삭제 및 삽입을 두 개의 개별 목록으로 결합하고 색인 경로에서 내림차순으로 삭제를 처리 한 다음 오름차순 색인 경로 순서로 해당 삽입을 마지막으로 적용합니다.
 이것을해라. 그러면 너는 좋다.
 데이터를 다시로드하는 방법은 무엇입니까? 그리고 저는 모하메드가 우리가 그걸 때릴 수 있다고 말했고 우리는 끝났습니다. 그리고 모두들 웃었고 그래서 나는 소리 쳤다 고 확신합니다. 그러나 재로드 된 데이터에 관한 것은 위대한 애니메이션을 얻지 못하는 것입니다. 정말 썰매 망치 접근법입니다.
 그래서 우리는 앱이 생동감 있고 생기 있고 고객에게 큰 감동을주는 것을 정말 좋아합니다.
 그래서 이것은 특별한 경우에 사용됩니다.
 좋습니다. Mohammed, 진짜 빠른 것을 되돌리고 코드에서 고정 된 값을 얻을 수 있는지 확인하고 완전히 멋진 업데이트 애니메이션을 저장해 봅시다.
 좋아, 나 자신을 구할 시간이야.
 예.
 스티브가 우리와 공유 한 가이드 라인을 사용하여 업데이트 애니메이션을 수정하자.

여기에 기존 구현을 제거해 보겠습니다.
 그리고 우리가 업데이트 한 내용은 다시로드, 삭제 및 이동으로 구성되었으며 리로드와 이동은 동일한 인덱스 경로에있었습니다.
 그들은 같은 곳에서 시작했습니다.
 이것이 바로 우리의 갈등이있는 곳입니다.
 그래서 우리는 그 둘을 분리함으로써 시작할 필요가 있습니다.
 재로드를 배치 업데이트를 수행하는 자체 호출로 가져 가자. 이전과 마찬가지로 데이터 소스를 다시 업데이트하고 CollectionView에서 다시로드 항목을 호출한다.
 UI 사양보기에서 애니메이션을 닫지 않고 수행하기 만하면됩니다. 사양을 면밀히 살펴보면, 실제로 다시 애니메이션이 적용되지 않기 때문에 초기 리로드입니다.
 괜찮아.
 그래서 다음으로, 나머지 업데이트, 삭제 및 이동을 처리해야합니다.
 그리고 그들에 대해 잠깐 이유를 들어 봅시다.
 인덱스 2에서 삭제가 발생하고 인덱스 3에서 인덱스 0으로 이동합니다.
 따라서 방금 배운 지침을 사용하여 이동을 분석하면 인덱스 2에서 삭제, 인덱스 3에서 삭제, 인덱스 3에서 인덱스 3에 항목이 삽입됩니다.
 이제 두 세트의 작업이 있습니다.
 삭제 및 삽입이 있습니다.
 우리는 그에 따라 처리 할 수 ​​있습니다.
 먼저 삭제를 내림차순으로 수행합니다.
 그래서 우리는 인덱스 3에서 먼저 삭제를 수행하고 거기에서 사람을 붙잡아 나중에 삽입 할 수 있습니다.
 그런 다음 색인 2에서 해당 항목을 삭제합니다.
 그런 다음 삽입 순서를 오름차순으로 처리해야합니다.
 우리는 하나 가지고 있습니다, 그래서 우리는 그냥 들어가서 그것을 삽입 할 수 있습니다.
 마지막으로 우리는 우리가 원하는 애니메이션을 수행하도록 CollectionView에 요청할 것입니다.
 이제, 나는 여전히 여기로 이사를 부르고있다.
 콜렉션 뷰가 올바른 애니메이션을 재생하기를 원하기 때문에 구성 요소 작업으로 분해하지 않았으며, 데이터 소스로 올바른 작업을 수행했다면 CollectionView는 애니메이션 측면에서 올바른 생각을 할 것입니다.
 괜찮아.
 시뮬레이터로 돌아가서 작동 할 때 우리 업데이트가 어떻게 보이는지 봅시다.
 괜찮아.
 여기에는 아무 것도 없습니다.
 와우.
 큰! 내가 다시로드하고 천천히 차선을 돌릴 것입니다. 우리는 거기에갑니다.
 그건 우리 사양과 똑같아 보입니다. 그렇지 않습니다.
 멋지다, 굉장하다.
 괜찮아.
 글쎄요.
 우리는 많은 내용을 다루었습니다.
 다시 슬라이드로 전환 할 수 있습니까? 그리고 저는 행동 촉구를 약간하고 싶습니다.
 따라서 사용자 정의 레이아웃을 작성하는 것이 불안하거나 불안한 경우에는 방금 적용한 내용을 사용하여 돌아가서 사용자 정의 레이아웃을 만들고 정말 훌륭한 CollectionView 솔루션을 작성하십시오.
 그리고 많은 재로드 데이터가 앱 전체에 뿌려지고 이러한 회색 애니메이션이 손실되는 경우.
 그들은 그러한 것들을 조사하고 아마도 당신이 이해하지 못했던 이유를 보거나 왜 그것이 일어 났는지 그 이유에 대해 꽤 잘 돌봐주지 않았고 그 지점을 수정했습니다.
 좋아, 더 많은 정보가 있으면 슬라이드의 링크를 볼 수 있습니다.
 그리고 우리는 또한 내일 9시에 CollectionView 실험실을 가지고 있습니다.
 CollectionViews에 대한 질문이나 의견이 있으시면 언제든지 채팅하고 채팅하십시오.
 모하메드와 나는 둘 다 거기에있을 것이다.
 그리고와 주셔서 대단히 감사 드리며, 나머지 컨퍼런스를 즐기시기 바랍니다.

