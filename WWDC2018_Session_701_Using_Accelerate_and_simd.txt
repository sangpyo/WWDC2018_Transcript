좋은 아침.
 모두 어떠신가요? 좋은.
  내 이름은 Matthew Badin이고 저는 Apple의 엔지니어입니다.
 Accelerate 및 simd 세션 사용에 오신 것을 환영합니다.
 그래서 제 동료 Luke Chang과 저는 오늘 매우 흥분됩니다.
 Accelerate 및 관련 프레임 워크에서 사용할 수있는 모든 위대한 API에 대해 이야기하고 Accelerate 및 내부에 포함 된 고성능 라이브러리에 대해 자세히 설명합니다. .
 그런 다음 몇 가지 라이브러리를 자세히 살펴보고 vDSP를 살펴 보겠습니다.
 우리에게 당신을위한 두 가지 예가 있습니다.
 첫 번째는 노이즈에서 신호를 추출하는 방법을 보여주고 특정 유형의 이슈를 이미지에서 제거하는 방법을 보여줍니다.
 이제 simd에 대해 살펴볼 것입니다. 쿼터니언을 사용하여 3 차원에서 회전을 표현하는 방법을 보여 드리겠습니다.
 저는 제 동료 인 Luke Cheng에게 프리젠 테이션을 전달할 것입니다. Luke Cheng은 vImage로 할 수있는 재미있는 것들을 보여줄 것입니다.
 그래서 시작하자.
 그래서 당신은 아마 당신 자신에게 정확히 이것을 요구할 것입니다.
 지구에서 가속은 무엇입니까? 따라서 Accelerate의 주된 목적은 수천 개의 저수준 수학 프리미티브를 제공하는 것이며 Apple의 모든 플랫폼에 이러한 프리미티브를 제공합니다.
 그래서 여기에는 iOS와 macOS뿐만 아니라 watchOS와 tvOS도 포함됩니다.
 이러한 프리미티브의 대부분은 프로세서의 마이크로 아키텍처에 맞게 조정됩니다.
 이것은 우리가 훌륭한 성과를 얻는다는 것을 의미합니다.
 그리고이 성능은 곧 에너지 절감으로 이어집니다.
 따라서 앱 개발자이고 Accelerate 프레임 워크를 사용하면 애플리케이션이 더 빠르게 실행될뿐만 아니라 배터리 수명도 단축됩니다.
 즉, 사용자가 전반적으로 더 나은 환경을 경험하게됩니다.
 이제 우리는 매우 많은 프리미티브를 제공하기 때문에 도메인 별 라이브러리로 구성하거나 그룹화하는 것이 유용하다는 것을 알게되었습니다.
 예를 들어 vDSP에서 모든 신호 처리 프리미티브를 그룹화합니다.
 예를 들어, 이것은 FFT 또는 DFT와 DCT, 고속 푸리에 변환, 이산 코사인 변환이 될 것입니다.
 VImage는 이미지 처리 프리미티브를 포함합니다.
 색상 공간 변환을 수행 중이라면이 라이브러리가 적합합니다.
 VForce는 벡터 버전의 초월 함수를 포함합니다.
 그래서 예를 들어 사인과 코사인.
 또한 선형 선형 대수뿐만 아니라 조밀 한 선형 대수를 지원하며 BNNS라는 신경망 용 특수 라이브러리가 있습니다.
 기본 신경망 서브 루틴의 약자입니다.
 Accelerate 프레임 워크의 일부는 아니지만 매우 밀접한 관련이 있으며,이 라이브러리는 CPU에 대한 벡터 프로그래밍 도구 인 simd와 여러 가지 다양한 무손실 데이터 압축 알고리즘이 포함 된 Compression과 같은 라이브러리를 포함하고 있습니다.
 먼저 첫 번째 라이브러리를 살펴 보겠습니다.
 우리는 vDSP를 살펴볼 것입니다.
 VDSP는 최첨단 신호 처리 라이브러리이며 광범위한 신호 처리 프리미티브를 포함합니다.
 이는 덧셈 및 뺄셈과 같은 배열에 대한 기본 산술 연산부터 회선 및 FFT와 같은 더 복잡한 연산까지 다양합니다.
 성공적인 앱 개발자이고 어쩌면 과거에 FFT를 피했을 때 Accelerate를 사용하여 어떻게 쉽게 만들 수 있는지 보여 드리고자합니다.
 몇 줄의 코드만으로 그 작업을 할 수 있습니다.
 그리고 나는 그 모범을 보았습니다.
 노이즈에서 신호를 추출하는 방법을 보여 드리겠습니다.
 여기에 오디오 신호가 있습니다.
 이것은 기본 신호입니다.
 아직 아무 소리도 추가하지 않았으므로 맨 아래에 두 개의 슬라이더가 있음을 알 수 있습니다.
 왼쪽 하단에는 잡음을 추가 할 수있는 슬라이더가 있으며,이 슬라이더를 볼 수 있습니다.
 또한 두 번째 슬라이더를 사용하여 Threshold라는 노이즈를 제거합니다.
 또한 오른쪽 하단에 토글 스위치가 있습니다.
 이것은 내가 다른 도메인 아래에서 이것을 보게한다.
 그래서 현재 우리는 시간 영역에서이 신호를보고 있습니다.
 몇 가지 분석을하고 주파수 도메인에서이 신호를 봅니다.
 왼쪽에있는 모든 스파이크를 볼 수 있습니다.
 그것들은 신호의 주파수 성분입니다.
 파란색 막대가 나타납니다.
 파란색 막대가 임계 값 슬라이더이므로 이동할 수 있음을 알 수 있습니다.
 그래서 제가 지금 할 일은 신호에 약간의 잡음을 더하는 것입니다.
 실제로, 꽤 많은 잡음을 추가합시다.
 그래서 내가 아직도 관심을 가지고있는 신호가 좌측의 스파이크 또는 가장 높은 높이의 스파이크 인 다른 방법으로 표현된다는 것을 볼 수 있습니다. 그리고 우리가 추가 한 것은 우리가 소음의 유형입니다. 이것은 백그라운드 노이즈입니다.
 따라서 모든 곳에서 균등하게 분산 된 스파이크가 있지만 낮은 수준의 스파이크입니다.
 이제는이 잡음을 없애고 이것을 수행 할 방법은이 임계 값을 약간 높게 움직이는 것입니다.

내가하는 것처럼 일어나는 일은 뒤에서이 임계 값보다 작은 주파수 성분을 찾아서 제거하는 것입니다.
 우리는이 파란 막대보다 낮은 높이의 스파이크가 있다면 효과적이라고 말하고 있습니다. 우리는 소음을 가장하고 제거하려고합니다.
 따라서 계속 슬라이딩하면이 노이즈가 제거됩니다.
 그리고 시간 영역으로 돌아 가면 잡음을 제거한 것을 볼 수 있습니다.
 그리고 당신이 나를 믿지 않으면, 우리는 임계 값을 제거 할 수 있습니다. 그리고 이것은 여전히 ​​모든 노이즈가 추가 된 것처럼 보입니다.
 그래서 우리가 어떻게하는지 보여 드리죠.
 우선 우리가해야 할 일은 먼저 신호에 대한 분석을 수행하는 것입니다.
 그것이 스위치로 처리됩니다.
 그런 다음 노이즈를 나타내는 주파수 구성 요소를 찾아 제거합니다.
 우리가 해본 후에 우리는 오디오 신호를 재구성 할 것입니다.
 그래서 몇 가지 코드를 보여 드리겠습니다.
 우리가 여기에서 사용할 것은 이산 코사인 변환 또는 DCT입니다.
 여기서 DCT CreateSetup을 볼 수 있습니다.
 이 문맥은 우리가 할 일의 유형을 설명 할뿐만 아니라이 일을 수행 할 수있는 공간을 제공 할 것입니다.
 이 경우 유형 2 DCT를 사용합니다.
 그런 다음이 컨텍스트를 실행 함수에 전달할 것입니다.
 이것은 실제로 작업을 수행합니다.
 분석이 끝나면 노이즈를 제거하고 싶습니다.
 여기가 바로 마술이 일어나는 곳입니다.
 이 루틴은 그 임계 값보다 작은 주파수 성분을 식별하여 0으로 만듭니다.
 그것은 그것을 제로로 만들 것입니다.
 우리가 해본 후에, 우리는 오디오 신호를 재구성하려고합니다.
 다시, CreateSetup을 사용하여 컨텍스트를 만들어야합니다.
 이 경우 우리는 유형 3 DCT를 사용하여 신호를 재구성합니다.
 그런 다음이 컨텍스트 DCT를 실행하여 실제로 오디오 신호를 재구성하는 작업을 수행합니다.
 그래서 우리가 보여준 것은 vDSP를 사용하여 오디오 신호에서 특정 유형의 잡음을 제거 할 수있는 방법의 예입니다.
 vDSP를 사용하여 이미지에서 특정 유형의 노이즈를 제거 할 수있는 방법의 예를 보여 드리고자합니다.
 이 경우 오래된 신문 사진을 복원 할 것입니다.
 그래서 우리가 한 것은이 이미지를 찍은 것입니다. 우리는 2 톤 스크린을 적용했습니다.
 이것은 오래된 신문 사진을 나타낼 수 있습니다.
 그리고 우리가하려는 것은이 화면을 제거하는 것입니다.
 우리는 당신이 보는 유물을 제거하려고 노력할 것입니다.
 현재, 우리는 벗어 났으므로 아무 것도하지 않습니다.
 우리가 할 일은 실제로이 스크린의 샘플을 취하는 것입니다. 샘플에서 마스크를 생성하고 그 샘플을 이미지에 적용하여 제거하려고합니다.
 그래서 첫 번째 시도를 보여 드리겠습니다.
 따라서 우리는 특정 임계 값에서 주파수 구성 요소를 식별하고, 제거하려는 임계 값보다 높은 모든 주파수 구성 요소를 식별합니다.
 그리고 임계 값을 너무 낮게 설정하면 아티팩트를 제거 할뿐만 아니라 이미지도 상당히 제거합니다.
 우리가 너무 높게 설정하면, 우리는 아무것도하지 않는다는 것을 알 수 있습니다.
 중간 정도의 것 같습니다.
 매체가 이미지의 손상을 너무 많이주지 않으면 서 이미지의 아티팩트를 너무 정확하게 올바르게 식별합니다.
 그래서 우리가 어떻게하는지 보여 드리죠.
 높은 수준에서 우리가 할 일은 이미지와 샘플에 대해 FFT를 수행하는 것입니다.
 우리는 그 샘플로부터 마스크를 만들어 이미지에 적용 할 것입니다.
 일단 우리가 해냈다면 원본 이미지를 재구성 할 것입니다.
 그래서 몇 가지 코드를 살펴 보도록하겠습니다.
 우리는 FFT를 할 것입니다.
 이것은 2의 거듭 제곱이어야 함을 의미합니다.
 이것이 log2 호출을 보는 이유입니다.
 1024 x 1024는 이미지 크기입니다.
 그러면 fft2d zrop에 전달할 것입니다.
 이것은 꽤 입소문입니다.
 여기에서 중요한 부분은 위치가 어긋나는 것을 의미합니다.
 그래서 결과를 위해서 임시 공간을 만들어야합니다.
 우리는이 복잡한 구조를 저장하려고합니다. 그리고 실제로 이것은 복소수를 실수 배열을 한 배열에, 실수 배열을 두 배열에 저장하려고합니다.
 우리는 방향을 지정해야합니다.
 이 경우 앞으로 FFT를 수행 할 것입니다.
 이제 아티팩트 제거가 조금 더 진보되어서, 나는 이것을 매우 높은 수준으로 만 진행할 것입니다.
 현재 온라인에서 사용할 수있는 샘플 응용 프로그램을 다운로드하는 것이 좋으며이 루틴들 각각은 vDSP로 문서화되어 있으며 훌륭한 온라인 설명서가 있습니다.
 우리가해야 할 일은 샘플의 주파수 성분의 크기를 확인하는 것입니다.
 그런 다음 제거 할 구성 요소를 확인하려고합니다.
 그런 다음 마스크를 작성하려고합니다.
 일단 우리가 그렇게하면, 그 마스크를 이미지에 적용 할 것입니다.
 사실 우리가하고있는 일은 우리가 제거하고자하는 구성 요소를 0으로 유지하고 유지하고자하는 구성 요소를 1 개 더하는 것입니다.
 이미지를 재구성하기 위해 다시 zrop을 사용할 것입니다.

이것은 FFT이기 때문에 컨텍스트를 다시 사용하게됩니다.
 이 경우 복잡한 구조이므로 이미지를 두 개의 배열에 저장하는 것이 중요합니다.
 그래서 짝수 픽셀은 실제 배열에있게 될 것이고, 홀수 픽셀은 허수에있게 될 것입니다.
 그리고 다시 우리는 방향을 정할 것입니다.
 이 경우 역 FFT를 사용합니다.
 이제 나는 기어를 한동안 바꿔 가고 싶습니다.
 이전에 두 가지 예를 보여 주었고 vDSP에 대한 두 가지 작업 예제가 있었고 그 다음에 뒤로 작업했으며 예제를 어떻게 구성했는지 보여주었습니다.
 우리는 거꾸로 일하고 움직이는 조각들을 보여주었습니다.
 이 다음 라이브러리에서는 기본 구성 요소부터 시작하고 싶습니다.
 나는 결과를 구축하려고합니다.
 그래서 우리는 simd를 살펴볼 것입니다. 그리고 우리는 기본적인 저수준 프리미티브에서 시작하여 회전까지 구축 할 것입니다.
 이 경우 3D 객체의 회전.
 높은 수준에서 simd는 벡터 처리 장치의 추상화입니다.
 그래서 당신이 할 수있는 것은 벡터와 매트릭스 객체를 선언하는 것입니다. 그리고 여러분은이 객체들에 대한 연산을 수행하게되고, 이것은 프로세서의 벡터 하드웨어에 직접 매핑 될 것입니다.
 코드 예제를 보여 드리겠습니다.
 여기서 우리는 두 개의 배열을 취할 것이고, 우리는 그 구성 요소의 평균을 구할 것입니다.
 따라서 각 스케일러 구성 요소를 반복적으로 살펴보고 함께 추가하고 2로 나눕니다.
 이것은 정말로 느려질 것입니다.
 대신 이러한 배열을 simd float4 벡터 유형으로 선언 할 수 있습니다.
 그럼 우리는이 객체들에 대한 기본적인 산술 연산을 수행 할 수 있습니다.
 따라서 자연스럽게 계산을 표현할 수있을뿐만 아니라 가능한 한 빨리 실행됩니다.
 그리고 이것은 모든 애플 플랫폼에서 작동 할 것입니다.
 Simd에는 엄청난 기능이 있습니다.
 벡터 및 행렬 객체 외에도 이러한 객체에 대해 산술 연산을 수행 할 수 있습니다.
 확장 기능이 있습니다.
 예를 들어, 제품과 클램프를 사용합니다.
 또한 초월 함수 (예 : 사인 및 코사인은 물론 쿼터니언)를 지원합니다.
 쿼터니언은 3 차원에서 회전을 표현하는 데 매우 유용합니다. 실제로 이들에 대해 조금 더 이야기하고 싶습니다.
 그래서 저는 코딩 예제를 통해 여러분을 안내 할 것입니다.
 여기에 압축을 푸는 데는 약간의 어려움이 있습니다.
 그래서 우리는 오른쪽에서 시작할 것입니다.
 우리는 하나의 구가 있습니다.
 이것이이 회색 구체입니다.
 그리고 당신은이 붉은 점에 주목할 것입니다.
 그리고 그것은 실제로이 벡터의 팁입니다.
 우리는 simd float3 벡터를 선언했습니다.
 우리는 x와 y 성분을 0으로, z 성분을 1로 설정했습니다.
 그래서 우리에게 나옵니다.
 그리고 그 빨간 점은 그 벡터의 끝으로 표현됩니다.
 이제 쿼터니온을 사용하여이 벡터에서 회전을 수행 할 것입니다.
 기술적으로, 우리는 전체 장면을 회전시키고 있지만 일러스트레이션을 위해 우리는이 벡터를 회전시키고 있다고 말할 것입니다.
 회전에 쿼터니언을 사용하는 경우 축과 회전 각도를 지정해야합니다.
 또는 다른 방법으로 말하자면, 무엇에 대해 그리고 얼마만큼 회전하고 있습니까?
 그래서 우리는 x 축에 대해 회전 할 것이고, 우리는 3 라디안 이상으로 pi를 회전시킬 것입니다.
 simd act 함수를 호출하여 순환 게재를 적용합니다.
 이렇게하면 해당 벡터에 쿼터니언의 동작이 적용되고 회전 된 벡터가 반환됩니다.
 그럼 이제 살펴 보겠습니다.
 따라서 일반적으로 단일 축을 따라 회전하는 데 관심이 없습니다.
 일반적으로 여러 축을 따라 회전하고 싶은데 회전 행렬에 익숙하다면 매우 자연스러워 보일 것입니다.
 회전 행렬과 마찬가지로 곱셈을 사용하여 회전을 결합 할 수 있으며 회전 행렬과 마찬가지로 곱셈은 교환 가능하지 않습니다.
 즉, 피연산자의 순서를 변경하면 회전 순서가 변경됩니다.
 여기서 우리가하는 일은 pi를 3 라디안 이상으로 회전시킨 다음 pi를 3 라디안 이상으로 오른쪽으로 회전시키는 것입니다.
 그리고 우리는 이것을 하나의 회전으로 결합 할 것입니다.
 쿼터니언과 simd로 실제로 할 수있는 흥미로운 것들 중 일부는 보간법이며 두 가지 유형의 보간법을 지원합니다.
 첫 번째는 Slerp입니다.
 그것은 Spherical Linear Interpolation을 나타내며 실제로 두 가지 변종이 있습니다.
 우리는 simd slerp를 가지고 있습니다.이 두 점 사이의 가장 짧은 호 (이 경우 파란색과 녹색 사이)를 발견 할 수 있으며, 가장 긴 호를 찾을 수있는 가장 긴 simlerp를가집니다.
 그러면 실제로 그것이 단위 영역 뒤쪽으로 이동하는 것을 볼 수 있습니다.
 두 번째 변형은 스플라인입니다.
 스플라인은 두 개 이상의 회전이 있으면 정말 유용합니다.
 예를 들어, 여기서는 회전 배열 사이를 보간 할 것입니다. 여기에 보일러 플레이트 코드가 있습니다. 그래서 Spline 호출에만 집중하길 바랍니다.
 우리가하는 일은 모든 개별 회전을 반복하고 스플라인을 적용하는 것입니다.

따라서 스플라인으로 지정해야하는 것은 두 보간 사이의 보간뿐 아니라 이전 및 다음 보간도 포함됩니다.
 그리고 이것은 이것이 어떻게 생겼는지입니다.
 따라서 게임 개발자라면 개별 벡터를 회전하는 데 관심이 없을 것입니다.
 회전하는 물체에 관심이있을 것입니다.
 그래서 우리는 당신을 위해 그것을 가지고 있습니다.
 우리에게는 큐브가 있습니다.
 그것은 여러 벡터에 의해 표현되며, 일련의 8 회전을 거칩니다.
 왼쪽에서 Slerp를 사용하여 회전을 추적 할 것이며, 오른쪽에서는 Spline을 사용할 것입니다.
 Slerp가 어떻게 생겼는지 보여 드리겠습니다.
 그리고 선형 보간이기 때문에 볼 수 있습니다. 매번 방향을 바꾸면 날카로운 모서리가 생깁니다.
 반면에 우리가 스플라인을 볼 때 - 이전 및 다음 회전도 알고 있기 때문에 이러한 둥근 모서리로 끝납니다.
 다시 한번 봅시다.
 이제는 모든 주제를 빠르게 살펴 보았습니다. 간단히 요약하자면 vDSP를 살펴보고 두 가지 예를 보여 줬습니다.
 첫 번째는 노이즈에서 신호를 추출하는 방법이었고 두 번째는 이미지에서 특정 유형의 아티팩트를 제거하는 방법이었습니다.
 우리는 simd를 살펴 보았고 quaternions를 사용하여 3 차원에서 회전을 표현할 수있는 방법을 보여주었습니다.
 저는 이제 제 동료 인 Luke Chang에게 비디오를 통해 할 수있는 흥미로운 것들을 보여줄 것입니다.
  고마워, 매튜
 안녕하세요.
 내 이름은 Luke Chang입니다.
 저는 벡터와 숫자 그룹의 엔지니어입니다.
 오늘은 vImage, vImage가 제공하는 기능, 그리고 vimage를 앱에서 사용하는 것이 얼마나 쉬운 지 이야기 해 보겠습니다.
 몇 줄의 코드로 앱에서 매력적인 비디오 효과를 만들 수 있습니다.
 그것을 바로 잡자.
 VImage는 우리의 이미지 처리 라이브러리입니다.
 그것은 여러 구성 요소를 가지고 있습니다.
 첫 번째 구성 요소는 변환 함수입니다.
 변환 기능은 다양한 이미지 형식간에 이미지를 이동하는 데 도움이됩니다.
 다른 이미지 형식은 다른 장점이 있습니다.
 예를 들어, RGV 형식은 디스플레이의 픽셀과 일치하므로 디스플레이에 가장 적합합니다.
 반면에, 우리는 인간이 이미지를 인식하는 것과 유사한 YCbCr 이미지를 가지고 있습니다.
 인간의 눈은 휘도 채널 인 휘도를 인식한다.
 또한, 색차 채널 인 색.
 또한 카메라는 YCbCr 형식을 사용하여 이미지를 캡처합니다.
 따라서 수렴 기능을 사용하면 이러한 형식간에 이미지를 쉽게 이동할 수 있습니다.
 다음으로 우리는 기하학 함수를 가지고 있습니다.
 기하학 기능은 이미지의 크기 또는 방향을 변경합니다.
 우리는 이미지를 확대하거나 축소 할 수있는 이미지 스케일을 가지고 있습니다.
 우리는 Lanczos 알고리즘을 사용하기 때문에 작업 후에는 고품질 출력을 얻습니다.
 시계 방향 또는 반 시계 방향으로 이미지를 회전시킬 수있는 vImage 회전도 있습니다.
 다음으로, 컨볼 루션 (convolution) 기능.
 컨볼 루션 함수의 가장 주목할만한 효과는 흐림 효과입니다.
 UI에서 사진의 흐림 효과를 항상 볼 수 있습니다.
 배경에 무언가를 단계적으로 적용하려면 흐림 효과, 흐림 효과를 적용 할 수 있습니다.
 다음으로 변환 함수.
 변환 함수는 기본적으로 행렬 곱하기입니다.
 그것은 당신이 각 픽셀의 데이터 채널에서 작동하게합니다.
 빨강을 증가 시키거나 녹색을 증가시키려는 경우, 변환 함수를 사용하여이를 수행 할 수 있습니다.
 형태.
 형태학은 이미지 자체가 아닌 이미지의 객체 크기 또는 모양을 변경합니다.
 우리는 vImage가 침식되고, vImage가 개체를 더 작게 만들고 커지게 만듭니다.
 만약 당신이 모험을 느끼고 있다면, 실제로 커널의 커스텀 쉐이프를 이러한 함수에 제공 할 수 있습니다. vImage erode와 dilate는 여러분이 제공 한 커널에 따라 오브젝트를 작게 또는 크게 만듭니다.
 그것들은 vImage의 다섯 가지 요소입니다.
 이제 vImage를 기반으로 작성한 데모 응용 프로그램을 보여주고 vImage에서 어떤 효과를 얻을 수 있는지 보여 드리려고합니다.
 내가 가지고있는 것은 백 카메라를 사용하여 이미지를 캡처하고 이미지를 화면에 놓는 실험실입니다.
 그리고 우리는 실시간으로하고 있습니다.
 이것은 라이브 스트림이므로, 술을 마시는 새는 장미 옆에서 움직이는 것을 볼 수 있습니다.
 좋아, 내가 보여주고 싶은 첫 번째 효과는 채도 효과입니다.
 이 효과는 많은 사진 편집 소프트웨어에서 볼 수 있습니다.
 그래서 나는 그 색을 내고 싶습니다.
 내가 할 수있는 것은이 슬라이더를 오른쪽으로 움직이면 빨간색과 녹색이 실제로 녹색이됩니다.
 그리고 다른면에는 흰 장미가 있습니다.
 나는 흰 장미의 색깔이 저에게 흥미롭지 않다고 느낍니다.
 청중의 초점을이 이미지의 구성과 대비에 집중하고 싶습니다.
 이 이미지가 흑백 이미지가되는 지점까지 이미지의 채도를 낮추려면 왼쪽으로 밀 수 있습니다.
 이제 색상은이 이미지에서 산만 해지지 않으며 뷰어는 컴포지션과 대비에 집중할 수 있습니다.
 괜찮아.
 그럼, 어떻게해야할까요? 우리가 취해야 할 몇 가지 조치가 있습니다.
 우선 카메라에서 이미지를 가져와야합니다. 그런 다음 vImage를 사용하여 처리하고 효과를 적용하려면 vImage 용 입력 및 출력 버퍼를 준비해야합니다.

그런 다음 사실상 vImage 함수를 호출하여 이러한 효과를 적용하고 결과를 화면에 표시합니다.
 먼저 vImage 함수를 사용하여 효과를 적용하는 방법에 대해 이야기하겠습니다.
 내가 보여주는 효과는 채도 효과이며 여기서는 채도를 조절하는 공식입니다.
 기본적으로 픽셀에서 바이어스를 제거하고 곱셈을 사용하여 포화 효과를 적용한 다음 바이어스를 다시 픽셀에 적용하려고합니다.
 VImage는 vImage 행렬 곱셈 인이 연산을 수행하는 함수를 정확하게 가지고 있습니다.
 VImage 행렬 곱셈은 바이어스를 제거하기 위해 preBias (이 경우 마이너스 128)를 취하고 채도는 [비가역] 지점이고 이미지는 정수이므로이 채도 값을 먼저 고정 소수점 형식으로 변환하려고합니다.
 우리는 Q12를 고정 소수점 형식으로 선택 했으므로 0x100의 약수를 선택했습니다.
 그리고 나서 우리는 128 배의 postBias를 가지고 픽셀에 바이어스를 되돌려줍니다.
 매트릭스 자체는 정말 간단합니다.
 우리가 원하는 것은 CbCr 채널의 스케일링을하는 것뿐입니다.
 그래서 행렬 자체는 단순한 스케일러이며 CbCr 채널에이 스케일러를 곱하려고합니다.
 우리는 모든 정보를 가지고 있으므로 vImageMatrixMultiply를 호출하고 한 줄의 코드, 한 번의 함수 호출만으로 채도 효과를 얻을 수 있습니다.
 이제 우리가해야 할 다른 단계로 돌아가 보겠습니다.
 우리는 카메라에서 이미지를 가져와야합니다.
 어떻게해야합니까? 우리는 델리게이트 메서드를 작성해야하며 카메라가 제공하는 것은 CV 이미지 버퍼입니다.
 그래서 우리는 완충약을 얻는다.
 이 버퍼가 CPU에 액세스 할 수 있는지 확인해야합니다.
 그것은 vImage가 사는 곳입니다.
 효과를 적용한 후에는 어떤 효과가 있더라도이 픽셀 버퍼의 기본 주소를 잠금 해제해야 카메라가이 메모리를 다시 사용할 수 있습니다.
 두 번째 단계에서는 vImage 입력 및 출력 버퍼를 준비해야합니다.
 이미 CV 이미지 버퍼에이 이미지가 있습니다.
 높이와 너비와 같은 정보를 얻는 것만으로 vImage 버퍼 객체에 패키지 할 수 있으므로 vImage 라이브러리에서이를 사용할 수 있습니다.
 루미넌스 및 크로 미 넌스 채널에 대해이 작업을 수행합니다.
 이제 출력 버퍼를 준비해야합니다.
 출력 이미지에 아직 할당 된 메모리가 없으므로이를 수행해야하며 vImage에는이를 수행 할 수있는 vImage 버퍼가있는 편리한 함수가 있음을 기억하십시오.
 이 높이, 너비 및 픽셀 당 비트를 감안할 때 vImage 버퍼는이 이미지를 보유 할만큼 큰 메모리를 할당 한 다음 vImage 버퍼 객체를 만들어 vImage 라이브러리에서 사용할 수 있도록합니다.
 마지막 단계에서는이 프로세스 이미지를 화면에 표시합니다.
 앞서 말했듯이 RGB는 실제로 디스플레이에 가장 적합한 형식이므로 변환 함수를 사용하여 YCbCr 이미지를 RGB 이미지로 변환 해 봅시다.
 UI가 cgImage 객체를 기대하기 때문에 우리는 객체를 생성해야합니다.
 vImage에는 편의 기능이 있습니다.
 vImageCreatesCGImage FromBuffer는 이미 vImage에있는 버퍼를 기반으로 cgImage를 만드는 데 도움이됩니다.
 한가지주의 할 점은 실제로 이미지의 큰 데이터 버퍼를 다른 곳으로 복사하지 않는다는 것입니다.
 이 이미지 버퍼에 컨테이너를 추가하는 cgImage 객체를 만드는 것입니다.
 따라서 우리는 cgImage가 필요로하는 정보 만 채우고 데이터를 복사하는 대신 cgImage 객체를 생성합니다.
 일단 이미지 뷰에 cgImage 객체를 보내면 화면에 cgImage 객체가 표시됩니다.
 그래서 간단합니다.
 네 단계와 자신 만의 효과를 만들 수 있습니다, 우리는 당신에게 채도 효과를 보여줍니다.
 이제 vImage로 할 수있는 다른 효과가 있습니다.
 우리는 전에 말한 것처럼 회전을 할 수 있습니다. 시계 반대 방향으로 이미지를 회전시킬 수 있습니다.
 우리는 배경을 흐리게 처리하거나 무언가를 단계적으로 수행 할 수 있습니다.
 그리고 이미지에 복고풍 느낌을 더하기를 원한다면 흑백 이미지에 대한 디더링과 컬러 이미지에 대한 색 양자화를 수행 할 수 있습니다.
 앱에서 어떻게 보이는지 보여 드리겠습니다.
 다시 한번, 회전을 제어하기위한 슬라이더가 있습니다.
 시계 반대 방향으로 회전하거나 시계 방향으로 회전 할 수 있습니다.
 이제 나는 흐리게 효과를 시험해보고 싶다.
 여기를 클릭하겠습니다.
 그리고 나는 더 흐리게하거나 왼쪽으로 미끄러지기를 적용 할 수 있으며, 장미를 전경으로 가져올 수 있습니다.
 흑백의 경우 디더링을 사용할 수 있습니다.
 이제 흑백 이미지, 그레이 스케일은 이제 점의 밀도로 표현됩니다. 이는 디더링 효과입니다.
 그리고 우리는 이것을 위해 액센트와 디더링 알고리즘을 사용합니다. 그리고 나중에 어떻게 할 것인지를 보여줄 것입니다. 그리고 색상 양자화를 위해서 우리는 룩업 테이블을 가지고 있습니다.
 그리고이 슬라이더를 움직여서 양자화 레벨을 높일 수 있습니다.
 슬라이더를 오른쪽으로 움직이면이 이미지에서 더 적은 수의 색상을 사용할 수 있습니다.
 그것은 일종의 독창적 인 일입니다. 90 년대 나 80 년대와 같이 컴퓨터 화면이 어떻게 보이는지입니다.
 괜찮아.
 그래서 우리가 어떻게하는지 보여 드리죠.
 회전 효과의 경우 vImageRotate를 호출하고 회전 각도를 지정하면 반 시계 방향 또는 시계 방향으로 이미지를 잘 정렬 할 수 있습니다.

흐림 효과는 TentConvolve를 사용합니다.
 블러 효과는 커널의 크기에 의해 제어됩니다.
 커널이 클수록 더 많은 흐려짐을 얻을 수 있습니다.
 디더 효과는 기본적으로 8 비트 이미지를 1 비트 이미지로 변환하는 것입니다.
 동시에 디더링 알고리즘을 지정할 수 있습니다.
 이 경우 Atkinson 디더링 알고리즘을 사용했습니다.
 색상 양자화, 양자화 레벨을 사용하여 RGB 채널에 대한 조회 테이블을 생성했으며 vImageTableLookUp을 호출하여이 테이블 조회를 RGB 채널에 적용하여 화면의 색상 수를 제한했습니다.
 그것들은 제가 여러분에게 보여주고 자했던 네 가지 부가적인 효과이며, 이제는 다음 주제로 넘어갈 좋은시기라고 생각합니다.
 LINPACK 벤치 마크.
 우리는 Accelerate의 기능에 대해 이야기했습니다.
 앱에서 Accelerate에서 사용하는 것이 얼마나 쉬운 지 이야기합니다.
 Accelerate가 실제로 얼마나 빠릅니까?
 LINPACK Benchmark는이를 수행하기위한 완벽한 도구입니다.
 LINPACK 벤치 마크 란 무엇입니까? 기본적으로 컴퓨터에서 선형 시스템을 얼마나 빨리 해결할 수 있는지 측정하려고합니다.
 실제로 세 가지 LINPACK 벤치 마크가 있습니다.
 첫 번째는 100 x 100 선형 시스템을 해결하는 것입니다.
 두 번째 문제는 1000 x 1000의 문제를 해결하는 것입니다.
 가장 흥미로운 것 인 마지막 것이 바로 오늘 사용하게 될 것입니다.
 컴퓨터의 계산 능력을 최대한 활용하려는 시스템을 최대한으로 해결할 수 있습니다.
 Accelerate를 사용하여 iPhone X의 성능을 살펴 보겠습니다.
 성능은 기가 플롭스로 측정됩니다. 이중 정밀도가 iPhone 5S, iPhone 6, iPhone 6S, iPhone 7을 따라 잡을 수 있으며, iPhone X는 약 28 인치입니다.
7 기가 플롭스.
 그것은 배정도입니다.
 단 정밀도를 살펴 보겠습니다.
 다시 말하지만, 우리는 공간을 다 써 버렸고, 우리는 그것이 더 가까워 지도록 노력해야합니다.
 IPhone X는 68 기가 플롭스입니다.
 이제 당신은 생각할지도 모릅니다.
 그러나 시간이 지남에 따라 성능이 향상되므로 시간이 지남에 따라 성능이 향상되지만 실제로는 절반에 불과합니다.
 컴퓨터에 추가적인 계산 능력을 갖기 위해 마이크로 아키텍처가 변경되면이 추가 계산 능력을 완전히 활용하려면 일치하는 [들리지 않음]이 필요합니다.
 그리고 그것이 우리가 들어오는 곳입니다.
 이것은 5 세대 모든 iPhone에서 실행되는 LINPACK Benchmark 실행 파일과 동일합니다.
 그들은 모두 조금도 바꾸지 않고 Accelerate를 사용하여 최고의 성능을 얻었습니다.
 앱에서도 마찬가지입니다.
 앱에서 Accelerate를 사용하면 우리가 지원하는 모든 아키텍처에서 최고의 성능을 자동으로 얻을 수 있습니다.
 또한 Accelerate는 여러 플랫폼에서 지원됩니다.
 Accelerate는 macOS, iOS, tvOS, watchOS에서 작동합니다.
 따라서 내일 애플이 새로운 아키텍처 나 새로운 플랫폼을 출시한다면 걱정할 필요가 없다고 가정 해 봅시다.
 앱을 다시 작성하고 바로 연결하기 만하면됩니다.
 최신 릴리스 플랫폼 또는 아키텍처에서 최고의 성능을 자동으로 얻게됩니다.
 간단히 요약하자면 Accelerate는 다양한 기능을 지원합니다.
 아마도 Accelerate에서 필요한 것을 찾을 수있을 것입니다.
 사용할 수없는 것이 필요한 경우 기능 요청을 보내주십시오.
 우리는 지속적으로이 기능 요청을보고 평가 한 다음 빌드에 넣습니다.
 사실, 우리의 최고의 기능 중 일부는 기능 요청에서 왔습니다.
 가속은 사용하기 쉽습니다.
 대개의 경우 하나의 함수 호출이고 작업이 완료됩니다.
 빠르고 에너지 효율이 높기 때문에 앱의 응답 성이 향상되고 배터리 수명이 더 길어집니다.
 Accelerate는 플랫폼과 아키텍처 전반에서 이식 가능합니다.
 우리가 지원하는 모든 플랫폼과 우리가 지원하는 모든 아키텍처에서 최상의 성능을 얻었습니다. 가장 중요한 부분은 코드를 변경할 필요가 없다는 것입니다.
 자세한 내용은 개발자의 온라인 설명서를 참조하십시오.
사과.
com 및 모든 데모 응용 프로그램, 간단한 코드 및 세션 자료를 온라인에서 사용할 수 있습니다.
 내일 오후 2시에 실험실 수업이 있습니다.
 나는 너희들을 거기에서 만날 것을 고대한다.
 질문이 있거나 Accelerate에 대해 더 알고 싶다면 거기에있는 것을보고 싶습니다.
 그것은 오늘 우리의 프리젠 테이션을위한 것입니다.
 와 주셔서 감사합니다.
 좋은 하루 되세요.
